<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Datartisan数据工匠 - 知乎专栏</title><link>https://zhuanlan.zhihu.com/datartisan</link><description></description><lastBuildDate>Wed, 08 Mar 2017 02:16:44 GMT</lastBuildDate><generator>Ricky</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>如何才能进入数据孵化器中心</title><link>https://zhuanlan.zhihu.com/p/24326162</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-f6b2362c42b7ac848c086d54cde64c42_r.png"&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;提示：文章中划线部分涉及的链接列在文章的末尾。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们&lt;a href="http://www.thedataincubator.com/?utm_source=Blog&amp;amp;utm_medium=Link&amp;amp;utm_campaign=Preparing4Incubator" data-editable="true" data-title="数据孵化器中心" class=""&gt;数据孵化器中心&lt;/a&gt;收到成千上万份想要加入我们数据分析协会的申请。我们的要求非常高，以致于经常有人问我们以下问题：“我要怎么做才能加入你们的数据分析协会呢？” &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-f6b2362c42b7ac848c086d54cde64c42.png" data-rawwidth="1055" data-rawheight="660"&gt;接下来我将介绍我们最看重的五个技能以及相应的学习资源，虽然我们并不要求申请者同时拥有这些技能，但是大多数申请人需要掌握大部分的技能。  &lt;/p&gt;&lt;h3&gt;爬虫技术&lt;/h3&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-cfd662b0253986f45cc1e65d4eaf90f3.png" data-rawwidth="1019" data-rawheight="739"&gt;互联网上有许多数据，你需要学习如何获取它们。不管它们的格式是 JSON，HTML 或者其他一些自制的格式，你都应该能够轻松地把它们抓取下来。像 Python 专业的现代脚本语言是写爬虫程序的理想工具。在 Python 中，有许多便捷的软件库帮助我们更好地完成爬虫工作，比如 &lt;a href="https://docs.python.org/2/library/urllib2.html" data-editable="true" data-title="urllib2"&gt;urllib2&lt;/a&gt;,&lt;a href="http://docs.python-requests.org/en/latest/" data-editable="true" data-title="requests"&gt;requests&lt;/a&gt;,&lt;a href="https://pypi.python.org/pypi/simplejson/" data-editable="true" data-title="simplejson"&gt;simplejson&lt;/a&gt;,&lt;a href="https://docs.python.org/2/library/re.html" data-editable="true" data-title="re"&gt;re&lt;/a&gt; 和 &lt;a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/" data-editable="true" data-title="beautiful soup"&gt;beautiful soup&lt;/a&gt;。进阶的爬虫相关软件库有处理错误机制的 &lt;a href="https://pypi.python.org/pypi/retrying" data-editable="true" data-title="retrying"&gt;retrying&lt;/a&gt; 和 并行处理的 &lt;a href="https://docs.python.org/2/library/multiprocessing.html" data-editable="true" data-title="multiprocessing"&gt;multiprocessing&lt;/a&gt;。  &lt;/p&gt;&lt;h3&gt;SQL&lt;/h3&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-8f13eea8d54586c6a465407b694483aa.png" data-rawwidth="1116" data-rawheight="627"&gt;当你获得一大堆结构化数据后，接下来你需要考虑的问题是如何储存它们？SQL 是一门原始的查询语言，以至于许多语言都有 SQL 查询接口，比如 R 语言中的 &lt;a href="https://code.google.com/p/sqldf/" data-editable="true" data-title="sqldf"&gt;sqldf&lt;/a&gt;和 &lt;a href="https://hive.apache.org/" data-editable="true" data-title="HIVE" class=""&gt;HIVE&lt;/a&gt;。通常情况下，安装 SQL 的过程非常麻烦。不过幸运的是，这里有一个&lt;a href="http://sqlzoo.net/wiki/Main_Page" data-editable="true" data-title="在线学习网站"&gt;在线学习网站&lt;/a&gt;，该网站提供了一个交互式环境，你可以在网站上提交自己的 SQL 查询代码。此外，如果你想在本地环境中使用 SQL，那么你可以尝试使用 &lt;a href="http://www.sqlite.org/" data-editable="true" data-title="SQLite"&gt;SQLite&lt;/a&gt;。  &lt;/p&gt;&lt;h3&gt;数据框&lt;/h3&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-f2803ddee7ca46381eea162717016d3f.png" data-rawwidth="560" data-rawheight="413"&gt;虽然 SQL 可以很好地处理大批量的数据集，但是 SQL 中缺乏机器学习模型和可视化的工具。因此我们通常利用 SQL 或者 MapReduce 来预处理数据，然后利用 R 语言中的数据框或者 Python 的 &lt;a href="http://pandas.pydata.org/" data-editable="true" data-title="pandas"&gt;pandas&lt;/a&gt;来做进一步的数据分析。对于 pandas 来说，在视频网站 YouTube 上有其创始人 Wes McKinney 发布的教学视频。你可以&lt;a href="https://www.youtube.com/watch?v=w26x-z-BdWQ" data-editable="true" data-title="点此"&gt;点此&lt;/a&gt;观看视频，并跟着&lt;a href="https://github.com/estimate/pandas-exercises" data-editable="true" data-title="github"&gt;github&lt;/a&gt;上的代码亲自练习。  &lt;/p&gt;&lt;h3&gt;机器学习模型&lt;/h3&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-177b5dc9b5187563572354c9f0ace3ce.png" data-rawwidth="909" data-rawheight="578"&gt;许多数据分析只需要用到 select, join 和 groupby（或者 map 和 reduce）等操作即可完成，但是有时候你需要构建更深入的机器学习模型。在你接触复杂的算法之前可以考虑使用一些相对较简单的算法，比如&lt;a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier" data-editable="true" data-title="朴素贝叶斯模型"&gt;朴素贝叶斯模型&lt;/a&gt;和&lt;a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)" data-editable="true" data-title="正则化回归模型"&gt;正则化回归模型&lt;/a&gt;。在 Python 中，我们利用 &lt;a href="http://scikit-learn.org/stable/" data-editable="true" data-title="scikit-learn"&gt;scikit-learn&lt;/a&gt;来实现相应的机器学习模型，而在 R 语言中我们主要使用 &lt;a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/glm.html" data-editable="true" data-title="glm"&gt;glm&lt;/a&gt; 和 &lt;a href="http://cran.r-project.org/web/packages/gbm/gbm.pdf" data-editable="true" data-title="gbm"&gt;gbm&lt;/a&gt; 软件包。你应该确保你在了解相关基础知识之后再进一步尝试更深入的算法模型。  &lt;/p&gt;&lt;h3&gt;可视化&lt;/h3&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-ff7e62e06b49a7b59d2b595b3f3009c5.png" data-rawwidth="751" data-rawheight="527"&gt;&lt;p&gt;数据科学的一个重要过程是与他人共享你的一些发现，其中数据可视化是一个非常有效的手段。Python 中提供了 MATLAB 风格的绘图软件包 &lt;a href="http://matplotlib.org/users/pyplot_tutorial.html" data-editable="true" data-title="matplotlib"&gt;matplotlib&lt;/a&gt;，R 则提供了一个非常强大的绘图工具 &lt;a href="http://cran.r-project.org/web/packages/ggplot2/ggplot2.pdf" data-editable="true" data-title="ggplot"&gt;ggplot&lt;/a&gt;。当然如果你想尝试动态可视化绘图工具的话，你可以试下 &lt;a href="http://d3js.org/" data-editable="true" data-title="d3"&gt;d3&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以上都是一些数据科学家的基础技能，掌握这些技能后对你的职业生涯会有很大的帮助。如果你仅仅只掌握了一部分技能，这是一个很好的开始。而且如果你已经做好准备的话，那么就来&lt;a href="http://www.thedataincubator.com/#apply" data-editable="true" data-title="加入我们吧"&gt;加入我们吧&lt;/a&gt;！&lt;/p&gt;&lt;blockquote&gt;更多课程和文章尽在微信号：「datartisan数据工匠」&lt;/blockquote&gt;&lt;p&gt;原文链接：&lt;a href="http://blog.thedataincubator.com/2014/09/how-to-prepare-for-the-data-incubator/" class="" data-editable="true" data-title="How to Prepare for The Data Incubator"&gt;How to Prepare for The Data Incubator&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者：Michael&lt;/p&gt;&lt;p&gt;译者：Fibears&lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/24326162&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 02 Mar 2017 11:11:32 GMT</pubDate></item><item><title>机器学习系列-广义线性模型</title><link>https://zhuanlan.zhihu.com/p/24967776</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-5b9207d6134b683d7978afd14abc880c_r.jpg"&gt;&lt;/p&gt;&lt;h2&gt;广义线性模型  &lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-1aa61b9cbb26372270b275bfa63897d7.png" data-rawwidth="670" data-rawheight="416"&gt;&lt;/h2&gt;&lt;h2&gt;高斯分布的另一种看法  &lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-657d2ab05e14b13dac020fb9c27c1d72.png" data-rawwidth="683" data-rawheight="442"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-6b4966e2ea352318b1821387295d2421.png" data-rawwidth="691" data-rawheight="510"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-49f5410660db324756c4837672ec422c.png" data-rawwidth="738" data-rawheight="500"&gt;&lt;h2&gt;伯努利分布--Logistic回归的含义&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-2c76a5cb41585cb3ee5ed68eff5c4574.png" data-rawwidth="739" data-rawheight="424"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-dab972404c8489dc8d9e77eed1123261.png" data-rawwidth="742" data-rawheight="370"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-5498e0c153e9dcf276e9d2bb9a80f2c4.png" data-rawwidth="739" data-rawheight="430"&gt;&lt;h2&gt;Softmax 迭代推导&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-4a93c6c19ef212b5dedd6a2efa2fface.png" data-rawwidth="746" data-rawheight="464"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-43871f0652ee53e56d97f83f769f7a38.png" data-rawwidth="743" data-rawheight="424"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-1f1355a473529589a1a4622aef61dd2d.png" data-rawwidth="740" data-rawheight="353"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-dd197cec6bcba6f7b00d6be87f6c9229.png" data-rawwidth="723" data-rawheight="303"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-5094628ec0cbc45d530b6a10fcec2c0c.png" data-rawwidth="721" data-rawheight="334"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-b8c14144f228dda46b950aba98415712.png" data-rawwidth="719" data-rawheight="359"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-897c58324e3a405208f18312635b2a36.png" data-rawwidth="746" data-rawheight="301"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-059a57eaf00e6f836ccd31e9a10a18ad.png" data-rawwidth="744" data-rawheight="383"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-3f169baa38600bdd68db61745330cb77.png" data-rawwidth="737" data-rawheight="352"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-cdd53ab1b34287fdca78053489adad85.png" data-rawwidth="741" data-rawheight="197"&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;softmax 算法在机器学习里占有很重要的地位，虽然很多机器学习的学习包已经高度的集成了softmax 算法，但从推到的过程中，可以看到很多的知识点，好像看到了算法的机器学习算法推到的大统一。广义线性模型，解释了机器学习算法的很多问题，最小二乘法的理论依据，Logistic 回归 Sigmoid 函数的由来，softmax 的推到，进一步解释了 Logistic 回归和 softmax 的关系，理论的依据终于贯通了，可以放心了。&lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/24967776&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 23 Feb 2017 11:23:27 GMT</pubDate></item><item><title>从 R 迁移到 Python 过程中你需要知道的几个软件库</title><link>https://zhuanlan.zhihu.com/p/24751059</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-45162f178160d7868e2c588c1d27f3de_r.png"&gt;&lt;/p&gt;为什么要用 Python 呢？&lt;p&gt;我喜欢用 Python 来处理机器学习问题的一个重要原因是 Python 吸取了 R 社区的优点，同时还将其进行了优化打包。我一直认为编程语言的能力取决于它的软件库，因此本文将着重介绍我经常使用的一些关于机器学习算法的 R 包和 Python 中的替代包。&lt;/p&gt;&lt;h2&gt;glm, knn, randomForest, e1071 -&amp;gt; scikit-learn&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-b735cb60415feecb707287aaf4fcfdf4.png" data-rawwidth="1966" data-rawheight="472"&gt;&lt;p&gt;R 语言的一个缺点是每个机器学习算法都有一个相应的软件包，这大大提升了用户的学习成本。Python 中的 scikit-learn 软件包则完美地解决了这个问题，scikit-learn 为许多常用的机器学习算法提供了一套相同的 API 接口。利用这个软件包，我们仅需要一行代码就可以将 LogistiRegression 模型切换成 GradientBoostingMachines 模型。&lt;/p&gt;&lt;h2&gt;reshape/reshape2, plyr/dplyr -&amp;gt; pandas&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-dbd0cb09ca4e4b777b8ef8542697164e.png" data-rawwidth="1286" data-rawheight="282"&gt;&lt;p&gt;我在之前的&lt;a href="http://blog.yhat.com/posts/R-and-pandas-and-what-ive-learned-about-each.html" data-editable="true" data-title="一篇文章"&gt;一篇文章&lt;/a&gt;中介绍了 pandas 库。pandas 吸取了 R 语言中数据清洗功能的优点并将其引入到 Python 中。该库中实现了数据框的功能和其他的一些常用操作方法，它基本包含了 reshape/reshape2 和 plyr/dplyr 中的精华之处。&lt;/p&gt;&lt;h2&gt;ggplot2 -&amp;gt; ggplot + seaborn + bokeh&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-6f15644b9a8a163f17c6e55d06c55a81.png" data-rawwidth="2402" data-rawheight="552"&gt;&lt;p&gt;在绘图方面，R 语言一直做得比 Python 好。即便如此，Python 的绘图功能已经趋于成熟了，如果你喜欢 ggplot 风格的代码，你可以尝试 Yhat 开发的 &lt;a href="https://github.com/yhat/ggplot" data-editable="true" data-title="ggplot "&gt;ggplot &lt;/a&gt;；如果你倾向于绘制统计图，那么你可以使用 seaborn；如果你想体验一些更高级的功能，那么你可以尝试下 bokeh。&lt;/p&gt;&lt;h2&gt;stringr -&amp;gt; nothing&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-45162f178160d7868e2c588c1d27f3de.png" data-rawwidth="1022" data-rawheight="454"&gt;&lt;p&gt;R 语言自带的字符串操作函数非常难用，每次当我需要处理字符串时，我都会做以下两件事：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;向大神 Hadley Wickham 表示感谢&lt;/li&gt;&lt;li&gt;导入 stringr&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;stringr 绝对是一个大救星，该软件包非常友好，我们可以轻易地安装并利用它快捷地处理字符串数据。但是对于 Python 来说，它本身就能够非常快速地处理字符串数据，所以我们不需要类似于 stringr 的第三方软件包！Python 中拥有正则表达式库 re,和一个内置的字符串软件包 string。&lt;/p&gt;&lt;h2&gt;RStudio -&amp;gt; Rodeo&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-d51e0cc01fdc9dcd218d40d929bfbc39.png" data-rawwidth="974" data-rawheight="594"&gt;&lt;p&gt;对于许多用户来说，RStudio 是 R 语言中一款非常友好的编辑器。对于 Python 来说，以前可能没有比较好用的编辑器，但现在情况已经不一样了。我们在一年前就发布了 Rodeo 的第一个版本，并在一个月前发布了适用于 Windows， OSX 和 Linux 的 2.0 版本。&lt;/p&gt;&lt;h2&gt;Knitr -&amp;gt; Jupyter&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-3a64a7978a277c5c09f70c430613733c.png" data-rawwidth="1778" data-rawheight="1014"&gt;&lt;p&gt;在 R 语言中，我们可以利用 knitr 来创建可重复的可视化分析报告，RStudio 中很早就包含了这个功能。在 Python 中，最相近的软件库是 Jupyter。Jupyter notebooks 为多种编程语言提供了一个创建可重复的可视化分析报告的交互式环境。&lt;/p&gt;&lt;h2&gt;sqldf -&amp;gt; pandasql&lt;/h2&gt;&lt;p&gt;sqldf 是 SQL 用户在 R 中轻松操作数据的一个好方法。在我刚开始喜欢使用 R 语言的时候，我经常利用 sqldf 来处理数据。据我所知，Yhat 开发了一个类似的 Python 软件库，pandasql。这两个软件库拥有同样的功能：利用 SQL 语句来操作数据框并返回相应的数据框。&lt;/p&gt;&lt;p&gt;原文链接：&lt;a href="http://blog.yhat.com/posts/moving-from-r-to-python.html" data-editable="true" data-title="ŷhat | Moving from R to Python: The Libraries You Need to Know"&gt;ŷhat | Moving from R to Python: The Libraries You Need to Know&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者：Yhat&lt;/p&gt;&lt;p&gt;译者：Fibears &lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/24751059&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 16 Feb 2017 11:13:20 GMT</pubDate></item><item><title>要优雅！一行代码搞定 R 语言模型输出！（使用 stargazer 包）</title><link>https://zhuanlan.zhihu.com/p/24511106</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-56f05adf96cc1376b57da6b636bb3570_r.png"&gt;&lt;/p&gt;&lt;h1&gt;引言&lt;/h1&gt;&lt;p&gt;使用stargazer包可以将 R 构建的模型结果以LATEX、HTML和ASCII格式输出，方便我们生成标准格式的表格。&lt;/p&gt;&lt;p&gt;再结合rmarkdown，你就可以轻轻松松输出一篇优雅的文章啦~&lt;/p&gt;&lt;p&gt;本文“使用说明”部分主要参考stargazer的&lt;a href="https://vectorf.github.io/" data-editable="true" data-title="说明文档" class=""&gt;说明文档&lt;/a&gt;。（&lt;a href="https://vectorf.github.io/" data-editable="true" data-title="Vector Blog" class=""&gt;Vector Blog&lt;/a&gt;）&lt;/p&gt;&lt;h2&gt;安装及加载&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-56d4c250592bc8549658c86984ae4705.png" data-rawwidth="735" data-rawheight="109"&gt;&lt;h2&gt;使用说明&lt;/h2&gt;&lt;p&gt;**注意：stargazer包的输出结果是相应格式的，例如输出LATEX格式，可以直接将结果粘贴进WinEdt等编辑器中输出表格。下文直接将结果以表格的形式展示。&lt;/p&gt;&lt;p&gt;我们使用 R 中自带的数据集attitude来简要说明stargazer包的用法。 &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-085904533efdf966f4acbef42cc6793c.png" data-rawwidth="740" data-rawheight="80"&gt;&lt;p&gt;attitude数据集中包括rating、complaints等八个变量：&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-a698b3b63d13f58f70a4642006035833.png" data-rawwidth="539" data-rawheight="273"&gt;&lt;/p&gt;&lt;p&gt;1.展示数据集的描述性分析和部分数据集内容&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-dd3e1c62a36ab9ab732389e3778daa94.png" data-rawwidth="735" data-rawheight="109"&gt;&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-05c34b1065e2678376e51fb72fcfebf2.png" data-rawwidth="640" data-rawheight="280"&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-e877a267dabb1f5eaa68f1f184bdad3d.png" data-rawwidth="735" data-rawheight="124"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-2b52412a7eac374329cca5d41a7f7bbe.png" data-rawwidth="695" data-rawheight="225"&gt;怎么样？！是不是感觉还不错~&lt;/p&gt;&lt;p&gt;2.展示线性模型结果，并加上表名&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-1f77b256f71cb01039ae2e3e93582de7.png" data-rawwidth="731" data-rawheight="400"&gt;&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-8fddf69b094815cdd174046241140220.png" data-rawwidth="559" data-rawheight="654"&gt;我们构建了两个线性模型和一个 Probit 模型，并将结果输出。&lt;/p&gt;&lt;p&gt;使用title参数将其命名为“Results”；&lt;/p&gt;&lt;p&gt;使用align参数使数字排列整齐。&lt;/p&gt;&lt;p&gt;3.对模型结果输出做部分调整：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;更改变量名；&lt;/li&gt;&lt;li&gt;删除极大似然统计量、残差标准差、F统计量；&lt;/li&gt;&lt;li&gt;删除表中的空行。&lt;/li&gt;&lt;/ul&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-2ccbe46327c90763362d3136cedb6122.png" data-rawwidth="741" data-rawheight="349"&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-ec872ce184d84f512cd250f221e71a23.png" data-rawwidth="538" data-rawheight="592"&gt;使用dep.var.labels和covariate.lables参数分别将因变量和自变量重命名为容易理解的形式；&lt;/p&gt;&lt;p&gt;使用omit.stat参数控制对数似然比（“LL”）、标准化残差（“ser”）和F统计量（“f”），这三个统计量不在输出结果中展示；&lt;/p&gt;&lt;p&gt;使用no.space参数将输出表格中的空行删去。&lt;/p&gt;&lt;p&gt;4.展示置信区间&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-7cbd212de4e1ab5c5507998012e5df05.png" data-rawwidth="746" data-rawheight="351"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-631f622eb9c10581b6a2d8921a8bf87e.png" data-rawwidth="531" data-rawheight="351"&gt;使用ci和ci.level参数展示90%的置信区间；&lt;/p&gt;&lt;p&gt;使用single.row参数使估计量与置信区间并排展示。&lt;/p&gt;&lt;p&gt;5.调整变量展示顺序，加上样本量，并移除其他统计量&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-5fe8525e8edf81a538853d7ae1806548.png" data-rawwidth="742" data-rawheight="261"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-8a07de924e642b8bbae4fd047805bc22.png" data-rawwidth="531" data-rawheight="313"&gt;&lt;/p&gt;&lt;p&gt;使用order参数控制自变量展示的顺序，即将learning和privileges放在表的前两行；&lt;/p&gt;&lt;p&gt;使用keep.stat参数控制要展示的统计量，keep.stat="n"即只展示样本量的大小，并移除其他统计量。&lt;/p&gt;&lt;p&gt;6.以ASCII格式输出：&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-e313701db19b8d4cd5208c5f34217573.png" data-rawwidth="741" data-rawheight="343"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-656d56b04315cf054d308b749e7b5caa.png" data-rawwidth="890" data-rawheight="477"&gt;使用type参数控制以ASCII格式输出，还可以选择输出HTML格式。默认为LATEX格式。&lt;/p&gt;&lt;p&gt;相应地，将type参数分别设置为text、html、latex即可。&lt;/p&gt;&lt;p&gt;7.展示矩阵&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-47529df894c5b5e849b93d6fc729c5ac.png" data-rawwidth="745" data-rawheight="174"&gt;&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-818237432774a1bf523f5692e6bccf1d.png" data-rawwidth="412" data-rawheight="151"&gt;stargazer也可以用来展示向量、矩阵或者数据框的内容。&lt;/p&gt;&lt;p&gt;我们建立了attitude数据集中变量rating、complaints、privileges的相关系数矩阵，并展示出来。&lt;/p&gt;&lt;p&gt;8.自定义变量&lt;/p&gt;&lt;p&gt;我们使用sandwich包来计算异方差-稳健标准误，并将其与默认计算的标准差一同展示。&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-5a09df7979df8daafff38d060af7c3d1.png" data-rawwidth="736" data-rawheight="285"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-c7214f1e9a52a9e074d22e1de99d52ba.png" data-rawwidth="522" data-rawheight="548"&gt;&lt;/p&gt;&lt;h2&gt;与 rmarkdown 一起食用&lt;/h2&gt;&lt;p&gt;rmarkdown包可直接在RStudio中编辑符合 markdown语法的文档，并兼容LATEX格式。而且可以直接输出成HTML、pdf等格式的文档。&lt;/p&gt;&lt;p&gt;因此，stargazer与rmarkdown一起食用，风味更佳~&lt;/p&gt;&lt;p&gt;首先，你需要在Rstudio中安装rmarkdown。&lt;/p&gt;&lt;p&gt;然后，就可以原先新建脚本的地方发现，可以新建一个R Markdown文件啦。&lt;/p&gt;&lt;p&gt;在rmarkdown中，用如下所示的形式来表示代码块：&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-1305d618b48fa09ae881d006670301ed.png" data-rawwidth="340" data-rawheight="72"&gt;&lt;/p&gt;&lt;p&gt;注意以下几点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;要加上results='asis'保证输出的是表格，而不是LATEX格式；&lt;/li&gt;&lt;li&gt;参数align失效，不能加上；&lt;/li&gt;&lt;li&gt;加上参数header=F，以避免输出关于包作者的一些信息。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其余用法与上述使用说明基本相同。这样就可以直接输出如上所示的表格了。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;stargazer用一行代码就可以解决模型结果输出成表格的问题，而且支持大量模型。具体可查看该包的&lt;a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf%09%22stargezer.pdf%22" data-editable="true" data-title="说明文档"&gt;说明文档&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;最后，如果在你的文章中有使用了stargazer包。记得附注以下作者的信息哦。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Hlavac, Marek (2015). stargazer: Well-Formatted Regression and Summary Statistics Tables. R package version 5.2. &lt;a href="http://CRAN.R-project.org/package=stargazer" data-editable="true" data-title="http://CRAN.R-project.org/package=stargazer" class=""&gt;http://CRAN.R-project.org/package=stargazer&lt;/a&gt;&lt;/p&gt;&lt;p&gt;stargazer包的说明文档：&lt;a href="https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf" data-editable="true" data-title="r-project.org 的页面" class=""&gt;https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本文作者：&lt;a href="https://vectorf.github.io/" data-editable="true" data-title="Vector"&gt;Vector&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/24511106&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Fri, 10 Feb 2017 09:53:55 GMT</pubDate></item><item><title>揭开机器学习的面纱</title><link>https://zhuanlan.zhihu.com/p/24119658</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-174b03d34c7c7f21a9d56ec7c1e33e46_r.jpg"&gt;&lt;/p&gt;&lt;blockquote&gt;你周围的人是否都在谈论着“机器学习”？而你是否也听说过一些算法技术却仍旧缺乏一个全局的认识？本文也许就是一个好的起点……&lt;/blockquote&gt;&lt;h3&gt;智力的新纪元&lt;/h3&gt;&lt;p&gt;在科学界，机器学习是目前很热门的话题。通过把计算机和人类的能力相结合，一些相当复杂甚至是难以想象的问题正在被逐个突破。&lt;/p&gt;&lt;p&gt;如今的机器可以更容易地处理不断产生的大量数据，也能够对复杂的科学发现进行破译。另一方面，研究人员已经承认机器学习具有用于广泛领域的潜力，并且最终可以付诸实践。&lt;/p&gt;&lt;p&gt;当开始着手研究机器学习，我们会发现这其中很多的算法技术对于统计学家、工程师、程序员、数学家和金融工程师而言也许并不陌生。这是因为这些算法技术实际上已经被研究很多年了。“机器学习”是一个相对而言的新名词，但对于数据科学家而言这并不是一个完全陌生的领域。&lt;/p&gt;&lt;p&gt;本文汇总了原作者在研究初时遇到的一些有趣的实例，从而有助于理解机器学习的相关内容是如何联系在一起，并列出其知识体系各部分之间的不同之处，最终针对现有的项目，选择最佳的方案。&lt;/p&gt;&lt;p&gt;虽然本文并没有提出什么新的观点，甚至算不上专业，但原作者希望本文可以帮助那些对入门机器学习仍有疑惑的人。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-59c86e05b877817b416887d3429ab6a9.jpg" data-rawwidth="700" data-rawheight="297"&gt;&lt;h3&gt;“机器学习”是什么？&lt;/h3&gt;&lt;p&gt;在机器学习领域，我们让机器自主学习。他们通过给定数据集里的案例进行学习。人们只需要利用机器得到的结论去改善方案、提高效率、实现自动化流程和任务。&lt;/p&gt;&lt;p&gt;让我们引用该领域两位巨擘的话来更精确地解释：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;“机器学习是让计算机在不被明确编程的情况下运作的科学。” ——安德鲁·吴（Coursera）&lt;/p&gt;&lt;p&gt;“一种计算机程序，如果它的任务记为T，用P来测度性能，并通过经验E来改善的话，它就会不断地从经验E中学习，从而满足某类任务T和性能指标P。”——汤姆·米歇尔（1997）&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;我曾经听说过这个！&lt;/h3&gt;&lt;p&gt;听起来，“机器学习”（简称为ML）和你之前了解的其他科学十分相似。现在，让我们看看它们之间究竟有什么不同。&lt;/p&gt;&lt;p&gt;或许，你对“人工智能”（简称为AI）更加熟悉。人工智能是通过复制人类的基本意识来开发系统项目从而独立完成预设好的目标的科学。很大程度上，机器学习可以算作是通过创造算法来调整机器行为从而接近经验数据的人工智能。&lt;/p&gt;&lt;p&gt;很多机器学习的内容来源于统计学科，只不过叫法不同罢了。与传统的统计学科不同，在机器学习中机器不对数据做推断，它得到的结论也不会被最初的诸多假设所限定。回想一下你在统计学中听到了多少次“假设X服从正态分布”或者“给定独立同分布的随机变量”。你有想过这些假设在现实中真的可能成立吗？&lt;/p&gt;&lt;p&gt;然而，机器学习方法的一个缺点在于我们很难得到对变量之间关系的直观解释，而这恰恰是统计推理所擅长的。为了实现更精确的预测，机器学习得到的模型会变得相当复杂以至于难以去解释。&lt;/p&gt;&lt;p&gt;失去解释性是绝大多数数据科学家不愿意见到的，但这也是为了解决复杂问题必须付出的代价。通常来说，在机器学习中最重要的是解决整个问题而不需要去分析细节。你能够不依赖其他技术发现数据背后隐藏的信息吗？尝试在下面这个色彩丰富的图中找出隐藏的三个物体，你能看到什么？&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-31323bb8f2d5658a590b2fd473b3ba1b.jpg" data-rawwidth="660" data-rawheight="467"&gt;&lt;p&gt;“机器学习”和“数据挖掘”也很相似。然而数据挖掘主要是为了发现数据中未知的模式和关系，机器学习则是在实际应用中通过先前得来的信息来处理新的数据集。&lt;/p&gt;&lt;p&gt;问题的关键在于平衡好性能和解释性的关系，比如说，预测准确性 vs 解释性。&lt;/p&gt;&lt;p&gt;如果你仍旧对机器学习与其他学科的异同留有困惑，你可以在&lt;a href="https://www.analyticsvidhya.com/blog/2015/06/machine-learning-basics/" data-editable="true" data-title="“这里”"&gt;“这里”&lt;/a&gt;和&lt;a href="http://shakthydoss.com/what-is-the-difference-between-artificial-intelligence-machine-learning-statistics-and-data-mining/" data-editable="true" data-title='"这里"'&gt;"这里"&lt;/a&gt;找到机器学习和人工智能、统计、数据挖掘、深度学习的比较。&lt;/p&gt;&lt;h3&gt;揭开机器学习的面纱&lt;/h3&gt;&lt;p&gt;理解机器学习和学习如何入门最好的方法莫过于理解其知识体系各部分之间的不同之处。熟悉机器学习的人可能知道机器学习的主要模式就是监督学习和无监督学习了。&lt;/p&gt;&lt;p&gt;简而言之，监督学习就是我们已经通过之前已知的数据知道结果了。&lt;/p&gt;&lt;p&gt;此时，我们想建立一个模型来预测未知数据的结果。我们将已有的数据和结果输入机器，让它从这两者之间的关系中不断学习从而建立模型。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-e908865a8bb4695085ab0356fddb23a9.png" data-rawwidth="800" data-rawheight="384"&gt;&lt;p&gt;在无监督学习中，我们则是希望发现数据中未知的结构或者是趋势。原数据不含任何的标签，但我们希望可以对数据进行整合（分组或者聚类），或是简化数据（降维、移除不必要的变量或者检测异常值）。&lt;/p&gt;&lt;p&gt;我们进一步区分这两个模式的子类别，并在下图中展示出来：&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-d6bbab79810c44367fd66a3c6d09e4aa.png" data-rawwidth="1461" data-rawheight="968"&gt;&lt;p&gt;监督学习可以根据预测变量的类型再细分。如果预测变量是连续的，那这就属于回归问题。&lt;/p&gt;&lt;p&gt;而如果预测变量是独立类别（定性或是定类的离散值），那这就属于分类问题了。&lt;/p&gt;&lt;p&gt;举例来说，如下两图所示：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;预测 S&amp;amp;P500 指数下周的回报率。由于回报率是连续变量，这就是回归问题。&lt;/li&gt;&lt;li&gt;预测欧元兑美元的趋势是上升还是下降。这里只有两种可能性：牛市或熊市。这就是分类问题。&lt;/li&gt;&lt;/ol&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-5ceed3b86ff529caa0dd66f67b6abb10.png" data-rawwidth="800" data-rawheight="383"&gt;&lt;p&gt;无监督学习可以再细分为聚类分析、密度估计和降维。&lt;/p&gt;&lt;p&gt;聚类分析中，数据通过相似性或者距离来分组。密度估计中，模式和数据用分布函数或是定义的形状表示。降维中，通过移除重复或者不必要的变量实现更简洁的数据结构。&lt;/p&gt;&lt;p&gt;我们也可以根据学习的类型和所需解决的问题对特定的方法进行分类，如下图所示：&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-afbd2ab1483ecf9f3534391b4801b17c.png" data-rawwidth="642" data-rawheight="467"&gt;&lt;p&gt;&lt;a href="http://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/" data-editable="true" data-title="“MLmastery”"&gt;“MLmastery”&lt;/a&gt;和&lt;a href="http://www.analyticsvidhya.com/blog/2015/08/common-machine-learning-algorithms/" data-editable="true" data-title="“analyticsV”"&gt;“analyticsV”&lt;/a&gt;等博文对机器学习主要的算法做了清晰实用的解释。&lt;/p&gt;&lt;h3&gt;其他细节&lt;/h3&gt;&lt;p&gt;机器学习技术在应用之前使用“训练+检验”的模式（通常被称作”交叉验证“）。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-b330046f5f69b269f95cc4c98daab5b9.png" data-rawwidth="638" data-rawheight="467"&gt;&lt;p&gt;机器会不断地尝试参数的组合，因此我们要警惕“过拟合”和“运行时间”的问题。在训练阶段过高的准确性往往会造成过度优化，以至于在检验阶段会有较差的结果。同时，为了减小成本函数到足够的水平，算法也会花很长时间直至收敛到最终的结果。&lt;/p&gt;&lt;h3&gt;关于实际应用&lt;/h3&gt;&lt;p&gt;机器学习可谓是无处不在，在日常生活中有大量相关实例，只是我们没有意识到。比如说，机器学习被用于搜索引擎、过滤垃圾邮件、面部识别、社交网络分析、市场细分、数据分析、欺诈检测和风险分析等。&lt;/p&gt;&lt;p&gt;泛泛而谈是不足以说明问题的。通过将机器学习用于金融领域的实例，我们能看到将这些复杂的算法用于实际会带来多大的便利。&lt;/p&gt;&lt;p&gt;无监督学习技术可以用于分析和理解金融数据。比如说，&lt;a href="http://quantdare.com/2014/03/analisis-de-componentes-principales/" data-editable="true" data-title="主成分分析（PCA）"&gt;主成分分析（PCA）&lt;/a&gt;可以用于资产配置，&lt;a href="http://quantdare.com/2015/10/k-means-algorithm/" data-editable="true" data-title="K 均值"&gt;K 均值&lt;/a&gt;可用来债券市场回报率的聚类，&lt;a href="http://quantdare.com/2015/05/reproducing-the-sp500-by-clustering/" data-editable="true" data-title="其他聚类方法"&gt;其他聚类方法&lt;/a&gt;可以再现 S&amp;amp;P 500指数的组成，&lt;a href="http://quantdare.com/2016/01/stock-classification-with-isomap/" data-editable="true" data-title="ISOMAPS"&gt;ISOMAPS&lt;/a&gt; 算法可以分类不同行业的股票。&lt;/p&gt;&lt;p&gt;监督学习技术则非常适合用于分析金融数据。它可以实现预测和帮助制定投资风险策略。举例来说，&lt;a href="http://quantdare.com/2014/03/vecinos-serie-temporal/" data-editable="true" data-title="近邻算法"&gt;近邻算法&lt;/a&gt;、&lt;a href="http://quantdare.com/2014/07/redes-neuronales-ii/" data-editable="true" data-title="神经网络"&gt;神经网络&lt;/a&gt;、&lt;a href="http://quantdare.com/2014/09/clasificando-mercado-con-arboles-de-decision/" data-editable="true" data-title="决策树"&gt;决策树&lt;/a&gt;、&lt;a href="http://quantdare.com/2015/01/random-forest-vs-simple-tree/" data-editable="true" data-title="随机森林"&gt;随机森林&lt;/a&gt;和&lt;a href="http://quantdare.com/2015/10/naive_bayesian_classifier/" data-editable="true" data-title="贝叶斯"&gt;贝叶斯&lt;/a&gt;这些都可以用来监测股市的市场变动趋势。&lt;/p&gt;&lt;h3&gt;更多相关链接&lt;/h3&gt;&lt;p&gt;不知道从何开始？可以尝试&lt;a href="https://www.coursera.org/learn/machine-learning/" data-editable="true" data-title="“在Coursera上的机器学习课程”"&gt;“在Coursera上的机器学习课程”&lt;/a&gt;或者用Python的&lt;a href="http://scikit-learn.org/stable/user_guide.html" data-editable="true" data-title="”tool scikit-learn“"&gt;”tool scikit-learn“&lt;/a&gt;。当然，你也可以在&lt;a href="https://www.kaggle.com/competitions" data-editable="true" data-title="”Kaggle“"&gt;”Kaggle“&lt;/a&gt;上进行学习，”泰坦尼克号''实例很适合初学者。&lt;/p&gt;&lt;p&gt;想知道究竟什么算法才适合解决你的问题？不如去看看&lt;a href="http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" data-editable="true" data-title="“scikit learn”"&gt;“scikit learn”&lt;/a&gt;和&lt;a href="https://azure.microsoft.com/en-us/documentation/articles/machine-learning-algorithm-choice/" data-editable="true" data-title="“Azure”"&gt;“Azure”&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果你想开始编程并尝试一些实例，&lt;a href="http://topepo.github.io/caret/index.html" data-editable="true" data-title="“caret Package”"&gt;“caret Package”&lt;/a&gt;中包含大量的相关细节、函数和案例。你也可以从&lt;a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" data-editable="true" data-title="”Python and R codes“"&gt;”Python and R codes“&lt;/a&gt;中学到机器学习主要的算法。&lt;/p&gt;&lt;p&gt;不喜欢本文？想了解更多或想换个角度看？&lt;a href="http://www.toptal.com/machine-learning/machine-learning-theory-an-introductory-primer" data-editable="true" data-title='"detailed post"'&gt;"detailed post"&lt;/a&gt;介绍了机器学习的入门知识，或是阅读&lt;a href="http://www.r2d3.us/visual-intro-to-machine-learning-part-1/" data-editable="true" data-title='"innovative introductory visualisation"' class=""&gt;"innovative introductory visualisation"&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;在机器学习中有很多不同的词实际上代表同一样东西。下图是对于输入和输出变量的常见的一些表达方式：&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-ab992b6bfe58f1771ce9e79d5139b598.png" data-rawwidth="739" data-rawheight="467"&gt;你也可以在&lt;a href="http://robotics.stanford.edu/~ronnyk/glossary.html" data-editable="true" data-title='"Glossary"'&gt;"Glossary"&lt;/a&gt;找到更多与机器学习相关的术语。 &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;原文链接：&lt;a href="http://quantdare.com/2016/03/machine-learning-a-brief-breakdown/" data-editable="true" data-title="Machine Learning: A Brief Breakdown" class=""&gt;Machine Learning: A Brief Breakdown&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者： libesa&lt;/p&gt;&lt;p&gt;译作者：&lt;a href="https://vectorf.github.io/" data-editable="true" data-title="Vector"&gt;Vector&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/24119658&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 19 Jan 2017 10:34:34 GMT</pubDate></item><item><title>Logistic 函数 vs Softmax 函数</title><link>https://zhuanlan.zhihu.com/p/24042556</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-8e868ab407d589a407104daf194dea62_r.png"&gt;&lt;/p&gt;&lt;p&gt;嘿，大家好。你知道机器学习中的分类模型么？你知道 Softmax 和 Logistic 函数么？如果你不是很了解这些内容的话，那么请继续往下看吧。&lt;/p&gt;&lt;p&gt;众所周知，机器学习中最经典的模型是分类模型。根据维基百科的叙述，分类模型（监督学习模型）是根据标记数据来推断未知样本归属类别的模型。  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-8e868ab407d589a407104daf194dea62.png" data-rawwidth="1088" data-rawheight="784"&gt;&lt;p&gt;为了简化起见，我们的数据集中标签的数目必须是有限的，即对于一张猫的照片我们需要计算机告诉我们这是一只猫。&lt;/p&gt;&lt;p&gt;本文中用到的图片全部来自于&lt;a href="https://pixabay.com/" data-editable="true" data-title="Pixabay" class=""&gt;Pixabay&lt;/a&gt;，该网站上提供了许多免费照片。&lt;/p&gt;&lt;p&gt;首先我们来看一个简单的分类模型——二分类问题，比如判断图片中是否存在猫。本文中主要采用一个黑箱模型——神经网络模型，不过本文的重点并不是介绍神经网络模型的建模过程，而是关注该模型的最后一个计算步骤。   &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-66f2a0e88d14e6521e051695020108a6.png" data-rawwidth="1078" data-rawheight="792"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-c3c802cf96b498ea9633f3f889aef4c6.png" data-rawwidth="1086" data-rawheight="768"&gt;&lt;p&gt;对于黑箱模型来说，我们无法得知其内部的构建过程，我们只能得到给定输入结果对应的预测标签。相反地，同样存在白箱模型，我们不但能获取输出结果，还能得知模型的内部结构。&lt;/p&gt;&lt;p&gt;因此，神经网络的计算模块是一个黑箱过程，我们输入一张图片，该模型返回相应的标签结果。输出结果如下所示：  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-94011836e9aad64910adf40d02edfc35.png" data-rawwidth="740" data-rawheight="112"&gt;为了获得输出结果所对应的标签情况，我们需要利用 logistic 函数，其形式如下所示：&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-5cb80f5452810865f657a058852d16cf.jpg" data-rawwidth="138" data-rawheight="41"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-9efffd7a2a0c1f183de573151758168b.png" data-rawwidth="1354" data-rawheight="1112"&gt;&lt;p&gt;从上图我们可以看出，该函数可以很好地处理二分类问题：当概率值大于 0.5 时，我们认为该样本属于类 ‘1’，而当概率值小于 0.5 时，我们认为该样本属于类 ‘0’。&lt;/p&gt;&lt;p&gt;转换后的结果如下所示：&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-ea03654accbdf724a62f92dc7085258c.png" data-rawwidth="727" data-rawheight="175"&gt;&lt;p&gt;那么，什么是 Softmax 函数呢？该函数通常用于处理多分类问题，它可以计算得到样本归属于每个类别的概率。&lt;/p&gt;&lt;p&gt;比如，&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-209b91fc7afbd8d804484307f832ba14.png" data-rawwidth="730" data-rawheight="204"&gt;&lt;/p&gt;&lt;p&gt;那么问题来了，给定某个样本它归属于每个类别的概率分别是多少呢？我们假设每个样本只能有一个标签，此时我们利用 Softmax 函数即可获得样本归属于每个类别的概率，该函数的形式非常简单：  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-ba8ca3df1639b9c60cd6eb5ead98fdf5.jpg" data-rawwidth="109" data-rawheight="43"&gt;因此，我们可以得到给定样本的概率向量：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-42069d195981b51568675664d55631bd.png" data-rawwidth="724" data-rawheight="171"&gt;&lt;p&gt;需要注意的是，这些概率值的总和为1。 &lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Softmax 函数通过给定的任意向量输出对应的概率值，它可以处理多标签分类问题。&lt;/li&gt;&lt;li&gt;Logistic 函数通过给定的任意向量输出 Sigmoid 函数的值，它可以处理二分类问题。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果你发现本文中存在问题，请及时告诉我，我很乐意听到这些消息并从中学会更多的知识。 &lt;/p&gt;&lt;h2&gt;一些有用的链接&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.udacity.com/course/deep-learning--ud730" data-editable="true" data-title="Udacity course on ML"&gt;Udacity course on ML&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Sigmoid_function" data-editable="true" data-title="Wikipedia article for sigmoid function"&gt;Wikipedia article for sigmoid function&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Softmax_function" data-editable="true" data-title="Wikipedia article for softmax function" class=""&gt;Wikipedia article for softmax function&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;—————————————————————————————————————————&lt;/p&gt;&lt;p&gt;原文链接：&lt;a href="https://medium.com/@demidovs/ml-1-logistic-function-vs-softmax-44c73399c3c4#.78vsb0ato" class=""&gt;https://medium.com/@demidovs/ml-1-logistic-function-vs-softmax-44c73399c3c4#.78vsb0ato&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者：Alexander Demidovskij&lt;/p&gt;&lt;p&gt;译者：Fibears&lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/24042556&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 12 Jan 2017 10:46:46 GMT</pubDate></item><item><title>[Python]因果检验工具</title><link>https://zhuanlan.zhihu.com/p/23945385</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-d4b5b05dd7598cffae35ce344ada522a_r.png"&gt;&lt;/p&gt;&lt;h2&gt;安装过程&lt;/h2&gt;&lt;p&gt;如果你已经安装了 pip，那么你只需运行以下代码即可。  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-770e08ae1195d0f8eeb5b7663ed68dea.png" data-rawwidth="585" data-rawheight="87"&gt;&lt;h2&gt;因果推理&lt;/h2&gt;&lt;p&gt;causality.inference 模块中将会包含多种推断变量之间因果关系的算法。但是到2016年1月23日为止，我只实现了 &lt;strong&gt;Pearl(2000)&lt;/strong&gt; 提出的 &lt;strong&gt;IC*&lt;/strong&gt; 算法。  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-d5d90bd2170408ee9b38eb3336fb0a28.png" data-rawwidth="582" data-rawheight="579"&gt;此时，我们已将变量的关系图储存到 graph中，在这个图中每个变量表示一个节点，每条边则表示给定搜索路径中其他变量的情况下，相邻节点之间的统计相关性。如果两个变量之间存在统计相关性，那么箭头方向处的变量将被存在 arrow 中。如果两个变量之间同时满足真正的因果关系，此时 marked=True。如果我们打印出模型的拟合结果，我们可以很明显的看出变量之间存在的关系：  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-5a8acab2375cea0602791d381a9341f1.png" data-rawwidth="590" data-rawheight="178"&gt;从上述结果中我们可以看出，x2与x4，x3与x4，x4与x5之间存在统计相关性，此外我们还可以看出 x4到x5 之间存在真正的因果关系。这个结果与 Pearl(2000) 文章中的图 2.3(d) 相吻合。  &lt;/p&gt;&lt;h2&gt;非参数效应估计&lt;/h2&gt;&lt;p&gt;causality.nonparametric 模块是一个利用观测数据集对因果分布进行非参数化估计的工具。你可以提供一个变量的容许集用来控制，它用来度量给定原因时一个效应的因果反应分布，或给定原因时这个效应的期望值。&lt;/p&gt;&lt;p&gt;我最近已经添加了调整功能，你可以通过调整有向图中变量X的父节点来估计一组变量Y和一组变量X之间的因果效应。  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-799c93d3edacebd91a11dddf720641f4.png" data-rawwidth="541" data-rawheight="242"&gt;此时，你可以利用以下代码来观察调整结果：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-71e8303419417f74b7c1ccac1d2035b1.png" data-rawwidth="536" data-rawheight="97"&gt;&lt;p&gt;如果我们没有对变量 x1 进行调整，由于 x2,x1,x3 之间存在一个搜索路径，那么我们将会错误地认为 x2 是 x3 的因果原因。&lt;/p&gt;&lt;h2&gt;其他注意事项&lt;/h2&gt;&lt;p&gt;这个项目还处于早期阶段，程序的运行时间较长。未来的一段时间内，我将会不断对其进行优化，其中主要包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;实现快速互信息计算，O(NlogN)&lt;/li&gt;&lt;li&gt;加快整合控制变量的九三过程&lt;/li&gt;&lt;li&gt;增加用户提供的图形，并找出容许集&lt;/li&gt;&lt;li&gt;确定变量间因果效应的捷径方法&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Pearl, Judea. Causality. Cambridge University Press, (2000)  &lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/23945385&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 05 Jan 2017 11:14:26 GMT</pubDate></item><item><title>深度学习教程 Part 1</title><link>https://zhuanlan.zhihu.com/p/23766334</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-8ad0a7d0e3dd6cd1353005e2a0a9b7a9_r.png"&gt;&lt;/p&gt;&lt;p&gt;如果你想利用深度学习方法来识别图像，但却不知道如何上手的话，那么我想这篇文章可以帮助到你。&lt;/p&gt;&lt;p&gt;如果你不知道机器学习和卷积神经网络的话，那么我强烈建议你先看下 &lt;a href="https://medium.com/u/ba4c55e4aa3d" data-editable="true" data-title="Adam Geitgey" class=""&gt;Adam Geitgey&lt;/a&gt;的文章&lt;/p&gt;&lt;p&gt;本文将构建一个卷积神经网络模型来读取并识别图像，对每个图像打上相应的标签。  &lt;/p&gt;&lt;h2&gt;环境配置&lt;/h2&gt;&lt;p&gt;首先，我们需要配置下环境，你可以从&lt;a href="www.continuum.io/downloads" data-editable="true" data-title="官网"&gt;官网&lt;/a&gt;下载 Anaconda，并选择 Python 2.7版本。&lt;/p&gt;&lt;p&gt;安装完成后，你需要确认 NumPy, SciPy, Sphinx, pyyaml 等包是否已经成功安装，你可以利用搜索栏来搜寻这些软件包。&lt;/p&gt;&lt;p&gt;此外，我们还需要安装 &lt;a href="http://www.deeplearning.net/software/theano" data-editable="true" data-title="Theano" class=""&gt;Theano&lt;/a&gt;，我们将采用最简单的方法来安装该软件库。如下所示：在 Anaconda 界面中，打开终端界面  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-2393ef9edc53f7eb0c72df82739e1ed6.png" data-rawwidth="718" data-rawheight="420"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-8345a27007544b055a74bd168192b3e5.png" data-rawwidth="370" data-rawheight="195"&gt;此外你也可以利用 git 来安装最新版本程序：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-37ba440fd88b0e2676d3b35c4d91046e.png" data-rawwidth="430" data-rawheight="99"&gt;&lt;h2&gt;使用 Jupyter Notebook&lt;/h2&gt;&lt;p&gt;从 Anaconda 登陆界面中打开 Jupyter notebook 并新建一个文件：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-b82f74d9e9f22cbc83d28ccf9a658929.png" data-rawwidth="319" data-rawheight="228"&gt;&lt;h2&gt;编程阶段&lt;/h2&gt;&lt;p&gt;首先，我们需要载入相应的软件库  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-4f13050e9c5f29e1095069f11210d51e.png" data-rawwidth="581" data-rawheight="441"&gt;&lt;p&gt;我们将以&lt;a href="http://yann.lecun.com/exdb/mnist/" data-editable="true" data-title="MNIST" class=""&gt;MNIST&lt;/a&gt;数据集为例，并利用 Keras 来载入数据集。该数据集中包含了 60,000 张大小为 28*28 的图片，测试集中包含 10,000 张图片。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-b7e4998fb25e39cfae8f6e09ef5c8c3f.png" data-rawwidth="538" data-rawheight="605"&gt;&lt;h3&gt;深度学习架构&lt;/h3&gt;&lt;p&gt;我们将使用基于 Lenet-5 结构的神经网络[1]，具体如下所示：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-8ad0a7d0e3dd6cd1353005e2a0a9b7a9.png" data-rawwidth="719" data-rawheight="237"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-137de95fb0926a76d876a2a4e81555f6.png" data-rawwidth="759" data-rawheight="515"&gt;&lt;p&gt;如果你对上述层级结构感到困惑的话，你可以参阅这个&lt;a href="http://neuralnetworksanddeeplearning.com/chap6.html#introducing_convolutional_networks" data-editable="true" data-title="教程" class=""&gt;教程&lt;/a&gt;。 &lt;/p&gt;&lt;h3&gt;训练并测试模型&lt;/h3&gt;&lt;p&gt;利用 CPU 来训练模型的话需要几分钟的计算时间，但是如果使用 GPU 的话仅需要几秒钟。&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-126f58637d458c94fa00e2ed6834c023.png" data-rawwidth="489" data-rawheight="291"&gt;评估模型的效果：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-93e7619296a90c2f879929f903207144.png" data-rawwidth="440" data-rawheight="122"&gt;&lt;p&gt;其中测试集的得分是损失函数值，如 MSE，而测试精度则是预测结果的准确率。测试得分越小，测试精度越高，模型的拟合效果越好。结果显示，上述模型的测试得分为 3%，测试精度为 99%。&lt;/p&gt;&lt;h3&gt;分类结果&lt;/h3&gt;&lt;p&gt;别忘了我们的测试集中有 10,000 张图片，在这里我们只展示前 25 张图片的预测结果：  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-426cbb91ddf5cfdd677c148b9c337231.png" data-rawwidth="441" data-rawheight="227"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-9fd697eb57b9662b89b1372ad640a282.png" data-rawwidth="638" data-rawheight="630"&gt;接下来我们还能做啥呢？我们还可以调整神经网络的结构，改变隐藏层的类型，改变迭代次数并观察模型的拟合效果是否变得更好。或者我们可以将训练好的模型保存下来以便于处理图像分类预测问题。当然我们也可以将预测错误的图片打印出来：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-8c8f7676ede60c11a0c89c17ef50d77c.png" data-rawwidth="586" data-rawheight="592"&gt;&lt;blockquote&gt;更多资讯和文章尽在微信号：「datartisan数据工匠」   &lt;/blockquote&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;p&gt;[1] Y. Lecun, L. Bottou, Y. Bengio and P. Haffner, “Gradient-based learning applied to document recognition,” in Proceedings of the IEEE, vol. 86, no. 11, pp. 2278–2324, Nov 1998. &lt;/p&gt;&lt;p&gt;原文链接：&lt;a href="https://medium.com/@databolism/getting-start-with-deep-learning-a-hands-on-guide-for-complete-beginners-part-1-setting-up-c2737a2fc0d#.4y6kbdrvv" class=""&gt;https://medium.com/@databolism/getting-start-with-deep-learning-a-hands-on-guide-for-complete-beginners-part-1-setting-up-c2737a2fc0d#.4y6kbdrvv&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者：Akina M.&lt;/p&gt;&lt;p&gt;译者：Fibears&lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/23766334&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 29 Dec 2016 10:51:13 GMT</pubDate></item><item><title>用随机森林预测NBA球员打什么么位置</title><link>https://zhuanlan.zhihu.com/p/22883235</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-f37445cc22043090fb439c8d7a6a59fb_r.png"&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;目的：用NBA球员的统计数据来预测他们所打的位置。&lt;/p&gt;方式：决策树和随机森林&lt;/blockquote&gt;&lt;p&gt;引言：&lt;/p&gt;&lt;p&gt;众所周知，篮球队分为大前锋、小前锋、得分后卫、控球后卫和中锋五个位置，虽然现在无位置篮球正在兴起，但是我们还是可以用球员的历史数据来预测它的位置。在这里我们就是要对球员进行一个多分类，方法选用经典的决策树和它们的集成方法——随机森林。接下来我们先看一下这五个位置各有什么特点，当然你可能比我更清楚这些内容，但是我们也不是在做无用功，注意加重的文字，我们就从这些里面选择特征。 &lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;em&gt;中锋&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;中锋一般都是整支球队中最&lt;strong&gt;高&lt;/strong&gt;的，能够进行激烈的身体对抗，负责&lt;strong&gt;篮板&lt;/strong&gt;和&lt;strong&gt;阻拦&lt;/strong&gt;，得分方式主要靠&lt;strong&gt;勾手&lt;/strong&gt;、&lt;strong&gt;跳投&lt;/strong&gt;和&lt;strong&gt;扣篮&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平均身高：6'11.25"平均体重：257 lbs &lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;strong&gt;&lt;em&gt;控球后卫&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;控卫一般都是最&lt;strong&gt;矮&lt;/strong&gt;的球员，应该具有优秀的&lt;strong&gt;过人能力&lt;/strong&gt;和&lt;strong&gt;控球能力&lt;/strong&gt;，而不是作为主要投手。一般控卫都是在攻防转换中带球过场的那个人，在进攻和防守之间控制好球权。优秀的控卫在助攻和抢断上数据很好看。 &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平均身高：6'2平均体重：189 lbs &lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;strong&gt;&lt;em&gt;得分后卫&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;得分后卫一般比控卫要高一点但还是要比前锋矮，他的定位是全队的&lt;strong&gt;最佳投手&lt;/strong&gt;，在其他队友的掩护下投篮得分，也要足够&lt;strong&gt;灵活&lt;/strong&gt;分担控卫的职责。 &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平均身高：6'5.25"平均体重：209 lbs &lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;strong&gt;&lt;em&gt;小前锋&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;小前锋被视为是进攻时的&lt;strong&gt;全能球员&lt;/strong&gt;，既要足够强转可以在内线对抗又要足够灵活足够在外线驰骋，能够在外线和内线都具有较强的得分能力。 &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平均身高：6'7.75"平均体重：225 lbs &lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;strong&gt;&lt;em&gt;大前锋&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;大前锋是一个既要身体&lt;strong&gt;高大强壮&lt;/strong&gt;，还要有一定的&lt;strong&gt;速度&lt;/strong&gt;，能够积极进攻并抢得&lt;strong&gt;篮板&lt;/strong&gt;。 &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;平均身高：6'9.5"平均体重：246 lbs &lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;变量&lt;/h2&gt;&lt;p&gt;我们选择了15个变量来进行预测分析： &lt;/p&gt;&lt;ol&gt;&lt;li&gt;场均得分 Points per Game &lt;/li&gt;&lt;li&gt;真实投篮命中得分 True Shooting Score&lt;/li&gt;&lt;li&gt;进攻篮板 Offensive Rebounds&lt;/li&gt;&lt;li&gt;防御篮板 Defensive Rebounds &lt;/li&gt;&lt;li&gt;总篮板 Total Rebounds&lt;/li&gt;&lt;li&gt;助攻 Assists&lt;/li&gt;&lt;li&gt;盖帽 Blocks &lt;/li&gt;&lt;li&gt;失误 Turn Overs&lt;/li&gt;&lt;li&gt;团队利用Team Play Usage&lt;/li&gt;&lt;li&gt;进攻等级 Offensive Ratings&lt;/li&gt;&lt;li&gt;防守等级 Defensive Ratings&lt;/li&gt;&lt;li&gt;进攻胜利贡献 Offensive Win Shares&lt;/li&gt;&lt;li&gt;防守胜利贡献 Defensive Win Shares&lt;/li&gt;&lt;li&gt;胜利贡献 Win Shares&lt;/li&gt;&lt;li&gt;抢断 Steals&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;可视化&lt;/h2&gt;&lt;p&gt;在分析之前，我们先来看一些变量在不同位置中的分布，从而判断什么变量可以帮助我们区分不同的位置。以下几个可视化的图表显示了这15个变量的分布。可以清晰地发现，中锋和大前锋在篮板和盖帽的数量上独领风骚，这就很可能成为决策树的分支变量。更加显著的是助攻数据，看到这里我认为要获得一个高的预测准确度还是容易达到的。 &lt;/p&gt;&lt;h4&gt;数据汇总&lt;/h4&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-76d9919ca5ce68c77d4b2dcbf343bd8c.png" data-rawwidth="768" data-rawheight="126"&gt;&lt;h4&gt;分布&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-42621af43fc09332814fb6f72f778d2b.png" data-rawwidth="1061" data-rawheight="740"&gt;&lt;/h4&gt;&lt;h4&gt;热力图（按变量）&lt;/h4&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-cc3a4e4188a65dcb76cf77c2a52ce3f3.png" data-rawwidth="2494" data-rawheight="1426"&gt;&lt;h4&gt;热力图（按位置）&lt;/h4&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-a7aeff8155d1ac60007bf4568a9a359e.png" data-rawwidth="1024" data-rawheight="728"&gt;&lt;h2&gt;决策树和随机森林分类器&lt;/h2&gt;&lt;h3&gt;适度拟合的决策树&lt;/h3&gt;&lt;p&gt;决策树类似于一个向你问问题的机器。比如我们有一个新球员，要预测他的位置。决策树就会问:“它的总篮板数是多少”，然后你给它一个答案，它向你问的下一个问题是基于上一个问题的答案，直到他问的问题足够多以后他不会再问了而是告诉你这个球员会打什么位置。决策树很好理解而且做出来的图也很直观。 &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-443359cadad42a4c964d353132952df7.png" data-rawwidth="1922" data-rawheight="1276"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-012f3215819751506a0b4df548be742e.png" data-rawwidth="576" data-rawheight="146"&gt;&lt;p&gt;混淆矩阵显示中锋和大前锋预测正确率在50%左右，因为这两个位置往往可替代性很强，混淆的部分也很大。我们也看到了控卫的预测正确率有80%。做的这里我就想随机森林的结果一定会更好。 &lt;/p&gt;&lt;h3&gt;过拟合的决策树&lt;/h3&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-d7fb63d5ba12d0aa18bc06db3cadf498.png" data-rawwidth="1978" data-rawheight="1274"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-af84f706b40bd917eed3e935212a823f.png" data-rawwidth="1192" data-rawheight="296"&gt;&lt;p&gt;过拟合是指一个模型训练的程度过头了，导致这了模型把很多因为抽样所带来的随机因素考虑进去，从而导致模型的泛化能力差，在决策树中主要是没有进行剪枝的问题。可以从图中看出这个决策树的分支很多，数比较深。而混淆矩阵显示模型的预测准确率变差了。从方差—偏差权衡的角度来看，过拟合往往是因为过于注重控制偏差，反而使方差超过了最优水平。 &lt;/p&gt;&lt;h3&gt;随机森林&lt;/h3&gt;&lt;p&gt;随机森林是把很多的决策树组合在一起的集成算法，在下面我们可以看到在模型集成的过程中加入了随机因素，所以综合称之为随机森林。 &lt;/p&gt;&lt;ul&gt;&lt;li&gt;第一种随机因素是指我们在训练模型时用的是自助采样法随机抽取出来的样本子集，这样可以使得我们的预测更为稳定并减少过拟合的风险。&lt;/li&gt;&lt;li&gt;第二种随机因素是构建决策树并选择最优特征划分样本时，在一个随机抽取的特征子集中选择最优特征。这样可以集成更多的树，降低方差。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在展示结果之前，我们先来剖析一下模型的训练过程。我们确定要集成的决策树数目为T，第一步是为每一棵树随机抽取一个样本子集，一般为样本全集的2/3。第二步是在树的每个节点上随机抽取m个特征作为特征子集。第三步是树的生成，在每个节点上选择一个最佳的特征进行分支。在下一个节点上继续随机选择m个特征重复以上步骤。 &lt;/p&gt;&lt;p&gt;在我做的过程当中，我只注重调整两个影响力最大的参数，就是ntree和ntry，ntree就是指数的数目T，mtry就是指随机抽取的样本子集的大小m。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-3f22a69d851bb367e6ee23cb6e08a088.jpg" data-rawwidth="4712" data-rawheight="2874"&gt;&lt;h4&gt;调参&lt;/h4&gt;&lt;p&gt;对于第一个参数T我设置为180，这个图 展示了每个参数值对应的最小袋外误差。&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-72f6d610221a1f6002c22f4c9543b203.png" data-rawwidth="1024" data-rawheight="638"&gt;&lt;/p&gt;&lt;p&gt;对于参数m我设置为9，从下图袋外误差中可以看出当m=9的时候误差最小。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-32a7b23ca2d8d9291349dc9668d870e9.png" data-rawwidth="768" data-rawheight="467"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-40e4654f4124126c0c3174e6757217ec.png" data-rawwidth="576" data-rawheight="148"&gt;&lt;p&gt;从混淆矩阵显示结果来看，随机森林的预测结果明显优于决策树，尤其是控球后卫的预测结果较好，但是对大前锋和得分后卫的预测精度就有些下降了。我的数据集还是有些太少，如果我们用更多的数据，随机森林的效果必然有更高的提升。在我下一步的计划中，我想从50个赛季中抓取数据，然后做一个类似的分析看看最终结果如何。 &lt;/p&gt;&lt;h3&gt;结论&lt;/h3&gt;&lt;p&gt;这篇博客是利用NBA球员的历史数据来预测球员的位置，我用的是决策树和它的集成算法随机森林。结果显示随机森林表现得更好一点，但是提升空间也很大。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;译者注：从混淆矩阵结果来看并没有预想的那么好，另外作者明明在介绍各种位置的时候着重介绍了身高和体重的问题却没有将其加入特征全集中，也有特征选用少的原因。有兴趣的朋友可以进一步尝试扩大数据集和特征集以求更好的结果。 &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;以下是代码集，作者用的是R语言。&lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-bf1ad29e4978ece9c2178c834d5d8514.png" data-rawwidth="368" data-rawheight="383"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-22039e8cb5e4673306d1dd3acf22a315.png" data-rawwidth="346" data-rawheight="267"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-111cdf27bcb75b6a591d9f9213ce082e.png" data-rawwidth="551" data-rawheight="664"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-4e75f3b84c04a58826cb8c37482557ea.png" data-rawwidth="533" data-rawheight="201"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-010ebcdc3d82c48f6f3c2a6f80137400.png" data-rawwidth="466" data-rawheight="307"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-79538d37accc284b7650640a70bbdbda.png" data-rawwidth="468" data-rawheight="582"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-7672810e4b24ec15949ec31adb380bcf.png" data-rawwidth="491" data-rawheight="336"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-c584e1223b139e57b5bdeccfb432f8f2.png" data-rawwidth="360" data-rawheight="245"&gt;***&lt;/p&gt;&lt;p&gt;&lt;p&gt;http://weixin.qq.com/r/WkMCGqvEoPbfre959xZI (二维码自动识别)&lt;/p&gt;原文作者：Jurgen译者：Cup原文链接：&lt;a href="http://blog.nycdatascience.com/student-works/predicting-nba-player-positions/" data-editable="true" data-title="nycdatascience.com 的页面"&gt;http://blog.nycdatascience.com/student-works/predicting-nba-player-positions/&lt;/a&gt;&lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/22883235&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 22 Dec 2016 10:50:09 GMT</pubDate></item><item><title>iPhone 步行数据分析</title><link>https://zhuanlan.zhihu.com/p/23540254</link><description>&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-bd031dbee54442ad40d8957abbb1108d_r.png"&gt;&lt;/p&gt;&lt;p&gt;本文中我将展示如何利用 pandas 和 ggplot 来分析 iPhone 的步行数据，我主要利用 &lt;a href="https://www.yhat.com/products/rodeo" data-editable="true" data-title="Rodeo"&gt;Rodeo&lt;/a&gt;(Yhat's 的 IDE)来进行数据分析。&lt;/p&gt;&lt;h2&gt;数据收集&lt;/h2&gt;&lt;p&gt;首先我想从我的 iPhone 中导出用于分析的步行数据，Quantified Self 实验室的工作人员开发了一个数据提取的便捷工具——&lt;a href="http://quantifiedself.com/access-app/app" data-editable="true" data-title="QS Access" class=""&gt;QS Access&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以下是一组关于步行数据的截图： &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-da27bcecce398c32037d2d65bdee248a.png" data-rawwidth="756" data-rawheight="768"&gt;&lt;p&gt;QS Access 应用可以提取出一个包含某个时期内步行数据的 CSV 文件，该文件中包含三列变量——开始时点、结束时点和步数。&lt;/p&gt;&lt;h2&gt;数据分析&lt;/h2&gt;&lt;p&gt;我主要利用 pandas 中的时间序列分析工具来分析数据，当 &lt;a href="https://github.com/wesm" data-editable="true" data-title="Wes McKinney"&gt;Wes McKinney&lt;/a&gt;开始处理 pandas 项目时，他就已经在一家投资管理公司工作，该行业广泛依赖于时间序列分析方法。因此，pandas 中包含非常多的时间序列分析函数。&lt;/p&gt;&lt;p&gt;首先，当我们拥有了时间序列数据后，我们可以定义参数 parse_dates 使得 pandas 可以正确地处理时间序列数据。对于我们来说，结束时点变量并没有包含额外的有价值的信息，所以我们在分析过程中将不考虑该变量的情况。&lt;/p&gt;&lt;p&gt;最后我们将开始时点变量设定为索引变量，这个设定有助于我们进一步的数据分析。&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-cb823ae0b8c7cdb321cfb85559b6742a.png" data-rawwidth="469" data-rawheight="273"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-5cb0777e9d06b074bdbdd589d10fa078.png" data-rawwidth="350" data-rawheight="328"&gt;&lt;h2&gt;每小时步行数据&lt;/h2&gt;&lt;p&gt;如何快速地绘图分析现有的步行数据呢？&lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-517322a3a783ba8287e5c23a71f3d4ad.png" data-rawwidth="848" data-rawheight="610"&gt;&lt;p&gt;很不幸的是，我们无法从上图中得到比较有价值的信息，我们应该如何提高可视化效果呢？我想到一个好主意——我们可以利用 pandas 中的 resample 函数来改变数据集的时间粒度。&lt;/p&gt;&lt;p&gt;更精确地说，我们可以利用 &lt;strong&gt;downsampling&lt;/strong&gt; 的方法来降低时间的频度。比如，我们可以采集每小时的数据，然后利用重抽样和汇总计算的方法获得日度数据、周度数据和月度数据。&lt;/p&gt;&lt;h2&gt;获取每天步行数据&lt;/h2&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-93958825cb92b597c443fae2990b2dfc.png" data-rawwidth="460" data-rawheight="260"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-eed90038c0587b437ecdbb691ab1feff.png" data-rawwidth="814" data-rawheight="600"&gt;&lt;p&gt;从上图中我们可以看出，每天的步数存在一个上升趋势，随着时间的推移，步行的路程越长。&lt;/p&gt;&lt;h2&gt;获取每周和每月步行数据&lt;/h2&gt;&lt;p&gt;和上述代码一样，只要将 W 和 M 传递到 resample 函数中就能得到每周和每月的步行数据。&lt;/p&gt;&lt;p&gt;由于我更关心每天的运动情况，所以我将利用平均函数来计算每周或每月中平均每天的步行情况。具体的代码如下所示：  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-fb147340d71fc16050f7e75194e392b4.png" data-rawwidth="473" data-rawheight="92"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-6dfc710d95c16669e3f2a86b7cbeb18a.png" data-rawwidth="746" data-rawheight="1230"&gt;&lt;h2&gt;更深入的分析 &lt;/h2&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-bd031dbee54442ad40d8957abbb1108d.png" data-rawwidth="728" data-rawheight="414"&gt;我很好奇的一件事是：工作日的运动量是否大于周末的运动量？我们可以利用 weekday 和 weekday_name 两个方法来帮助分析。对于每个时间戳数据，前者可以得知它属于一周中的第几天，而后者可以得知该时间点对应的时间名字信息。添加完这两个新变量后，我们还可以添加一个布尔变量来表示某个时间点是否是周末。  &lt;/p&gt;&lt;p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-10b3ef4230e541c99d0787e512470263.png" data-rawwidth="443" data-rawheight="241"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-50f45e5106d0cd6481ea9a07fcfde141.png" data-rawwidth="782" data-rawheight="320"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic4.zhimg.com/v2-309ea9bbb6482aa8165b391aeab49314.png" data-rawwidth="444" data-rawheight="123"&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic1.zhimg.com/v2-023a6be32e57867dbc7381f80a56febb.png" data-rawwidth="844" data-rawheight="620"&gt;此外，我们还可以根据变量 weekend_bool来做分类汇总处理，并对比两组数据的差异情况。  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic2.zhimg.com/v2-2a7ad8bd2cc939d6b9b73b2e73196f19.png" data-rawwidth="361" data-rawheight="536"&gt;&lt;p&gt;从上述结果中可以看出，周末期间的每天平均步数是 11,621 步，中位数是 10,228，而工作日期间的每天平均步数是 10,146 步，中位数是 9,742，因此我们可以认为周末期间的运动量更大。&lt;/p&gt;&lt;h2&gt;趋势分析&lt;/h2&gt;&lt;p&gt;最后让我们来讨论下上文提到的上升趋势，四月初由于工作的原因，我从夏洛特搬到了纽约城，担任 &lt;a href="https://www.yhat.com/" data-editable="true" data-title="Yhat"&gt;Yhat&lt;/a&gt;的软件工程师。&lt;/p&gt;&lt;p&gt;我想知道经过这次搬家之后，我每天的步行情况有没有发生改变？我们可以利用上文分析周末与工作日步行情况的方法来分析这个问题。  &lt;/p&gt;&lt;img rel="noreferrer" src="https://images.weserv.nl/?url=ssl:pic3.zhimg.com/v2-528af85dd333c65fdfbb211964b2a0bb.png" data-rawwidth="808" data-rawheight="1236"&gt;&lt;p&gt;从上图中我们可以轻易地看出自从搬到纽约城之后，每天的运动量确实增加了。但这是由多方面因素共同决定的，比如搬到纽约城后我的跑步次数增加了，这会增加每天的平均步数。如果想要进行更深入的分析，我们需要获取更多的数据支持，由于篇幅问题，我们将在之后的文章中继续分析。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;我希望这个分析可以让您开始关注自己每天的步行情况，并利用 &lt;a href="https://www.yhat.com/products/rodeo" data-editable="true" data-title="Rodeo"&gt;Rodeo&lt;/a&gt; 和 &lt;a href="http://pandas.pydata.org/" data-editable="true" data-title="pandas"&gt;pandas&lt;/a&gt; 来分析数据。如果你对这个项目感兴趣的话，可以参阅&lt;a href="https://github.com/rkipp1210/data-projects" data-editable="true" data-title="该链接"&gt;该链接&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;http://weixin.qq.com/r/WkMCGqvEoPbfre959xZI (二维码自动识别)&lt;/p&gt;&lt;p&gt;原文链接：&lt;a href="http://blog.yhat.com/posts/phone-steps-timeseries.html" class="" data-editable="true" data-title="Å·hat | Analyzing iPhone Step Data"&gt;Å·hat | Analyzing iPhone Step Data&lt;/a&gt;&lt;/p&gt;&lt;p&gt;原文作者：Ross&lt;/p&gt;&lt;p&gt;译者：Fibears&lt;/p&gt;&lt;img rel="noreferrer" src="https://ga-beacon.appspot.com/UA-41015557-4/page-name?dt=https://zhuanlan.zhihu.com/p/23540254&amp;pixel&amp;useReferer"/&gt;</description><author>Datartisan</author><pubDate>Thu, 15 Dec 2016 10:28:56 GMT</pubDate></item></channel></rss>