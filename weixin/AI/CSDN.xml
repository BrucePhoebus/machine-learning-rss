<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>CSDN大数据</title>
    <link>http://www.iwgc.cn/list/1933</link>
    <description>CSDN分享Hadoop、Spark、NoSQL/NewSQL、HBase、Impala、内存计算、流计算、机器学习和智能算法等相关大数据观点,提供云计算和大数据技术、平台、实践和产业信息等服务.</description>
    <item>
      <title>游戏与算法的必经之路</title>
      <link>http://www.iwgc.cn/link/4228197</link>
      <description>&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文为姜雪伟原创文章，未经允许不得转载。注：文中所有标蓝部分均可阅读原文获取详情。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为一个在IT行业工作十五年的老兵，笔者在这里将自己多年的学习游戏算法经验分享给读者，希望能够帮助那些想学习算法提升自己的读者。算法是IT产品研发的核心，在IT的任何领域都离不开算法，目前比较流行的IT领域有：大数据，人工智能，深度学习，游戏开发，虚拟现实，增强现实等，这些领域的核心都是算法，可见算法在IT领域的重要性。本文主要聚焦游戏算法，游戏开发不外乎3D引擎接口调用和游戏逻辑编写，3D游戏引擎的主要功能是渲染，渲染使用的是图形学算法针对GPU编程的。客户端逻辑的编写也会用到一些算法，比如抛物线算法，曲线插值算法，A＊寻路算法等等。算法的优势主要体现在游戏核心功能和效率优化上面，作为IT程序员来说，如果对算法不精通，或者不知道如何在程序中使用算法，随着时间的推移会逐步被行业淘汰。当然大家也不必为此担心，笔者在此总结了学习算法必经之路的三个主要阶段。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;第一阶段 基础篇&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于初始学习&lt;/span&gt;&lt;span&gt;算法&lt;/span&gt;&lt;span&gt;的读者，首先要把基础算法学好，也就是把大厦的地基要打牢，毛泽东说过“理论联系实际”，学习算法先要把理论知识学好，给读者推荐的学习资料是大学的经典课程《数据结构与算法》，涉及到的主要知识点有：快速排序，二叉树排序，二分查找，哈希表，二叉树等。掌握这些数据结构并能运用它们解决实际问题，千万不要死记硬背，亲自动手将算法书写一遍，编程的过程就是要反复的练习。另外，还要学习一些关于矩阵、向量运算的知识点，这些知识点也是游戏开发必备的。给读者推荐的资料是大学课程《线性代数》。掌握这些知识的方法就是读者都要动手将它们逐行代码敲一遍并且用脑子反复琢磨领会贯通。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以二叉树为例，介绍其在游戏开发中使用的案例，二叉树在图论中是这样定义的：二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。它在游戏中应用案例给读者介绍一下，在游戏开发中经常使用图集，就是把多张小图片合成一张大的图片一次性加载到内存中，优化了内存加载效率，生成图集的算法就是用二叉树算法实现的，算法流程就是首先生成一块内存用于存储大图片，然后新建一个空的二叉树，把小图片看作是二叉树的子节点，依次去挂载到二叉树的叶子节点上，挂接的顺序采用的是先序遍历的思想，这样一张图集就生成了。如果本阶段的知识点读者已经掌握了可以直接略过，接下来进入第二阶段进阶篇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;第二阶段 进阶篇&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进阶篇阶段是学习一些相对基础篇比较复杂的算法，进阶篇的算法主要包括：A*算法，八叉树算法，Perlin噪音等，笔者建议学习的资料是关于游戏编程方面的书籍《游戏编程大师技巧》（上下册）这两本书非常经典，虽然其接口有些旧，但里面的编程理论非常适用游戏开发，笔者利用它的编程思想编写了一本适合初学者学习的《手把手教你架构3D游戏引擎》一书。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面以八叉树算法为例给读者介绍其应用，八叉树（octree）是三维空间划分的数据结构之一，它用于加速空间查询， Octree的实现原理主要分为六步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一步、设定最大递归深度；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二步、找出场景的最大尺寸，并以此尺寸建立第一个立方体；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三步、依序将单位元素丢入能被包含且没有子节点的立方体&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第四步、若没有达到最大递归深度，就进行细分八等份，再将该立方体所装的单位元元素全部分担给八个子立方体；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第五步、若发现子立方体所分配到的单位元元素数量不为零且跟父立方体是一样的，则该子立方体停止细分，因为跟据空间分割理论，细分的空间所得到的分配必定较少，若是一样数目，则再怎么切数目还是一样，会造成无穷切割的情形；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第六步、重复3步骤，直到达到最大递归深度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给读者举个游戏案例，假设：我们有一个大的房间，房间里某个角落站了一只小动物，我们想很快的把小动物找出来，该如何做？我们可以把房间当成一个立方体，先切成八个小立方体，然后排除掉没有放任何东西的小立方体，再把有可能藏小动物的小立方体继续切八等份….如此下去，平均在Log8(房间内的所有物品数)的时间内就可找到小动物。因此，八叉树就是用在3D空间中的场景管理，可以很快地知道物体在3D场景中的位置，或侦测与其它物体是否有碰撞以及是否在可视范围内。进而八叉树的应用场景可以推广到解决如下技术问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一、用其加速用于可见性判断的视锥裁剪；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二、加速射线投射，如用作视线判断或枪击判定；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三、邻近查询，如查询玩家角色某半径范围内的敌方NPC；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;四、碰撞检测的粗略阶段，找出潜在可能碰撞的物体对。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现的八叉树效果图展示如下所示：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUC584ibMcA4icBtvX95T52EMqZ5nuoV73GrveQaqe9IY9oRJlEdsPTHjJw/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;第三阶段 提高篇&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;掌握了第二阶段的学习后，接下来到了真正的提高篇，也就是“武林秘籍”的最高境界。提高篇主要是学习图形学算法编程，推荐给读者学习的书籍是：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;《Mathematics for 3D Game Programming and Computer Graphics》和《Real-Time&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rendering》这两本书相对来说比较难。但是写的非常好，有助于提升技术水平。市面上比较知名的引擎都使用了GPU编程技术，这些技术算法主要包含：PSSM算法、SSAO算法、Bloom算法、Blur算法、HDR算法、Deferred算法等，它们也是引擎的核心算法。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点此&lt;span&gt;查看&lt;/span&gt;作者有关《&lt;span&gt;【系列直播】算法与游戏实战技术&lt;/span&gt;》经验分享。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以PSSM算法为例，给读者分享一下应用案例，如何在游戏中使用，首先要了解其原理：PSSM全称 Parallel-Split Shadow Map&amp;nbsp;&lt;/span&gt;&lt;span&gt;PSSM算法的核心就是把视椎体进行分割，然后分别渲染组合。语言讲解不如看图直观，先通过视锥体分割说起。效果如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;视锥体分割效果图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUCga40W2XR7OUiaOu0SpVe6PRFV8hkyE6qibHiaNsKaaM1VRrA3EB89ovXg/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PSSM实时阴影的绘制首先需要灯光，在现实生活中，白天只有太阳出来了才可以看到影子。在虚拟世界中也是一样的，场景使用的是Directional（平行光）相当于现实世界的太阳光。上图左边部分显示的是视景体的投影，利用PSSM算法将其平行的分割成多个部分，然后对每个部分进行渲染，分割成的块数是可以自己设置的。右半部分是顶视角观看的分割效果，把物体分成三块进行实时阴影的渲染。渲染的计算是GPU中执行的，在GPU中执行的流程如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;渲染分解效果图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUCHeaokyos0zXyrjYiaOLIDs4BYIANsPBH1lXwQLLXRezl2iby0SwpzZNg/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图的处理流程首先是场景中的灯光照射到需要投影的物体上，接下来程序对投影的物体顶点进行矩阵变换将其转换到投影空间中，再转换到裁剪空间进行视口的平行分割，最后将其分别渲染出来。原理清楚了代码编写就很简单了，具体代码读者可以查看《手把手教你架构3D游戏引擎》一书，下面给读者展示效果图如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUCeZWnic1icthdPdkpKdn7GIrzfLGAOO5TPBmb8iczWuBTS633lXAVS7q3Q/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面笔者分享一下学习算法的感受，刚踏入IT行业时也不会算法编程，对算法有一种恐惧感，总感觉算法很神秘，更不知道如何使用，自己为此也苦恼过。刚入职公司的时候跟大多数程序员一样写写逻辑，两年后，自己感觉水平也比较牛了。为此，自己申请加入到公司核心部门引擎部，初衷就是看看引擎组都做些什么事情，当然也是想学习一些知识为了跳槽涨工资。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入引擎组后，经历了一件事情彻底改变了我，更让我认识到算法的重要性。事情是这样的，端游中实现的刀光拖尾算法，功能包括：取样插值并且实现材质的扭曲效果，当时接到任务一下子就懵了，在网上不停的翻资料，那时网上没有这方面的技术实现，最后只能硬着头皮自己动手写了，经过一周的折腾，选择了B样条曲线插值算法，再经过一周将其实现了出来，最后一周的时间，度日如年，晚上基本上都没睡好，做梦都想着如何实现算法。有时自己都想离职走人了，感觉压力太大了，但是最终还是实现出来了。经历过这段刻骨宁心的经历，让我明白了算法是如何与游戏开发相结合的，也让我明白了自己算法知识的薄弱，需要从头开始把算法学好，最终我也是按照上面这三个阶段学习的。在学习算法的过程中痛并快乐着，学习算法首先要明白其原理，然后再用代码敲一遍实现出来，切记眼高手低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来笔者独立写过几款3D引擎包括：3D渲染引擎，海水渲染引擎，物理引擎等。现将实现的效果给读者展示如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;海水渲染反射折射效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUCsIicDuR3fwemQibQRcy6oNdROhCvyg68Te8CHQOuKuTiaQDxwhhs7m9EQ/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;➤&lt;/span&gt;实时航行轨迹模果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUC20PBiaByZyNQQia6mrE50KhY5iciadBWicCahJfI7gKKTcNEHyTtxAXUQ3g/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后给读者一个建议：学习算法关键是我们要有一个正确的学习方法再结合着实战项目就可以快速的提升自己的技战水平。算法的学习不是一朝一夕的，只要找对学习方法，分阶段学习，持之以恒，相信随着经验的积累将来在IT“武林“真的可以独步天下，以此文与读者共勉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;作者：姜雪伟，创业公司技术合伙人，畅销书作者。CSDN社区专家，资深3D游戏引擎开发者，IT高级讲师，计算机图形学方向研究生。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Fri, 06 Jan 2017 17:10:04 +0800</pubDate>
    </item>
    <item>
      <title>Fregata: Spark上支持万亿维机器学习模型</title>
      <link>http://www.iwgc.cn/link/4228198</link>
      <description>&lt;p&gt;&lt;span&gt;大规模机器学习工程上最大的挑战是模型的规模。在计算广告，推荐系统的场景下，运用Logistic Regression算法时常需要做特征交叉。原来两组，三组特征的数量可能并不是太大，但是通过交叉后可能会特征数会爆炸。例如，用户特征数1万，广告特征数1万，那么交叉后总特征数就是1亿，如果再与几十个广告位特征交叉，总特征数就会达到几十亿。有些情况下，特征交叉后，总数甚至能达到上千亿。特征数量的爆炸，也带来模型规模的爆炸，这给机器学习带来的挑战比庞大的训练数据量更大。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常认为，当模型的规模超过单节点的容量后，基于MapReduce计算模型的Spark, Hadoop MapReduce就无法支持了。为了解决这一问题，Parameter Server应运而生，目前是大规模机器学习研究方面的前沿。目前Parameter Server还在发展的过程中，其使用，开发门槛相较于Spark来说都是较高的，而且在大数据平台中再引入一套新的计算平台，对整个体系的管理，运维都将带来更大点挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fregata致力于在Spark上解决大规模机器学习的问题，Fregata目前已经公开发布的版本已经能支持亿级维度的模型，而目前内部最新版本已经在一个月内连续突破了10亿，100亿，1000亿和10000亿4个台阶。在模型规模提高了4个数量级的同时保持了训练的高效性。下面是 Fregata的Logistic Regression算法在511412394个样本的训练集下的训练时间：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjV74w43tGJIZSjZlON3zGmwFRojsvib3JCSiaVdiaWrQtY83MeExLK0Hn8CwiaZUHLXqekoh5oBQFNdSQ/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上表可以看出，对于5亿多样本的训练集，在仅使用48个Executor的情况下，千亿维度以内的问题，都可在500秒内完成，而且每个Executor仅需最多2G内存。对于万亿维度的问题，训练时间也仅需800秒多一点，只是Executor的内存加到了8G。Fregata最近的突破，打破了在Spark上无法支持超大规模模型的瓶颈，将进一步降低大规模机器学习的使用门槛和成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fregata 项目地址：&lt;/span&gt;&lt;span&gt;https://github.com/TalkingData/Fregata&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：张夏天，TalkingData首席数据科学家。12年大规模机器学习和数据挖掘经验，对推荐系统、计算广告、大规模机器学习算法并行化、流式机器学习算法有很深的造诣；在国际顶级会议和期刊上发表论文12篇，申请专利9项；前IBM CRL、腾讯、华为诺亚方舟实验室数据科学家；KDD2015、DSS2016国际会议主题演讲；机器学习开源项目Dice创始人。&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎人工智能技术投稿、约稿、给文章纠错，请发送邮件至heyc@csdn.net&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Fri, 06 Jan 2017 17:10:04 +0800</pubDate>
    </item>
    <item>
      <title>【微信群分享报名】分布式实时处理系统架构设计与机器学习实践</title>
      <link>http://www.iwgc.cn/link/4228199</link>
      <description>&lt;p&gt;&lt;span&gt;编者按： 2016悄然而过，不管你收获多少还是失去什么，都已然过去，但接下来的2017年，唯有不断的武装自己并强化自身的硬实力才是正确之举，CSDN高级架构师群特为受众们继续带来知识分享，毕竟在这个物欲横流的世界里，这已属难能可贵，希望我们能一起携手前行，共同成长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享人&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjV74w43tGJIZSjZlON3zGmwGHTMaTgbLB17xX2SqFOwM7Df2EMSVkCth8euTmjOeaCfjtSbYOxsPQ/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;卢誉声，Autodesk软件研发工程师，从事平台架构方面的研发工作。在此之前，他曾在思科系统（中国）研发中心云产品研发部工作，并参与了大规模分布式系统的服务器后端、前端以及SDK的设计与研发工作，在分布式系统设计与实现、性能调优、高可用性和自动化等方面积累了丰富的敏捷实践与开发经验。他主要从事C/C++开发工作，致力于高性能平台架构的研究与开发。此外，对JavaScript、Lua以及移动开发平台等也有一定研究。著有《分布式实时处理系统：原理、架构和实现》，并译有《Storm实时数据处理》《高级C/C++编译技术》《JavaScript编程精解（原书第2版）》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享主题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《分布式实时处理系统架构设计与机器学习结合的未来展望》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;主题摘要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;机器学习与实时处理系统应用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分布式计算拓扑搭建&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消息算法调优&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hurricane计算框架与未来展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;听众受益&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高性能分布式海量数据分析系统架构设计原理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时处理系统案例实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;机器学习与分布式系统结合&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全新开源分布式系统介绍与展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Slides部分截图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjV74w43tGJIZSjZlON3zGmwqxD0iaY6icM6FN1nYkBffo87LsH56qIF9Nd8rlicVvT3ZdHdso1GQ0Q2g/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其它&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时间：11月11日，20:00（请提前十分钟进场签到）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时长：1小时（含QA）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方式：主要文字+图片（语音为辅）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;地点：CSDN架构师金牌授课群&amp;amp;大数据架构群&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;听课费用：每人1元，先进群后支付群活动收款即可，全部费用转讲师收取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分享整理：会首发在群里，并整理发布在CSDN网站和官方资讯微信公众号上，并提供Slides下载地址。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;报名方式：加群主微信qianshuguangArch，申请入群，需备注姓名+公司+职位+微课堂，已在群的无需重复申请。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjV74w43tGJIZSjZlON3zGmw55ia3V3A0ZJ0snp2XDqwJETTEM7oVuRwdicBk3HjU0927iaicYyOdQY5Zw/0?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫一扫就吃掉我喔，记得备注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjV74w43tGJIZSjZlON3zGmwaaWxCzRibm7qdcZqwD7rEakZRO7vK3IibzHxfgQMehrNqcjIR80BqpwQ/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫一扫为义务的知识付费1元。&lt;/span&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 06 Jan 2017 17:10:04 +0800</pubDate>
    </item>
    <item>
      <title>机器码农：深度学习自动编程</title>
      <link>http://www.iwgc.cn/link/4212672</link>
      <description>&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&amp;nbsp;&lt;span&gt;&lt;strong&gt;本文为&lt;/strong&gt;&lt;strong&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;《程序员》&lt;/a&gt;原创文章，未经允许不得转载，更多精彩请&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;订阅2017年《程序员》&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器自动编程是人工智能一直以来期望攻克的重要应用领域，随着深度学习的逐步流行，最近在自动编程方向获得了广泛应用并取得了很大进展。深度学习如何指导机器自动编写出能正确执行的代码？本文对这方面的最新技术进展进行了介绍，将主流技术分为“黑盒派”和“代码生成派”两种派别，并分别介绍了对应代表系统：“神经程序解释器”及“层级生成式CNN模型”的工作机理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着深度学习技术的快速进展，人工智能时代的序幕已经揭起，目前深度学习在图像处理方面的能力已经接近人，甚至在某些方面已经超过人的识别能力，在语音识别、自然语言处理等人机交互方面也取得了很大的技术进步。在未来社会，各行各业的不同类型工种逐步由机器代替人作为一个社会发展趋势已经开始逐步显现，比如工业机器人目前已经开始在工厂大量使用，特斯拉也已经在在售汽车中启用自动驾驶功能，由人工智能部分代替了传统的驾驶员的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前看人工智能已经能够成功从事一些体力为主的工作岗位，那么程序员作为一个脑力密集型劳动岗位，是否会被机器取而代之？从技术和社会发展趋势来看，这个问题在很大程度上可能会是个肯定答案。那么机器码农如何理解需求？如何根据需求秒速写出代码？本文后续内容将介绍相关技术，尤其是深度学习相关的一些技术思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度学习介入自动编码领域是最近两年的事情，目前深度学习系统自动编码能够解决的问题还比较简单，比如能做到自动根据训练数据写出冒泡排序等算法，根据例子学会十位数加减法以及字符串正则匹配规则等，所以短期内机器码农还没有替代人类程序员的可能。但也要看到随着深度学习在自动编码领域的深入应用，其技术发展速度是非常快的，极有可能在未来几年有突破性的技术进展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;归纳程序综合问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何让机器自动产生代码这个问题由来已久，是人工智能一直希望攻克的重大问题之一，传统上一般将这个问题称为“归纳程序综合”（Inductive Program Synthesis，简称IPS）问题。IPS问题的研究目标是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给定一组&amp;lt;输入，输出&amp;gt;数据对，如何自动产生一段代码，这段代码能够正确地将这些给定的输入转换为给定的输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的研究方法里，建立能自动产生代码的IPS系统一般主要涉及两个过程：代码组合空间搜索以及代码排序。一般编程语言可以形成的程序语句是非常多样的，如果随机选择其中一些语句组合起来，就能够对输入数据完成某种转换的任务形成输出。但是这种合法代码组合出的空间非常大，在这么大的代码语句组合空间里，到底哪些语句组合起来能够将给定的那组&amp;lt;输入，输出&amp;gt;数据进行正确的转换呢？这就需要在巨大的代码组合空间中进行搜索，找到那些能够对给定数据都能进行转换的代码片段，这些代码片段就是机器自动产生的程序。很明显，这里的关键是设计高效的搜索算法。另外，在代码组合空间里搜索，有可能找到很多段程序，这些程序都能够将输入数据进行准确地转换，那么到底输出哪一段最合理呢？这就是代码排序要做的工作，就是给多段完成相同功能的代码进行排序，找出最好的那一段，比如一种简单直观的方式是输出代码长度最短的那段作为自动生成的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面介绍的是传统IPS系统的设计思路，最近深度学习也开始被频繁应用到代码自动生成领域，后面内容主要介绍典型的相关技术思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;机器如何使用深度学习学会自动编程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;武侠世界分门别派是个常态，有少林、武当、峨眉、崆峒等派别之分，神经网络自动编程目前的主流技术路线也可以分为两派：“黑盒派”和“代码生成派”。尽管都采用了深度学习技术，但是两者在路线方向上有较大差异，也各有特点。下面我们分述两派的基本技术思路及其相应的代表系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;黑盒派&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“黑盒派”是神经网络编程的一类典型方法，所谓“黑盒”，是指编程系统并不显示地输出代码片段，而是从输入输出数据中学习转换规则，通过这些转换规则能够完成某项任务，正确地把输入转化为输出，所学习到的这些转换规则和输入输出数据中的规律则以神经网络参数的方式体现，所以并没有明确的代码或者规则输出，在人类眼中，只能看到能够完成指定任务的训练好的神经网络，至于它学到了什么规律并不清楚，这是为何称之为“黑盒”的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhQTVgicxB7utKKH59teA2U20pgEd4EHwG7jZUcfCpUchX3j62lTAl7muib1Ltz2Zz9nl5sz0FVW27A/0?"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;center style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;图1 “黑盒派”技术思路&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1展示了“黑盒派”神经网络编程器的基本运行思路，其主体部分包含三个关键部件：神经网络控制器、神经网络感知器以及行为器。神经网络感知器用来感知当前的输入数据并抽取输入数据的特征，神经网络控制器则根据输入数据的特征来判断当前应该对输入数据实施何种行为（比如对于数组排序来说可能是交换两个数值的SWAP(number1,number2)操作），属于决策机构，也是神经网络编程器中类似于人类大脑的关键构件，当确定了采取何种行为后，调用行为器来对输入数据进行实际操作，这样就将输入数据做了一步变换，形成中间数据，之后这个新形成的中间数据继续作为感知器的新输入，如此循环，就能够对原始输入数据不断变换，来完成比如数组排序等任务。在训练阶段，人类提供完成某项任务的一些输入及其对应的输出数据，并指定对应的行为序列，以此作为训练数据，训练神经网络编程器的学习目标是让深度学习系统模仿这种针对输入数据的行为过程，最终能够形成正确地输出数据。当训练完毕后，这些转换规则就被编码到神经网络的网络参数中，当实际应用时，提供一个新的输入，神经网络感知器对输入数据进行特征提取与表示，神经网络控制器决定采取何种操作，行为器对输入数据进行实际的变换行为，形成中间结果，如此反复，直到神经网络控制器决定终止操作，此时得到的结果就是程序对应的输出结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上述过程中可知，“黑盒派”神经网络编程器并不产生具体的代码来完成编程任务，而是学习输入数据和输出数据之间的规律及其转换规则。从广义上来说，神经图灵机等网络模型虽然不是专门用于编程，而是用于更通用的任务过程中，但是其实也是符合这种“黑盒派”架构的基本思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhQTVgicxB7utKKH59teA2U2rYDXsUFYaZlB3IKY0PV4MnQYu5Xgkf6q7rpMzv6vRcWsH9dNvOaSLw/0?"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;center style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;图2 神经程序解释器（NPI）运行机制&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;神经程序解释器（Neural Programmer Interpreters，简称NPI）是Google提交到ICLR 2016的会议论文中提出的神经网络编程模型，这篇论文因新颖的思路及创新应用获得了ICLR 2016最佳论文奖。神经程序解释器是一种典型的“黑盒派”方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NPI的主体控制结构是递归LSTM（参考图2所示），这种递归LSTM结构可以体现程序与子程序之间的调用关系。至于什么是递归LSTM后文会有解释，我们先根据图2所示内容来说明NPI的运行过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在t时刻，LSTM的输入包括当前选中的子程序以及此时的输入数据，经过Encoder编码网络对这两个输入进行映射，形成t时刻LSTM输入层的内容。这个过程其实就对应图1中的神经网络感知器，用来对输入数据进行编码和特征提取，在NPI中，不同类型的任务可能对应不同的Encoder编码网络，因为不同任务的输入类型各不相同，比如有的是图片，有的是数组等，所以很难有公用的输入编码器能够统一处理，但是不同任务会共享LSTM层参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在对输入进行特征编码之后，t时刻的LSTM隐层单元对输入以及LSTM网络t-1时刻的隐层信息共同进行非线性变换，这是对历史信息和当前输入的特征融合；然后，通过三个解码器来产生t时刻的三种类型的输出：Decoder_1根据隐层编码信息产生一个概率值P，这代表了当前程序结束的可能性，当P高于阈值的时候，当前程序终止；Decoder_2输出子程序库中某个子程序的ID，这代表发生了&amp;lt;主程序，子程序&amp;gt;间的调用关系；Decoder_3输出新映射到的子程序所需的参数信息列表，Decoder_2和Decoder_3一起可以触发被调用的子程序。可以看出，LSTM结构以及子程序库其实就是图1中所示的神经网络控制器，它决定了神经网络所需要做的各种决策。NPI没有明确的行为器，这些行为隐藏在被调用的子程序中，一般不同的子程序会定义针对输入数据的不同操作，调用子程序会触发子程序的操作来改变输入数据内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之所以说NPI是个递归LSTM结构，是因为当子程序被触发时，自身也形成了类似图2所示的LSTM结构，所以形成了递归LSTM的形态。当被调用的子程序中的某个时间步输出的程序终止概率P大于阈值时，会返回调用程序的LSTM结构中，继续下一个时间步的类似操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3所示是NPI自动学习十进制加法的结构示意图，其输入是不断被子程序变换内容的数组矩阵，其控制结构其实就是图2所示内容，只是展示出了被调用子程序的LSTM结构，所以看上去比较复杂，但其运行逻辑就如上文内容所述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhQTVgicxB7utKKH59teA2U28MqhJibNyrZ2NX6wTaLoCLAFsZe8KffvBRsQu97OkQJPbqd6eeABdHw/0?"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;center style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;图3 NPI学习十进制加法&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码生成派&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhQTVgicxB7utKKH59teA2U2XgTH3Z1BN8Udg6WDIqrrtbC0ywPibHjqsQicWHeeRpcpcxic3gELAibicEg/0?"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;center style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;图4 代码生成派&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“黑盒派”有个很容易被诟病的问题：对于开发人员来说，对神经网络到底从数据中学到了什么规律所知甚少，所以不利于分析系统存在的问题以及提出有针对性的改进方案。“代码生成派”在这一点上的思路和“黑盒派”有很大差异，更接近传统的解决“IPS问题”的思路，期望能够让机器码农像人类程序员一样把解决问题的过程形成代码片段。目前也有不少深度学习自动编码系统采用这一技术路线，尽管不同系统具体技术方案有较大差异，但其基本流程都是类似的，图4展示了从不同方案中抽象出的“代码生成派”神经网络自动编程的基本思路，分为模型训练阶段和模型应用阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在模型训练阶段，需要使用不同种类编程任务的训练数据来训练深度学习自动编程模型，一般训练数据包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任务Task&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;i&lt;/sub&gt;的一系列输入输出数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;{〈Input&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;1&lt;/sub&gt;,Output&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;1&lt;/sub&gt;&amp;nbsp;〉,〈Input&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;2&lt;/sub&gt;,Output&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;2&lt;/sub&gt;&amp;nbsp;〉……〈Input&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;n&lt;/sub&gt;,Output&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;n&lt;/sub&gt;&amp;nbsp;〉}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任务Task&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;i&lt;/sub&gt;对应的代码片段：Program&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;i&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这组训练数据的含义是：对于要执行的任务Task&lt;/span&gt;&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;i&lt;/sub&gt;&lt;span&gt;来说，当输入为Input&lt;/span&gt;&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;j&lt;/sub&gt;&lt;span&gt;的时候，经过任务的代码Program&lt;/span&gt;&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;i&lt;/sub&gt;&lt;span&gt;对输入进行各种变换，形成对应的输出Output&lt;/span&gt;&lt;sub style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;j&lt;/sub&gt;&lt;span&gt;。训练数据中可以包含各种不同类型的任务及其对应的训练数据，这形成了总体的训练神经网络模型的训练数据集合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前常用的编程语言有很多，比如JAVA、C++、Python、PHP等，对于机器码农来说，也存在着：“PHP是不是最好的语言”这种问题，就是说需要作出应该用什么语言产生代码的决策。一般不同的深度学习自动编码系统都会参考“领域特定语言（Domain Specific Language）”自己定义一种编程语言，而不是直接采用人类程序员常用的某种编程语言，这是因为对于机器产生代码来说，目前常用的编程语言过于复杂，里面包含了循环、分支判断等复杂控制逻辑，而根据“领域特定语言”定义的语言一般都比较简单，不包含这些控制逻辑，只包含一些基本原语，比如数值加一、数值减一、移动指针位置、读取某存储器内数据、将数据写入存储器某位置等基本操作原语。所有代码片段（包括训练数据对应的程序以及将来要生成的代码）都采用自定义的领域特定语言，这样会大大简化机器码农的学习难度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给定了各种任务的输入输出数据及其对应的代码片段，深度学习自动编程系统就可以开始使用SGD（随机梯度下降）算法来训练模型，一般神经网络的输入是某个任务对应的输入输出数据，而学习目标则是调整神经网络参数，使得其输出的代码片段和训练数据中对应的代码片段尽可能相同。通过这种方式可以训练获得自动编程模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在模型应用阶段，为了让机器码农能够针对新任务自动编写出解决任务的代码P（P能够正确地将给出的所有输入转换为对应正确输出），需要提供新任务的若干输入输出数据，这其实类似于日常程序员写代码的需求说明，只是以数据的方式体现的，否则不可能让机器漫无目的地去生成不知道在干么的代码，任务的输入输出数据其实是告知机器码农数据之间的映射规律。机器码农在获得新任务的输入输出数据后，根据训练阶段学习到的模型，可以预测出“领域特定语言”中的各种操作原语语句出现在代码片段P中的概率，可以认为出现概率较高的原语是代码片段P中应该包含的语句。这里需要注意的是：深度学习系统并不能准确地输出完整的代码片段，只能预测代码片段中DSL原语出现可能性。之后，可以采用某些搜索技术（比如线性动态编程或者宽度优先搜索等技术）在代码组合空间中寻找代码片段，这些代码片段能够准确地将给定的所有输入正确地转换为对应的输出。从这里可以看出，深度学习预测的结果起到的作用是形成代码组合空间搜索时的约束条件，能够大量减少搜索空间的大小，使得后续代码搜索过程极大地提速。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;层级生成式CNN模型（Hierarchical Generative Convolutional Neural Networks，简称HGCNN模型）是Facebook最近提出的一种具备“代码生成派”典型特点的深度学习自动程序推导方法。其整体工作流程符合上述“代码生成派”运行过程，只是图4中的“深度学习自动编程系统”模块采用了具体的HGCNN模型而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhQTVgicxB7utKKH59teA2U23TT5Zoib9kx2ico9fwDhLI5oN56gsP0Er9fhjURG5DgIMHVb9p2VfxSA/0?"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;center style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;图5 层级生成式CNN模型（HGCNN）&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5展示了HGCNN模型的神经网络结构。在模型应用阶段，对于需要编码的新任务，先提供若干满足任务处理逻辑的输入输出数据（HGCNN主要对数组进行各种类型的变换，比如图5中展示的例子是对数组进行排序）。对于每个输入输出数据，HGCNN使用四层采用全连接结构的DNN网络（图5中标为b的网络结构）来对其进行特征提取，每层网络包含512个隐层神经元。之后，将若干个输入输出数据的特征求均值作为输入输出数据的整体特征表示。可以看出，这个过程是对输入实例进行编码和特征提取的阶段。然后采用连续的CNN上采样（UpSampling）操作不断形成逐步扩大的二维结构矩阵，上采样是用来可视化展示CNN隐层所学到的特征所常用的技术，在这里采用上采样可以将输入输出数据中的特征规律以类似二维图形的方式展示；上采样形成的二维矩阵每次扩大一倍，直到形成最终的16*16大小的代码画布（Code Canvas），这个最终的代码画布代表了各种操作原语在最终代码中出现的可能性。代码画布的每一行代表一个操作原语语句，一个操作原语由某个操作符以及对应的两个参数构成（参考图5中的c部分）。GHCNN的“领域特定语言”定义的语言类似于汇编语言，图5中c子图展示的是Load 1 2的操作命令，图6则列出了这个语言定义的操作原语。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhQTVgicxB7utKKH59teA2U2EFQRXFT4xicjeUfjEpic6Phm5mWenL3o342oHFdKiaYuy2nxpician5zvYA/0?"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;center style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;图6 HGCNN的领域特定语言&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在获得了最终程序中可能包含的原语语句概率信息后，HGCNN采用宽度优先搜索策略在代码组合空间中搜索满足输入输出实例约束条件的代码片段，以此来最终形成输出的程序代码，这样就完成了指定输入输出实例后自动产生代码的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HGCNN有个特色是训练数据包括输入输出以及对应的代码完全自动生成得来，而不像很多其它系统需要提供现成的训练数据，从这点上说其运作机制有点类似于无监督学习。另外，从上述描述可以看出，本质上HGCNN是一种符合Encoder-Decoder（编码器-解码器）结构的具体模型，这里Encoder的编码对象是多个&amp;lt;输入,输出&amp;gt;数据，形成特征表示后采用Decoder来产生DSL原语语句，Decoder则是利用了上采样生成二维结构的方式生成DSL原语片段生成概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DeepCoder是另外一个采取“代码生成派”路线的深度学习自动编码系统，其主体思路和HGCNN类似，只不过使用的具体Encoder和Decoder不太相同，其整体运行流程也基本采用了图4所示的“代码生成派”典型流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题与展望&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用机器自动根据任务实例学习编写代码是能够极大提高代码开发效率的人工智能应用领域，而深度学习技术广泛使用在这个领域也是最近两年刚出现的新趋势，尽管取得了非常快速的技术进展，但是这个研发领域仍然面临一系列需要解决的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，深度学习自动编码研究仍然处于技术发展初期，目前也只能产生解决比较简单任务的代码，距离真正实用化的代码生成还有很大距离。其次，尽管提出了一些通用的解决方案，但是大部分技术的通用性仍然不够强。所谓通用性不强，是指当面临一类新的编程任务，需要重新训练神经网络参数，无法做到训练一次以后面对新场景时原先的神经网络能够反复适用，这对于技术的实用化应用是个很大的障碍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再次，对于机器自动产生的代码，很难验证其逻辑的正确性。自动产生的程序虽然能够将训练实例中给定的输入正确转换为指定输出，但是毕竟这些例子很有限，对于更多的输入其输出是否正确这点很难验证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然面临如上诸多困难，但是深度学习的蓬勃发展给很多应用领域都带来了根本性的性能提升，相信在未来几年内神经网络编码器领域会有大幅的技术进步，有可能在某些垂直领域产生真正实用化的机器码农。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;作者简介：张俊林，中科院软件所博士，曾担任阿里巴巴、百度、新浪微博资深技术专家，目前是用友畅捷通工智能相关业务负责人，关注深度学习在自然语言处理方面的应用。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;责编：何永灿，欢迎人工智能领域技术投稿、约稿、给文章纠错，请发送邮件至heyc@csdn.net。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Thu, 05 Jan 2017 17:09:10 +0800</pubDate>
    </item>
    <item>
      <title>用Rust解决C语言的隐患</title>
      <link>http://www.iwgc.cn/link/4212673</link>
      <description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;题记：相对于其它语言，使用Rust开发更能避免低级错误。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对笔者而言，Rust越用越顺手，接触越多也就越不能抵抗它的魅力，也因此才有了本文的诞生——希望大家能了解到这种语言的妙处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对大众来说，Rust最大的卖点在于它能确保代码的安全性，这是Rust相对于C语言的一个极大优势，也是令Rust与众不同的关键所在，这也是本文的重点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了让大家对Rust的优势有所了解，我们选择了这个地方入手——Rust是如何令开发者的日常工作更加轻松、更加惬意的。本文详细列举了样例，阐明Rust是如何完全地消弭那些继承自C语言的诸多隐患。这一优势再加上Rust的新潮功能，就促成了Rust符合人体工程学的体验——bug更少，代码更好&amp;nbsp;&lt;/span&gt;&lt;span&gt;（维护者半夜也能睡个好觉）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;100%的安全性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在列举例子之前，我们先来讨论一下Rust所使用的方式究竟安全在哪里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust中的大多代码被称为“安全”代码，确保代码100%的安全性。这个百分之百并非统计学意义上的，它没有达到编译器希望的那样完美，但只要代码能够编译，内存安全性和data-race freedom就能够保证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，这些措施无法避免开发者引入的逻辑错误，也就是说在极少数情况下，这些规则是可以打破的。这种情况下，开发者所编写的代码被称为“不安全的”代码。这类代码限制很少，开发者可以任意编写，但这样做的代价是：编译器不再确保安全性，结果可能会一塌糊涂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;隐患&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;strong&gt;&lt;span&gt;空指针引用（NULL Dereference）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;声名狼藉的程序分段错误（Segmentation Fault）是C语言的常见问题，而通常NULL dereferences是第一大诱因。如果开发者忘记了检查所返回的指针是否正确性，就可能会导致空指针引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;uint8_t* pointer = (uint8_t*) malloc(SIZE); // Might return NULL&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;for(int i = 0 ; i &amp;lt; SIZE ; ++i) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; pointer[i] = i; // Might cause a Segmentation Fault&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: square;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Rust中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust处理这类指针错误的方式非常极端，在“安全”代码中粗暴简单地禁用所有裸指针。此外在“安全”代码中，Rust还取消了空值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过不用担心，Rust中存在一个优雅的替代方案——引用和借贷的方式。本质上来说，这些引用（references）还是那些老指针，但有了生命周期（Lifetimes）和借贷（Borrowing）规则，系统就能确保代码的安全性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;let my_var: u32 = 42;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;let my_ref: &amp;amp;u32 = &amp;amp;my_var; // &amp;lt;-- This is a reference. References ALWAYS point to valid data!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;let my_var2 = *my_ref; // &amp;lt;-- An example for a Dereference.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;strong&gt;&lt;span&gt;释放内存后再使用（Use After Free）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一弊端会产生严重的漏洞，导致黑客随意操控你的代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面有一个样例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;uint8_t* pointer = (uint8_t*) malloc(SIZE);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;if (err) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; abort = 1;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; free(pointer);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;if (abort) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; logError("operation aborted before commit", pointer);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: square;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Rust中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像C++一样，Rust也使用资源获取即初始化（Resource Acquisition Is Initialization）的方式，这意味着每个变量在超出范围后都一定会被释放，因此在“安全的”Rust代码中，永远不必担心释放内存的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;fn foobar() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; let foo = Hashmap::new();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;^ &amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; let bar = Vec::new();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; ^&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; |&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; |&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; |&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; |&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; V&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp; } // `bar` will be freed once we get here&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| &amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;V &amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;} // `foo` will be freed once we get here&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但Rust不满足于此，它更进一步，直接禁止用户访问被释放的内存。这一点通过Ownership规则实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: square;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Rust中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;变量有一个所有权（Ownership）属性，owner有权随意调用所属的数据，也可以在有限的lifetime内借出数据（即Borrowing）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，数据只能有一个owner，这样一来，通过RAII规则，owner的范围指定了何时释放数据。最后，ownership还可以被“转移”，当开发者将ownership分配给另一个不同的变量时，ownership就会转移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;let foo = Hashmap::new();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;let bar = foo; // foo's ownership has been moved!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; } // the Hashmap will be freed here&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当向函数传递变量时，也会出现ownership转移，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;let foo = Hashmap::new();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;take_ownership(foo); // foo's ownership has been moved!&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // the Hashmap will be freed at the end of `take_ownership`&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而且被转移的数据是&lt;strong&gt;无法&lt;/strong&gt;使用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;let foo = Vec::new();&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; take_ownership(foo);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;foo.push(42);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// main.rs:7:5: 10:8 error: use of moved value: `foo` [E0382]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// main.rs:7 &amp;nbsp; &amp;nbsp; foo.push(42);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ^~~&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;执行Copy特性的类型也会被复制，比如执行Copy特性的原始整数类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;let foo = 42;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; i_copy(foo);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;println!("{}", foo); // foo still owns the data&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;strong&gt;&lt;span&gt;返回悬空指针（Dangling Pointers）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C语言老手都知道，向stack-bound变量返回指针很糟糕， 返回的指针会指向未定义内存。虽然这类错误多见于新手，一旦习惯堆栈规则和调用惯例，就很难出现这类错误了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是一个C语言的例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;uint8_t* get_dangling_pointer(void) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; uint8_t array[4] = {0};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; return &amp;amp;array[0];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// Returns a dangling pointer to a previously stack allocated memory&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: square;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Rust中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实证明，Rust的lifetime check不仅适用于本地定义变量，也适用于返回值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与C语言不同，在返回reference时，Rust的编译器会确保相关内容可有效调用，也就是说，编译器会核实返回的reference有效。即Rust的reference总是指向有效内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;fn get_dangling_pointer() -&amp;gt; &amp;amp;u8 {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; let array = [0; 4];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;amp;array[0]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// main.rs:1:30: 1:33 error: missing lifetime specifier [E0106]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// main.rs:1 fn get_dangling_pointer() -&amp;gt; &amp;amp;u8 {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;//&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;限于篇幅本文所述有限，不过还是有个问题值得一提，那就是生命周期的管理通常是在后台操作中进行，某些时候编译器不会自动推算返回reference的生命周期，这种情况下只需明确指定就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;fn get_static_string() -&amp;gt; &amp;amp;'static str {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; "I'm a static string!"&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// This works because we are returning a string with a `static` lifetime.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// A static lifetime simply means that it'll live for the entire duration of the program&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;strong&gt;&lt;span&gt;超出访问权限（Out Of Bounds Access）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一个常见问题就是在访问时，访问了没有权限的内存，多半情况就是所访问的数组，其索引超出范围。这种情况也出现在读写操作中，访问超限内存会导致可执行文件出现严重的漏洞，这些漏洞可能会给黑客操作你的代码大开方便之门。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近来这方面最著名的就是 Heartbleed bug，可以参见&lt;/span&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); text-decoration: underline; max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;相关消息&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面有个简单样例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;void print_out_of_bounds(void) {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; uint8_t array[4] = {0};&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; printf("%u\r\n", array[4]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// prints memory that's outside `array` (on the stack)&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: square;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Rust中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这种情况下，Rust利用运行时检查以减少这种不必要的行为，非常方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是一个样例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code class="" style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp;fn print_panics() {&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; let array = [0; 4];&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; println!("{}", array[4]);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;// thread '&amp;lt;main&amp;gt;' panicked at 'index out of bounds: the len is 4 but the index is 4', main.rs:3&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 style="max-width: 100%; color: rgb(62, 62, 62); line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前来说，Rust似乎前途无量，本文只对Rust用于保护代码安全性的规则做了简单一瞥，经过精心提炼的规则可以让开发者避开明显的陷阱，轻松惬意地编程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;CSDN Rust语言交流群，请加群主微信qianshuguangarch申请，备注：姓名+公司+职位+Rust。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Thu, 05 Jan 2017 17:09:10 +0800</pubDate>
    </item>
    <item>
      <title>《程序员》1月精彩内容：区块链技术与应用探索</title>
      <link>http://www.iwgc.cn/link/4212674</link>
      <description>&lt;p&gt;&lt;span&gt;如果你关注区块链技术长达几个月，可能已经对没完没了的概念介绍、前景描绘、行业探讨和链圈新闻产生了审美疲劳。没错，区块链必须与行业紧密结合，它也有颠覆人类协作方式之洪荒巨力，但是说到底它还是一个技术活，是要写代码的，在咖啡厅里整天坐而论道是造不出金链子来的。技术人员的逻辑简单直接，这个事情有没有前（钱）途？若有，该怎么干？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDialS1KcyqV7mSOWIVkC6tMHRndjuk6HPxNmq2OPsuosgETicohfYeoNHQ/640?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本期封面报道从原理、开发、应用等多个角度出发，带你深入浅出探索区块链技术的方方面面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;区块链开发技术综述（孟岩，IBM大中华区高级经理）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最小可行性区块链原理解析（文 | Ilya Grigorik ，译 | 汪晓明）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何使用区块链技术进行项目开发（陈浩，维优区块链CTO）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写给CTO的主流区块链架构横向剖析（张铮文，分布科技CTO &amp;amp; Founder）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于区块链，程序员需要了解什么（曹严明，SAP咨询服务部架构师）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;区块链现有应用案例分析（刘秋杉，Gulu共享短途出行CEO）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;产品定位的“生死劫”——你的区块链产品能否活过今年（段新星，OKCoin（币行） - 副总裁兼首席研究员）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;区块链领域最具人气的平台以太坊（汪晓明，朝夕网络创始人，前Beltal CTO）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无链之链：R3 Corda带来的新视角（王玮，北京微志科技有限公司创始人）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;区块链在版权保护方面的探索与实践（朱志文，亿书（Ebookchain.org）创始人）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;区块链技术在零售供应链的商业化应用（张作义，任职于京东商城Y事业部）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;资讯&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;CSDN要闻&amp;nbsp;&lt;br/&gt;社会计算的数学基础&amp;nbsp;&lt;br/&gt;公共场馆的可交互木乃伊3D扫描图像&amp;nbsp;&lt;br/&gt;无需碰触：未来设备将使用MEMS超声波识别手势&amp;nbsp;&lt;br/&gt;前沿科技：晶体管技术将有重大革新&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;人工智能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;深度增强学习前沿算法思想（Flood Sung，CSDN博主，专注于深度学习，增强学习与机器人的研究）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;深度增强学习（Deep Reinforcement Learning，DRL）是近两年来深度学习领域迅猛发展起来的一个分支，目的是解决计算机从感知到决策控制的问题，从而实现通用人工智能。以Google DeepMind公司为首，基于深度增强学习的算法已经在视频、游戏、围棋、机器人等领域取得了突破性进展。2016年Google DeepMind推出的AlphaGo围棋系统，使用蒙特卡洛树搜索和深度学习结合的方式使计算机的围棋水平达到甚至超过了顶尖职业棋手的水平，引起了世界性的轰动。AlphaGo的核心就在于使用了深度增强学习算法，使得计算机能够通过自对弈的方式不断提升棋力。深度增强学习算法由于能够基于深度神经网络实现从感知到决策控制的端到端自学习，具有非常广阔的应用前景，它的发展也将进一步推动人工智能的革命。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无人驾驶系统安全（刘少山，李文超，唐洁）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;目前针对无人车攻击的方法有许多，如何防御这些攻击以保证无人车的安全是个重要的课题。本文是无人驾驶技术系列的第九篇，详细介绍针对无人车传感器、操作系统、控制系统、车联网的攻击手段以及防御方法。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NIPS 2016精选论文（2）（洪亮劼，Etsy数据科学主管，前雅虎研究院高级经理）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;人工智能和机器学习领域的学术论文汗牛充栋。每年的各大顶级会议、研讨班录用好几千篇论文，即便是亲临现场也很难追踪到所有的前沿信息。在时间精力有限的情况下，选择精读哪些论文，学习哪些热门技术就成为了AI学者和从业人员所头痛的问题。这个栏目旨在帮助大家筛选出有意思的论文，解读出论文的核心思想，为精读提供阅读指导。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;移动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;微信小程序的编程模式（范怀宇，轻芒联合创始人）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;“轻芒小程序+”是由轻芒团队提出的小程序解决方案，它将替内容创业者免费搭建属于自己的微信小程序。在进行“轻芒小程序+”和其他小程序应用开发的过程中，本文作者与其团队对当前正火热的小程序开发有了更为深度的理解与认识，进而有了本文。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;58同城iOS客户端网络框架的演进之路（郭方清，58同城iOS客户端资深研发工程师）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;伴随着业务场景需求的变化，58同城App在网络架构层面经历了从使用第三方开源网络框架到自主研发框架的不同阶段的不断改进。本文作者即从iOS开发角度具体分享了58同城移动客户端在网络框架层面的几次演变改进实践与经验总结。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用Server-Side Swift开发RESTful API（何轶琛，去哪儿网iOS开发工程师）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;Swift自发布以来就备受众多Apple开发者关注，但由于API尚不稳定，系统没有内置Framework导致App包增大等问题，使得线上主力使用的公司还很少，不少客户端开发者都还没有机会使用Swift进行开发。等到2015年12月Swift开源并正式支持Linux系统，广大Apple开发者迎来了更广泛的开发场景，可以用它来进行服务端开发。不到一年时间各种Server-Side Swift Web Framework相继问世，其中以Kitura、Perfect、Vapor、Zewo最为成熟。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Docker在美团点评的实践（郑坤，美团点评Docker平台项目负责人）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;本文介绍美团点评的Docker容器集群管理平台。该平台始于2015年，是基于美团云的基础架构和组件而开发的Docker容器集群管理平台。目前该平台为美团点评的外卖、酒店、到店、猫眼等十几个事业部提供容器计算服务，承载线上业务数百个，日均线上请求超过45亿次，业务类型涵盖Web、数据库、缓存、消息队列等。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Web端VR开发初探（张乾，上海渲图信息科技有限公司CEO）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;随着硬件和软件技术的发展，产业界对虚拟现实（Virtual Reality）用户体验产生了重大期望。技术的进步也使我们可能通过现代浏览器借助开放Web平台获得这种用户体验。这将帮助Web成为创建、分发以及帮助用户获得虚拟现实应用和服务生态系统的重要基础平台。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用SIMD技术提高C++程序的性能（下）（张银奎，《软件调试》和《格蠹汇编》作者）&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;p&gt;&lt;span&gt;上期文章中，我们介绍了SIMD的思想、历史以及在X86架构CPU的实现，本期将通过一个具体的图像处理实例来介绍如何把SIMD技术应用到C++项目里，介绍难易不同的多种方案。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;知识库&lt;/strong&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;区块链入门指南（卿苏德，博士，就职于中国信息通信研究院产业与规划所）&amp;nbsp;&lt;br/&gt;区块链2.0架构及其保险业应用初探（李赫，就职于中国人民保险集团总部，从事信息技术工作）&amp;nbsp;&lt;br/&gt;区块链知识库内容精选&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;订阅2016年程序员（含iOS、Android及印刷版）请访问&lt;/span&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); text-decoration: underline; max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;http://dingyue.programmer.com.cn&lt;/span&gt;&lt;/a&gt;&amp;nbsp;&lt;br/&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDial1EKAVBW5BkjiasgZt1D4Yys1f7BYch3dZCE7icianfZUS4CdwJFR0Whg/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;订阅咨询：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在线咨询（QQ）：2251809102&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;电话咨询：010-64351436&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更多消息，欢迎关注微博@&lt;/span&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); text-decoration: underline; max-width: 100%; font-size: 14px; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;程序员编辑部&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiae3AaBg0fCgHQLp8hcDQCdZiaM17KiankNF1DalwH4a3fs1R35FVV9kpQ/640?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;</description>
      <pubDate>Thu, 05 Jan 2017 17:09:10 +0800</pubDate>
    </item>
    <item>
      <title>网易分库分表数据库DDB</title>
      <link>http://www.iwgc.cn/link/4197458</link>
      <description>&lt;blockquote style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文为&lt;/strong&gt;&lt;strong&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;《程序员》&lt;/a&gt;原创文章，未经允许不得转载，更多精彩请&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;订阅2017年《程序员》&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互联网时代，也是关系型数据库独领风骚的时代，从早期的Oracle独步天下，到现在MySQL蒸蒸日上，关系型数据库是大多数互联网应用在数据可靠性存储上的“命脉”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着互联网产品在体量和规模上日益膨胀，无论是Oracle还是MySQL，都会第一时间面临来自磁盘、CPU和内存等单机瓶颈，为此，产品方除了需要不断购买成本难以控制的高规格服务器，还要面临不断迭代的在线数据迁移。在这种情况下，无论是海量的结构化数据还是快速成长的业务规模，都迫切需要一种水平扩展的方法将存储成本分摊到成本可控的商用服务器上。同时，也希望通过线性扩容降低全量数据迁移对线上服务带来的影响，分库分表方案便应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表的原理是将数据按照一定的分区规则Sharding到不同的关系型数据库中，应用再通过中间件的方式访问各个Shard中的数据。分库分表的中间件，隐藏了数据Sharding和路由访问的各项细节，使应用大多数场景下可以像使用单机数据库一样使用分库分表后的分布式数据库。业界中，网易DDB、阿里TDDL、Cobar、MyCat和HotDB等系统都是分库分表中间件中的佼佼者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景——十年一剑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB（全称Distributed Database）是网易杭研院立项最早、应用最为广泛的后台产品之一，也是国内最早出现的数据库分库分表中间件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最早可以追溯到2006年，网易杭研成立之初，为了应对网易博客这个日活超过800W的大体量应用，由现任杭研院院长的汪源带队主导开发了DDB这套分库分表数据库，伴随着博客的成长，DDB集群也从最早的20+节点，到40+节点，最后到现在云端100+个RDS实例。除了博客外，十年来DDB也见证了很多其他大体量应用，如易信、云音乐、云阅读、考拉等。在大家耳熟能详的网易互联网产品中，几乎都可以看到DDB的身影。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过10年的发展和演变，DDB的产品形态已全面趋于成熟，功能和性能得到了众多产品的充分验证，下面罗列一些大家比较关注的功能特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与SQL92标准的兼容度达90%以上&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持跨库JOIN和跨库事务，支持大部分标量函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持COUNT、SUM、AVG、MAX、CONCAT等常用聚合函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持与MySQL高度一致的用户管理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持读写分离和数据节点高可用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持数据节点在线扩缩容、在线更改表分布&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供完善的数据库管理工具、Web和命令行工具&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据节点支持Oracle和MySQL&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前DDB在网易内部有近50个产品使用，最大集群过百数据节点，大部分部署在云端，为应用提供透明、无侵入、MySQL标准协议的分库分表服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DDB演变之路&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十年来，DDB经历了三次服务模式的重大更迭，从最早的Driver模式，到后来的Proxy模式，再到近几年的云模式，DDB服务模式的成长也深刻反映着互联网流行架构的变迁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Driver模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Driver模式的特点在于应用通过DDB提供的JDBC Driver来访问DDB，类似于通过MySQL的JDBC驱动访问MySQL。而对于MySQL的驱动Connector/J，只需要实现将SQL按照特定协议编码和转码即可。而DDB的驱动为了实现透明的分库分表，需要做很多额外的工作，如图1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaUaFSSTawRvPxUPG1zMrXNwJAWPH0TibQaC8wkicBuib9Nct9fn4D44B1g/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB Driver执行一条SQL时，会经历以下几个步骤：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由语法解析器解析SQL，生成抽象语法树Parse Tree，并根据是否PreparedStatement决定是否进入PTC（Parse Tree Cache），PTC保存了SQL模式到语法树的映射，对PreparedStatement SQL，会优先进入PTC中查询语法树；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据语法树和启发式规则生成分布式执行计划，这个过程会涉及到多个步骤的SQL转换和优化，如条件合并，JOIN拆分，LIMIT转化等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由SQL执行器按照执行计划和语法树生成下发给每个数据节点的真实SQL，然后通过标准数据库驱动将SQL下发给各个数据节点，这个过程为并发执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将各个数据节点返回的结果按照执行计划进行合并，并返回上层。具体的合并操作可能在应用调用结果时动态执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBI模块作为DDB提供给应用的JDBC 驱动，包含了完整的透明分库分表逻辑，是DDB最为核心的组件，除此之外，DDB中还有用于元数据管理和同步的Master组件、数据库管理工具DBAdmin，和命令行工具ISQL，DDB的Driver模式整体架构如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaC25quzALRaeK3P0qVz76om44UBaYKiatajFBXzSKbnv0kZTpOgXPV2Q/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;管理操作以建表为例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBA通过DBAdmin的窗口创建表，或者用ISQL执行建表语句后，向Master发起实际建表请求，Master完成用户认证和合法性校验后，先在各个数据节点上创建新表，然后将新表元数据记录在系统库中，最后由Master将新表元数据同步给各个DBI模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于建表语句中DDB特有的语法，会由ISQL或DBAdmin在解析DDL时完成相应处理，如自增ID的设置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在DDB中，Master用于元数据管理、同步和报警监控。DBI模块启动时，会第一时间向Master注册，并拉取元数据，之后Master对元数据的同步保障了DBI模块元数据的更新。在DBI执行SQL，以及创建DB连接的过程中，不会涉及到与Master的交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在分库分表中间件中，与DDB Driver模式同样类型的还有阿里TDDL，优势是部署简单、成本较低、容易理解和上手。劣势也非常明显：只支持Java客户端、版本难以管理、问题难以追踪、DB连接难以归敛等，另外一点是，中间件与应用绑定在一起，对应用本身是个巨大侵入，而且分库分表的过程比较耗费CPU资源，所以在Driver模式下，无论是运维还是性能开销上都存在不可控的因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Proxy模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比于Driver模式在多语言，版本管理，运维风险上存在的问题，Proxy模式很好地弥补了这些缺陷。所谓Proxy，就是在DDB中搭建了一组代理服务器来提供标准的MySQL服务，在代理服务器内部实现分库分表的逻辑。本质上说，DDB Proxy作为一组独立服务，实现了MySQL标准通信协议，任何语言的MySQL驱动都可以访问，而在Proxy内部，依赖DBI组件实现分库分表，Proxy与DBI的关系如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaibo7holnugJ7RMeI3M3v6ickgN4Sbaiay7A4amJKcGnMMQuiaJq24W39Uw/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用通过标准数据库驱动访问DDB Proxy，Proxy内部通过MySQL解码器将请求还原为SQL，并由DDB Driver，也就是DBI模块执行得到结果，最后通过MySQL编码器返回给应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图3可以看出，Proxy在DBI上架设了MySQL编解码模块，从而形成独立标准的MySQL服务，而在MySQL编解码模块之上，DDB Proxy也提供了很多特色命令支持，例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;show processlist：查看Proxy所有连接状态，与MySQL相关命令高度一致&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;show connection_pool：查询Proxy到数据节点的连接池状态&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;showtopsql：查询按照SQL模式聚合的各项统计结果，如执行次数，平均执行时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;count..from：查询过去各个时间段内的吞吐量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，DDB Proxy内还提供了Slow Log等辅助功能，给运维带来很大的便利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB Proxy模式完整架构如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaLib0TznMs23OOaLjcyu9Yq4ap7zLovicFuwrR6QI1RWu3yZvjUZTZJxA/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与Driver模式架构相比，除了QS（DDBProxy的内部称谓，下同）取代了DBI的位置，还在多个QS节点之上部署了LVS或HAProxy + Keepalived的组合做负载均衡，从而实现多个DDBProxy节点的热备，由于DDBProxy无状态，或者说状态统一由Master同步，在数据库节点没有达到瓶颈时，可以通过简单地增设QS服务器实现服务线性扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;私有云模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在网易私有云项目启动之前，DDB一直以一个个独立集群为不同业务提供服务，不同DDB各自为政毫不相干，这样的好处是业务之间完全隔离，互不影响。不好之处在于随着使用DDB的产品数目不断增多，一个DBA往往同时运维数个甚至数十个DDB集群，而之前我们一直缺乏一个平台化的管理系统，DBA在各个集群之间应接不暇时，我们没有平台化的统筹运维帮助应用及早发现问题，或是优化一些使用方法。例如版本管理，2013年我们在一个大版本中做了个Hotfix，并通知所有DBA将相关版本进行升级，但是最后由于管理疏漏，有个别集群没有及时上线，为业务带来了损失。当时如果我们有平台化的管理方案，可以提供一些运维手段帮助和提醒运维人员及时更新所有有问题集群，另外，平台化的管理工具也可以定制一些自动化功能，如自动备份、报警组等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易私有云的出现为DDB的思变提供了契机，从2012年开始，我们就在基于网易私有云开发一套平台化的管理工具Cloudadmin，为此，我们将DDB中原先Master的功能打散，一部分分库相关功能集成到Proxy中，如分库管理、表管理、用户管理等，一部分中心化功能集成到Cloudadmin中，如报警监控，此外，Cloudadmin中提供了一键部署、自动和手动备份、版本管理等平台化功能。私有云DDB的整体架构如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaaRnvduHafdfNv8hQwiaynHuBRE53BRRM9eIr2XpsjwXh2FggEjxlIEw/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在云DDB解决方案中，还打包了网易私有云LVS服务，Cloudadmin通过DDBAgent实现一键部署和报警监控。到目前为止，网易80%以上的DDB集群都已部署云端，云DDB的出现极大减轻了运维人员的负担。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DDB特性介绍&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式执行计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式执行计划定义了SQL在分库分表环境中各个数据库节点上执行的方法、顺序和合并规则，是DDB实现中最为复杂的一环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如SQL：&lt;/span&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;select * from user order by id limit 10 offset 10;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个SQL要查询ID排名在10—20之间的user信息，这里涉及到两个合并操作：全局ID排序和全局LIMIT OFFSET。对全局ID排序，DDB的做法是将ID排序下发给各个数据库节点，在DBI层再进行一层归并排序，这样可以充分利用数据库节点的计算资源，同时将中间件层的排序复杂度降到最低，例如一些需要用到临时文件的排序场景，如果在中间件做全排序会导致极大开销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对全局LIMIT OFFSET，DDB的做法是将OFFSET累加到LIMIT中下发，因为单个数据节点中的OFFSET没有意义，且会造成错误的数据偏移，只有在中间件层的全局OFFSET才能保证OFFSET的准确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最后下发给各个DBN的SQL变为：select * from user order by id limit 20。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;又如SQL：&lt;/span&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;select avg(age) from UserTet group by name&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过EXPLAIN语法得到SQL的执行计划，如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaVvtSGYykFmnwbicOXAvDIuicPVyRfmTV82f7w3LPsjrlDdBfwEOCrHRg/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述SQL包含GROUP BY分组和AVG聚合两种合并操作，与全局ORDER BY类似，GROUP BY也可以下发给数据节点、中间件层做一个归并去重，但是前提要将GROUP BY的字段同时作为ORDER BY字段下发，因为归并的前提是排序。对AVG聚合，不能直接下发，因为得到所有数据节点各自的平均值，不能求出全局平均值，需要在DBI层把AVG转化为SUM和COUNT再下发，在结果集合并时再求平均。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB执行计划的代价取决于DBI中的排序、过滤和连接，在大部分场景下，排序可以将ORDER BY下发简化为一次性归并排序，这种情况下代价较小，但是对GROUP BY和ORDER BY同时存在的场景，需要优先下发GROUP BY字段的排序，以达到归并分组的目的，这种情况下，就需要将所有元素做一次全排序，除非GROUP BY和ORDER BY字段相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB的连接运算有两种实现，第一种是将连接直接下发，若连接的两张表数据分布完全相同，并且在分区字段上连接，则满足连接直接下发的条件，因为在不同数据节点的分区字段必然没有相同值，不会出现跨库连接的问题。若不满足连接下发条件，会在DBI内部执行Nest Loop算法，驱动表的顺序与FROM表排列次序一致，此时若出现ORDER BY表次序与表排列次序不一致，则不满足ORDER BY下发条件，也需要在DBI内做一次全排序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表的执行计划代价相比单机数据库而言，更加难以掌控，即便是相同的SQL模式，在不同的数据分布和分区字段使用方式上，也存在很大的性能差距，DDB的使用要求开发者和DBA对执行计划的原理具有一定认识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如分库分表在分区字段的使用上很有讲究：一般建议应用中80%以上的SQL查询通过分区字段过滤，使SQL可以单库执行。对于那些没有走分区字段的查询，需要在所有数据节点中并行下发，这对线程和CPU资源是一种极大的消耗，伴随着数据节点的扩展，这种消耗会越来越剧烈。另外，基于分区字段跨库不重合的原理，在分区字段上的分组、聚合、DISTINCT、连接等操作，都可以直接下发，这样对中间件的代价往往最小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式事务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式事务是个历久弥新的话题，分库分表、分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，如此像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，适用于中间件这种数据节点无耦合的场景。2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。与很多其他一致性协议相同，2PC保障的是最终一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2PC整个过程如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaVhCVUnXx6c5ESlsxo8BjFqbZgoh3681nnhiaAM8niczK6Qnibibx3EibNlQ/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在DDB中，DBI和Proxy组件都作为Coordinator存在，2PC实现时，记录Prepare和PrepareAll的日志必须sync，以保障重启后恢复状态正确，而Coordinator最后的Commit日志主要作用是回收之前日志，可异步执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于2PC要求Coordinator记日志，事务吞吐率受到磁盘I/O性能的约束，为此DDB实现了GROUP I/O优化，可极大程度提升2P C的吞吐率。2PC本质上说是一种阻塞式协议，两阶段提交过程需要大量线程资源，因此CPU和磁盘都有额外消耗，与单机事务相比，2PC在响应时间和吞吐率上相差很多，从CAP角度出发，可以认为2PC在一定程度上成全了C，牺牲了A。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，目前MySQL最流行的5.5和5.6版本中，XA事务日志无法Replicate到从节点，这意味着主库一旦宕机，切换到从库后，XA的状态会丢失，可能造成数据不一致，这方面MySQL 5.7已经有所改善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然2PC有诸多不足，我们依然认为在DDB中有实现价值，DDB作为中间件，其迭代周期要比数据库这种底层服务频繁很多，若没有2PC，一次更新或重启就可能造成应用数据不一致。从应用角度看，分布式事务的现实场景常常无法规避，在有能力给出其他解决方案前，2PC也是一个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力，可以结合SOA框架来架构。原理上说，这两种方案都是大事务拆小事务，小事务变本地事务，最后通过幂等的Retry来保障最终一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;弹性扩缩容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表数据库中，在线数据迁移也是核心需求，会用在以下两种场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据节点弹性扩容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着应用规模不断增长，DDB现有的分库可能有一天不足以支撑更多数据，要求DDB的数据节点具有在线弹性扩容的能力，而新节点加入集群后，按照不同的Sharding策略，可能需要将原有一些数据迁入新节点，如HASH分区，也有可能不需要在线数据迁移，如一些场景下的Range分区。无论如何，具备在线数据迁移是DDB支持弹性扩容的前提。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据重分布&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发者在使用DDB过程中，有时会陷入困局，比如一些表的分区字段一开始没考虑清楚，在业务已经初具规模后才明确应该选择其它字段。又如一些表一开始认为数据量很小，单节点分布足以，而随着业务变化，需要转变为多节点Sharding。这两种场景都体现了开发者对DDB在线数据迁移功能的潜在需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是弹性扩容，还是表重分布，都可当做DDB以表或库为单位的一次完整在线数据迁移。可分为两个阶段：全量迁移和增量迁移：全量迁移是将原库或原表中需要迁移的数据DUMP出来，并使用工具按照分区策略Apply到新库新表中。增量迁移是要将全量迁移过程中产生的增量数据更新按照分区策略Apply到新库新表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全量迁移的方案相对简单，使用DDB自带工具按照特定分区策略DUMP和Load即可。对增量迁移，DDB实现了一套独立的迁移工具Hamal来订阅各个数据节点的增量更新，Hamal内部又依赖DBI模块将增量更新Apply到新库新表，如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDia4zFb3len9NlCQ6oEkKBuCZgLxgK0vtzgckzvQgibgfvw8KBlvHIq5gg/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hamal作为独立服务，与Proxy一样由DDB统一配置和管理，每个Hamal进程负责一个数据节点的增量迁移，启动时模拟Slave向原库拉取Binlog存储本地，之后实时通过DBI模块Apply到新库新表，除了基本的迁移功能外，Hamal具备以下两个特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;并行复制：Hamal的并行复制组件，通过在增量事件之间建立有向无环图，实时判断哪些事件可以并行执行，Hamal的并行复制与MySQL的并行复制相比快10倍以上；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;断点续传：Hamal的增量Apply具有幂等性，在网络中断或进程重启之后可以断点续传。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;全局表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑一种场景：City表记录了国内所有城市信息，应用中有很多业务表需要与City做联表查询，如按照城市分组统计一些业务信息。假设City的主键和分区键都是CityId，若连接操作发生在中间件层，代价较高，为了将连接操作下发数据节点，需要让联接的业务表同样按照CityId分区，而大多数业务表往往不能满足这个条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;联接直接下发需要满足两个条件，数据分布相同和分区键上联接，除此之外，其实还有一种解法，可以把City表冗余到所有数据节点中，这样各个数据节点本地联接的集合便是所求结果。DDB将这种类型的表称之为全局表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全局表的特点是更新极少，通过2PC保障各个节点冗余表的一致性。可以通过在建表语句添加相关 Hint指定全局表类型，在应用使用DDB过程中，全局表的概念对应用不可见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;未来——独立平台，与云共舞&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB作为网易浓缩了10年技术经验与精华的分库分表数据库，近一两年除了满足内部产品使用外，也渐渐开始帮助外部企业客户解决海量结构化数据存储的难题。随着公有云技术的大力发展和日趋成熟，各种IaaS和PaaS平台如雨后春笋层出不穷，如网易蜂巢的推出，为应用开发、部署和运维提供了极大便利。而随着IaaS层和PaaS平台的普及，各种SaaS服务也会慢慢为广大开发者所接纳，未来DDB也将重点为网易蜂巢客户打包DDB的SaaS服务，与蜂巢一同构建一套更加丰富的数据存储生态系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对DDB的SaaS服务化无比坚定，同时DDB的公有云之路绝非私有云的生搬硬套，在与蜂巢一同帮助企业客户解决分库分表难题的同时，未来我们也会更加注重平台独立，首先要做的是将DDB的SaaS层与底层PaaS和IaaS层解耦，实现将DDB平台所依赖的PaaS和IaaS以插件方式注入。这样既可以为客户提供更灵活的服务方式，也可以极大程度降低DDB平台本身的开发和运维成本：一套平台管理工具，适用所有内外部DDB用户，这是我们正在进行并将持续优化的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;作者：马进，DDB项目负责人，2013年加入网易，热衷于分布式中间件相关方面工作，从事过分库分表数据库DDB、缓存NKV、分布式事务中间件TCC、分布式视频处理系统NTS等项目。&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Wed, 04 Jan 2017 17:31:34 +0800</pubDate>
    </item>
    <item>
      <title>深度 | 对比深度学习十大框架：TensorFlow最流行但并不是最好</title>
      <link>http://www.iwgc.cn/link/4197459</link>
      <description>&lt;p&gt;&lt;span&gt;2016 年已经过去，BEEVA Labs 数据分析师 Ricardo Guerrero Gomez-Ol 近日在 Medium 上发表了一篇文章，盘点了目前最流行的深度学习框架。为什么要做这一个盘点呢？他写道：「我常听到人们谈论深度学习——我该从哪里开始呢？TensorFlow 是现在最流行的吧？我听说 Caffe 很常用，但会不会太难了？在 BEEVA Labs，我们常常需要应对许多不同的深度学习库，所以我希望能够将我们的发现和感想分享出来，帮助那些刚刚进入深度学习这一美丽世界的人。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;TensorFlow&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://www.tensorflow.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于那些听说过深度学习但还没有太过专门深入的人来说，TensorFlow 是他们最喜欢的深度学习框架，但在这里我要澄清一些事实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 TensorFlow 的官网上，它被定义为「一个用于机器智能的开源软件库」，但我觉得应该这么定义：TensorFlow 是一个使用数据流图（data flow graphs）进行数值计算的开源软件库。在这里，他们没有将 TensorFlow 包含在「深度学习框架」范围内，而是和 Theano 一起被包含在「图编译器（graph compilers）」类别中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在结束了Udacity 的Deep Learning课程之后，我的感觉是 TensorFlow 是一个非常好的框架，但是却非常低层。使用 TensorFlow 需要编写大量的代码，你必须一遍又一遍地重新发明轮子。而且我并不是唯一一个这么想的人。Andrej Karpathy 在 Twitter 上就多次吐过槽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;推文：我希望 TensorFlow 能标准化我们的代码，但它是低层面的，所以我们在其上面的层上分道扬镳了：Slim、PrettyTensor、Keras、TFLearn …&lt;/span&gt;&lt;span&gt;比如：我们在 OpenAI 使用 TensorFlow，但我们似乎都更喜欢其它框架，我们有些人还写自定义代码。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;几个月前，我去参加了「Google Experts Summit: TensorFlow, Machine Learning for everyone, with Sergio Guadarrama」。Sergio 是开发TensorFlow 的一位工程师，但他在会上没有展示 TensorFlow，而是展示了一个在TensorFlow上工作的更高层的库 tf.contrib：https://www.tensorflow.org/tutorials/tflearn/。我的看法是：他们内部已经意识到如果要让更多人使用 TensorFlow，他们就需要以更高的抽象水平在其上创建一些层，从而简化 TensorFlow 的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TensorFlow 支持 Python 和 C++，也允许在 CPU 和 GPU 上的计算分布，甚至支持使用 gRPC 进行水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：TensorFlow 非常好，但你必须了解它好在哪里。如果你不想什么事都自己手动去做和重新发明轮子，你可以使用更简单的库（安利一下 Keras）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Theano&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://deeplearning.net/software/theano/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Theano 是最老牌和最稳定的库之一。据我所知，深度学习库的开端不是 Caffe 就是 Theano。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和 TensorFlow 类似，Theano 是一个比较低层的库。也因此它并不适合深度学习，而更适合数值计算优化。它支持自动的函数梯度计算，带有 Python 接口并集成了 Numpy，这使得它从一开始就成为了通用深度学习领域最常使用的库之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天，Theano 依然效果良好，但由于它不支持多 GPU 和水平扩展，在 TensorFlow 的热潮下（它们针对同一个领域），Theano 已然开始被遗忘了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Keras&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://keras.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「You have just found Keras.」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这句话是你打开文档页面时看到的第一句话。我还记得我第一次发现 Keras 的时候。那时候我正在柏林解决 Data Science Retreat 的最后一个项目，为此我努力进入了深度学习库的世界。我在起步时就已经有了足够的深度学习知识，但我没有时间自己手动编写功能，也没有时间探索和学习一个新的库（截止时间不到 2 个月，而我还有课要上）。然后我发现了 Keras。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我真的很喜欢 Keras，因为它的句法是相当明晰的，它的文档也非常好（尽管相对较新），而且它支持我已经掌握的语言 Python。它的使用非常简单轻松；我们也能很直观地了解它的指令、函数和每个模块之间的链接方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Keras 是一个非常高层的库，可以工作在 Theano 和 TensorFlow（可以配置）之上。另外，Keras 强调极简主义——你只需几行代码就能构建一个神经网络。在这里你可以比较一下 Keras 和 TensorFlow 实现相同功能时所需的代码：https://gist.github.com/ricgu8086/0ba44ce3aab19ec50425383a4d778b50&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Lasagne&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://lasagne.readthedocs.io/en/latest/index.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lasagne 是一个工作在 Theano 之上的库。它的使命是简化一点深度学习算法之下的复杂计算，同时也提供了一个更加友好的接口（也是 Python 的）。这是一个老牌的库，并且很长时间以来它都是一个扩展能力很强的工具；但在我看来，它的发展速度赶不上 Keras。它们的适用领域都差不多，但 Keras 有更好的文档、也更完整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Caffe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://caffe.berkeleyvision.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Caffe 不只是最老牌的框架之一，而是老牌中的老牌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我看来，Caffe 有非常好的特性，但也有一些小缺点。起初的时候它并不是一个通用框架，而仅仅关注计算机视觉，但它具有非常好的通用性。在我们实验室的实验中，CaffeNet 架构的训练时间在 Caffe 中比在 Keras 中（使用了 Theano 后端）少 5 倍。Caffe 的缺点是它不够灵活。如果你想给它来一点新改变，那你就需要使用 C++ 和 CUDA 编程，不过你也可以使用 Python 或 Matlab 接口进行一些小改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Caffe 的文档非常贫乏。你需要花大量时间检查代码才能理解它（Xavier 初始化有什么用？Glorot 是什么？）。Caffe 的最大缺点之一是它的安装。它需要解决大量的依赖包……我曾经安装过 Caffe 两次，真正痛苦至极。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但要清楚，Caffe 并不是一无是处。在投入了生产的计算机视觉系统的工具上，Caffe 是无可争议的领导者。它非常稳健非常快速。我的建议是：用 Keras 进行实验和测试，然后迁移到 Caffe 中进行生产。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DSSTNE&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://github.com/amznlabs/amazon-dsstne&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DSSTNE 的发音同 Destiny，是一个酷劲十足的框架却总是被忽略。为什么？除去其他的因素不谈，原因在于这个框架不具有普适性，不是为一般常见任务所设计的。DSSTNE 框架只做一件事——推荐系统，但把这件事做到了极致。既不是为研究而设计，也不是为测试 idea 而设计（来源其官方网站的宣传语），DSSTNE 框架是为量产而设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已在 BEEVA 上做一些实验测试了，目前我已经感觉到这是一个运行非常快的工具并且能够得到非常好的运行结果（平均准确率均值——mAP 很高）。为了达到这一速度，DSSTNE 框架用 GPU 运行，这也是它的弊端之一：不同于篇中分析的其他框架或者库，这个框架不支持使用者随意在 CPU 和 GPU 中切换，而这可能会对有些尝试有用，但我们在 DSSTNE 里做这样的尝试时是不被框架所允许的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其他的感受就是迄今为止 DSSTNE 还不是一个足够成熟的项目，而且它封装的太严密了（「black box」）。如果我们想深入了解这个框架的运行机制是什么，我们必须且只能去看它的源码，并且你需要完成很多必须完成的设置（「TODO」）才可以看到。同时，关于这个框架的在线教程不多，而能让开发者进行操作尝试的指导就更少了。我的意见是再等 4 个月看看 DSSTNE 的最新版本。不能不说 DSSTEN 的确是一个很有意思的项目但还需要一点成长空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还想说明一点，这个框架对编程能力没有要求。DSSTNE 框架通过其终端的命令行来执行相关操作。到目前为止，很多我知道也很流行的框架和库我还没有用过，我不能给出更多具体的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Torch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://torch.ch/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个世界上每天仍有很多战争，但是一个优秀的「勇士」（西班牙语「Guerrero」）必须熟知哪些战争是需要去参加作战的，哪些是可以选择不参与的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Torch 是一个很著名的框架，因巨头 Facebook 的人工智能研究所用的框架是 Torch，并且在被谷歌收购之前 DeepMind 也是用的 Torch（收购之后 DeepMind 转向了 TensorFlow）。Torch 的编程语言是 Lua，这就是我刚才所谈的「战争」的具体所指。在目前深度学习编程语言绝大部分以 Python 实现为主的大趋势下，一个以 Lua 为编程语言的框架的最大劣势莫过于此。我从未用使用过这个语言，如果我想使用 Torch 这个工具，毫无疑问我需要先学习 Lua 语言然后才能使用 Torch。这固然是一个合理的过程，但就我个人情况来说，我偏向于用 Python、Matlab 或者 C++的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MXNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://github.com/dmlc/mxnet&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mxnet 是一个支持大多数编程语言的框架之一，包括 Python，R，C++，Julia 等。但我觉得使用 R 语言的开发者会特别偏爱 mxnet，因为至今为止还是 Python 以不可置疑的态势称霸深度学习语言的（Python 与 R 的对决，猜猜我会站哪边？:-p）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老实说，在此之前我并没有很关注 mxnet。但是当亚马逊 AWS 宣布选择 mxnet 作为其深度学习 AMI 的库时触发我开始关注 mxnet。我必须去了解一下。后来我获知亚马逊把 mxnet 列为其深度学习的参考库并宣称其巨大的横向扩展能力。我感觉到这里面有一些新的改变发生而且我必须深入了解。这也是为什么我们 2017 的 BEEVA 的技术测试名单里有 mnxet 的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我对多 GPU 的扩展能力有点疑虑并且我很原意去了解这样实验的更多细节，但目前我还是对 mxnet 持怀疑态度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DL4J&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://deeplearning4j.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我接触这一库，是因为它的 documentation。当时我正在寻找受限玻尔兹曼机、自编码器，在 DL4J 中找到了这两个 documentation。里面的文件很清楚，有理论，有代码案例。我必须得说 DL4J 的 documentation 简直是艺术品，其他库在记录代码的时候需要向它学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DL4J 背后的公司 Skymind 意识到，虽然在深度学习圈内 Python 是老大，但大部分程序员起自 Java，所以需要找到一个解决方案。DL4J 兼容 JVM，也适用 Java、Clojure 和 Scala，随着 Scala 的起起落落，它也被很多有潜力的创业公司使用，所以我还会继续紧追这个库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，Skymind 的 twitter 账户非常活跃，不断公开最新的科学论文、案例和教程，及其推荐大家关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cognitive Toolkit&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://github.com/Microsoft/CNTK&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;认知工具包（Cognitive Toolkit）之前被大家所知的缩略是 CNTK，但是最近又重命名回归到 Cognitive Toolkit，很可能是想沾最近微软认知服务（Microsoft Cognitive services）的光。在公开的基准测试上的表现来看，这个工具似乎很强劲，支持纵向和横向的推移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前为止，Cognitive Toolkit 似乎不是很流行。我并没有读到很多关于使用这个库的博客、在线实验案例或者在 Kaggle 里的相关评论。但是对我来说，一个背靠微软研究的框架特别强调自己的推移能力让我觉得有些奇怪，毕竟微软研究团队可是在语音识别上打破世界纪录并逼近人类水准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在查看他们项目百科的一个范例的时候了解到 Cognitive Toolkit 在 Python 上的语法和 Keras 是非常相类似的（Cognitive Toolkit 也支持 C++），这不禁让我在想（并不是确认）Keras 才是正确的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的结论是：如果你想进入这一领域，你应该首先学习 Python。尽管这一领域还支持其它很多语言，但 Python 是应用范围最广而且最简单的一个。但是为什么要选择 Python 呢——毕竟 Python 速度这么慢？因为大多数的库都使用的是符号式语言（symbolic language）方法而非命令式语言（imperative language）方法。解释一下也就是说：不是一条接一条地执行你的指令，而是根据你给出的所有指令创建一个计算图（computing graph）。这个图被内部优化和编译成可执行的 C++ 代码。这样你就能同时利用上两个世界的最优之处：Python 带来的开发速度和 C++ 带来的执行速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人们对深度学习的兴趣越来越大了，但人们并不愿意等待算法训练所需的大量计算时间（而且我说的是 GPU，想都不要想只使用 CPU）。这也是多 GPU 支持、多机器上的水平扩展甚至定制硬件最近开始得势的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度学习领域非常活跃、易变。很可能我现在所说的在 2017 年的中旬就变了。我的建议是，如果你是初学者，使用 Keras，如果不是初学者，也可以使用它。如果你参加过 Kaggle 比赛，你肯定注意到了 Kaggle 的两大巨星：Keras 和 XGBoost。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;原文链接：&amp;nbsp;&lt;/span&gt;&lt;span&gt;https://medium.com/@ricardo.guerrero/deep-learning-frameworks-a-review-before-finishing-2016-5b3ab4010b06#.z8zuthuwm&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Wed, 04 Jan 2017 17:31:34 +0800</pubDate>
    </item>
    <item>
      <title>一图读懂JVM架构解析</title>
      <link>http://www.iwgc.cn/link/4197460</link>
      <description>&lt;p&gt;&lt;span&gt;本文阐述了JVM的构成和组件，配图清晰易懂，是学习Java开发者的入门必读文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个Java开发人员都知道字节码经由JRE（Java运行时环境）执行。但他们或许不知道JRE其实是由Java虚拟机（JVM）实现，JVM分析字节码，解释并执行它。作为开发人员，了解JVM的架构是非常重要的，因为它使我们能够编写出更高效的代码。本文中，我们将深入了解Java中的JVM架构和JVM的各个组件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚拟机是物理机的软件实现。Java的设计理念是WORA（Write Once Run Anywhere，一次编写随处运行）。编译器将Java文件编译为Java .class文件，然后将.class文件输入到JVM中，JVM执行类文件的加载和执行的操作。请看以下的JVM架构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuialqalWoEk23CVV2t67okjt749UJZzK0kibfxNUCfkqsR87EgCvARcKpfI3ZAzFgNtU0a8IkwdB4FA/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JVM是如何工作的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上面架构图所示，JVM分为三个主要子系统：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;类加载器子系统（Class Loader Subsystem）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运行时数据区（Runtime Data Area）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行引擎（Execution Engine）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 类加载器子系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java的动态类加载功能由类加载器子系统处理，处理过程包括加载和链接，并在类文件运行时，首次引用类时就开始实例化类文件，而不是在编译时进行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Boot Strap类加载器，Extension类加载器和Application（类加载器是实现类加载过程的三个类加载器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1) Boot Strap类加载器：负责从引导类路径加载类，除了rt.jar，它具有最高优先级；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) Extension 类加载器：负责加载ext文件夹（jre \ lib）中的类；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3) Application类加载器：负责加载应用程序级类路径，环境变量中指定的路径等信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的类装载器在加载类文件时遵循委托层次算法（Delegation Hierarchy Algorithm）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1) 验证（Verify）：字节码验证器将验证生成的字节码是否正确，如果验证失败，将提示验证错误；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) 准备（Prepare）：对于所有静态变量，内存将会以默认值进行分配；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3) 解释（Resolve）：有符号存储器引用都将替换为来自方法区（Method Area）的原始引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3 初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是类加载的最后阶段，所有的静态变量都将被赋予原始值，并且静态区块将被执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 运行时数据区&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行时数据区可分为5个主要组件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1) 方法区（Method Area）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所有的类级数据将存储在这里，包括静态变量。每个JVM只有一个方法区，它是一个共享资源；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2) 堆区域（Heap Area）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所有对象及其对应的实例变量和数组将存储在这里。每个JVM也只有一个堆区域。由于方法和堆区域共享多个线程的内存，所存储的数据不是线程安全的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3) 堆栈区（Stack Area）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于每个线程，将创建单独的运行时堆栈。对于每个方法调用，将在堆栈存储器中产生一个条目，称为堆栈帧。所有局部变量将在堆栈内存中创建。堆栈区域是线程安全的，因为它不共享资源。堆栈框架分为三个子元素：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;局部变量数组（Local Variable Array）：与方法相关，涉及局部变量，并在此存储相应的值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作数堆栈（Operand stack）：如果需要执行任何中间操作，操作数堆栈将充当运行时工作空间来执行操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;帧数据（Frame Data）：对应于方法的所有符号存储在此处。在任何异常的情况下，捕获的区块信息将被保持在帧数据中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(4) PC寄存器（PC Registers）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每个线程都有单独的PC寄存器，用于保存当前执行指令的地址。一旦执行指令，PC寄存器将被下一条指令更新；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(5) 本地方法堆栈（Native Method stacks）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;本地方法堆栈保存本地方法信息。对于每个线程，将创建一个单独的本地方法堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.执行引擎&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分配给运行时数据区的字节码将由执行引擎执行，执行引擎读取字节码并逐个执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1) 解释器：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;解释器更快地解释字节码，但执行缓慢。解释器的缺点是当一个方法被调用多次时，每次都需要一个新的解释；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2) JIT编译器：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;JIT编译器消除了解释器的缺点。执行引擎将在转换字节码时使用解释器的帮助，但是当它发现重复的代码时，将使用JIT编译器，它编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，这提高了系统的性能。JIT的构成组件为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中间代码生成器（Intermediate Code Generator）：生成中间代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码优化器（Code Optimizer）：负责优化上面生成的中间代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目标代码生成器（Target Code Generator）：负责生成机器代码或本地代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析器（Profiler）：一个特殊组件，负责查找热点，即该方法是否被多次调用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3) 垃圾收集器(Garbage Collector)：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;收集和删除未引用的对象。可以通过调用“System.gc（）”触发垃圾收集，但不能保证执行。JVM的垃圾回收对象是已创建的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java本机接口（JNI）：JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地方法库（Native Method Libraries）：它是执行引擎所需的本机库的集合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原文：The JVM Architecture Explained&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：Jackson Joseraj 翻译：Daisy 责编：仲培艺&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 04 Jan 2017 17:31:34 +0800</pubDate>
    </item>
    <item>
      <title>携程移动端性能优化</title>
      <link>http://www.iwgc.cn/link/4181253</link>
      <description>&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文为《程序员》原创文章，未经允许不得转载，更多精彩请订阅2017年《程序员》&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在《程序员》杂志 10 月刊作者发布了文章《携程移动端架构演进与优化之路》文章第一部分：架构演进，11 月份作者在 CSDN 上发布了《携程移动端 UI 界面性能优化实践》。此文章是在这两篇文章基础上进行总结的关于携程移动端性能优化的其他内容，包括 Hybrid 框架优化、网络优化、通信数据格式传输优化、内存优化、启动时间优化、React Native 优化等内容，接下来作者将从这几个角度进行详细展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Hybrid 框架优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 的 Hybrid 框架经过多个版本的迭代，支持强大的插件功能，已经做到凡是可用，通通使用 Native 组件来优化 Hybrid 业务的体验。携程 Hybrid 框架在设计之初即采用了离线包功能：Hybrid 业务整体打包在 App 中，节省了用户打开页面时的资源加载时间；同时离线包支持差分增量更新，并通过 7z 压缩方式进一步降低了增量更新包的大小，相对 Zip 压缩减少 30%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤离线组件包&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统 HTML5 页面的静态资源常常需要从远程服务器下载，造成移动环境下最昂贵的网络开销。不同于 HTML5，组件化 Hybrid 方案引入了组件包的概念，将业务需要的所有静态资源打包成一个组件包文件，并进行离线化版本管理，而且关于离线包的更新是采取增量差分升级更新的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在用户访问组件页面之前，组件框架通常默默地将最新业务组件包下载至客户端，用户访问组件页面时，WebView 加载的实际上均是本地页面和资源，大幅提升了页面加载性能。不仅如此，关键业务组件在携程客户端版本发布时会预置到 App 中，减少首次下载安装的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤WebView 预加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影响页面加载速度的因素非常多，我们在对 WebView 加载一个网页的过程进行调试发现，每次加载的过程中都会有较多的网络请求。除了 Web 页面自身的 URL 请求，还会有 Web 页面外部引用的 JS、CSS、字体、图片等都是个独立的 HTTP 请求。这些请求都是串行的，加上浏览器的解析、渲染时间就会导致 WebView 整体加载时间变长，消耗的流量也对应地增多。所以为了加快 WebView 的整体加载时间，我们使用了预加载策略，将 JS、CSS、字体、图片等资源提前加载出来。Android 通过 WebView 自带的 API 即 setWebViewClient 中的回调接口 ShouldInterceptRequest 去实现资源的预加载。类似事例代码如图 1 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaicr9LicU7hEyiaDTLU5fjiaEy0lu9gqBplmv2kJfZiaDgfSjaFozNibTHYfw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 1 WebView 预加载资源&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;iOS 通过 setNeedsLayout 机制提前初始化下一个 UIwebView，将 HTML 文件初始化，然后捕获点击事件去动态刷新数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 网络请求是基于 TCP 和 HTTP 的混合请求，比如 Hybrid 页面就是通过直接发送 HTTP 请求。由于携程用户环境的复杂情况下 Hybrid 页面 HTTP 失败率在 3%左右，对于携程来说 4 个 9 的高可行性架构要求显然是不符合的，同时在 HTML5 页面使用 HTTP 服务容易发生 DNS 劫持现象。基于这些原因，提高服务的成功率是当时必须要推进而且是重中之重要推进的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们 Hybrid 网络性能优化通过 Hybrid 接口发送 Native 网络服务的方案替代 HTTP，其一是因为 Native 端的 TCP 长连接可以提高服务成功率，其二从安全角度可以避免 DNS 劫持。此外，针对携程海外用户的特点，我们也进行了海外网络性能优化，主要是通过 TCP 海外加速产品实现链路优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于携程 App 大部分网络服务主要基于 TCP 连接，为了将 DNS 时间降至最低，我们采取了动态 IP 优化策略算法，即内置了 Server IP 列表，该列表可以在 App 启动服务中下发更新。App 启动后的首次网络服务会从 Server IP 列表中取一个 IP 地址进行 TCP 连接，同时 DNS 解析会并行进行，DNS 成功后，会返回最适合用户网络的 Server IP，那么这个 Server IP 会被加入到 Server IP 列表中被优先使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，Server IP 列表是有权重机制的，DNS 解析返回的 IP 很明显具有最高的权重，每次从 Server IP 列表中取 IP 会取权重最高的 IP。列表中 IP 权重也是动态更新的，根据连接或服务的成功失败来动态调整，这样即使 DNS 解析失败，用户在使用一段时间后也会选取到适合的 Server IP。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了动态 IP 优化策略，携程还使用 TCP 替换 HTTP 请求服务，原因在于：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;携程用户有时会在网络环境非常差的景区使用，需要针对弱网进行特别的优化，单纯 HTTP 应用层协议很难实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP 请求首次需要进行 DNS 域名解析，我们发现国内环境下针对携程域名的失败率在 2-3%（包含域名劫持和解析失败的情况），严重影响用户体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP 虽然是基于 TCP 协议实现的应用层协议，优势是封装性好，客户端和服务端解决方案成熟。劣势是可控性小，无法针对网络连接、发送请求和接收响应做定制性的优化，即使是 HTTP 的特性如保持长连接 Keep Alive 或管道 Pipeline 等都会受制于网络环境中的 Proxy 或者服务端实现，很难充分发挥作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤Hybrid 网络服务优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 中有相当比例的业务是使用 Hybrid 技术实现的，运行在 WebView 环境中，其中的所有网络服务（HTTP 请求）都是由系统控制的，我们无法掌控，也就无法进行优化，其端到端服务成功率也仅有 97%左右（注：这里指页面中业务逻辑发送的网络服务请求，而非静态资源请求）。我们采用了名为“TCP Tunnel for Hybrid”的技术方案来优化 Hybrid 网络服务，和传统 HTTP 加速产品的方法不同，我们没有采用拦截 HTTP 请求再转发的方式，而是在携程 Hybrid 框架中的网络服务层进行自动切换。具体的架构图如图 2 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaI6CzO2SPah8JQ12Qotm6tcdia9ONog9Dm9BAVibPwXvLFlGbaSDlNzKg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2 携程 Hybrid 网络请求转发图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图 2 可见，该技术方案的流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 App 支持 TCP Tunnel for Hybrid，Hybrid 业务在发网络服务时，会通过 Hybrid 接口转发至 App Native 层的 TCP 网络通讯层。该模块会封装这个 HTTP 请求，作为 TCP 网络服务的 Payload 转发到 TCP Gateway。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TCP Gateway 会根据服务号判断出是 Hybrid 转发服务，解包后将 Payload 直接转发至 HTTP Gateway，此 HTTP 请求对 HTTP Gateway 是透明的，HTTP Gateway 无需区分是 App 直接发来的还是 TCP Gateway 转发来的 HTTP 请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后端业务服务处理完成后，HTTP 响应会经 HTTP Gateway 返回给 TCP Gateway，TCP Gateway 将此 HTTP 响应作为 Payload 返回给 App 的 TCP 网络通讯层。 TCP 网络通讯层会再将该 Payload 反序列化后返回给 Hybrid 框架，最终异步回调给 Hybrid 业务调用方。整个过程对于 Hybrid 业务调用方也是透明的，它并不知道 TCP Tunnel 的存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用该技术方案后，携程 App 中 Hybrid 业务的网络服务成功率提升至 99%以上，平均耗时下降 30%，如图 3 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaTTL5Enk1Gd0avESFGysOe6VakRAtKtzxJJG0MobsqqKtFKzlVLUeKg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3 携程 App TCP 和 HTTP 效果对比图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤携程 App 海外网络服务优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程目前没有部署海外 IDC，海外用户在使用 App 时需要访问位于国内的 IDC，服务平均耗时明显高于国内用户。我们采用了名为“TCP Bypass for Oversea”的技术方案来优化主要是使用了 Akamai 的海外专属网络通道，同时在携程国内 IDC 部署了局端设备，使用专用加速通道的方式来提升海外用户体验，如图 4 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riabat7SNgQCvEqia3HjGdzOQoJesEoLhTXrJusyMC6K9Xibiaf8xctpy3EA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4 携程海外网络通道署图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;海外用户启动 App 后先通过 Akamai 定制域名获取 Server IP，所有网络服务优先走 Akamai 通道；如果 Akamai 通道的网络服务失败并且重试机制生效时，会改走传统 Internet 通道进行重试。相比只用传统 Internet 通道，在保持网络服务成功率不变的情况下，使用 Akamai 通道 Bypass 技术后平均服务耗时下降了 33%，如图 5 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riao7MQJeVC51Umex34UX65xH1Qsxdk87DQnbA3FpAFekIDCJAUnpndVQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5 海外网络服务优化前后对比图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤携程 App 通信数据格式优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 原来使用了自定义的 SOTP 协议格式，底层采用 Socket TCP 协议，为了提高服务响应加载速度，我们优化了 TCP 服务 Payload 数据的格式和序列化/反序列化算法，从自定义 SOTP 格式转换到了 Protocol Buffer 数据格式。此外对数据格式进行了 Gzip 压缩，提升效果非常明显，我们使用 PB＋Gzip 后，数据大小下降了 76%，如图 6 和表 1 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaZOz8DonLrkZxnLRL4lFib17v0RibSZUM2yuiaKzKbWjtjtfjwaJn7ib1tw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 6 数据序列化大小对比效果图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riarPDab48xSLSaPGTrqLcunub4RJ885gpib97ibj1RDdY5MAV9QjoHRWoA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表 1 数据序列化大小对比效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 PB+Gzip 的优势，我们目前基本上大部分服务都已经迁移到 PB 上来。另外 Facebook 曾分享过他们使用 FlatBuffer 提高性能的实践，可以参考 Facebook 开源的 Blog。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FlatBuffer 是 Google 为游戏平台开放的一个开源项目，它是 Protocol Buffer 的一种进化方案与实现，具有不需要反序列化就能够获取到任意子元素、保持元数据的优点，不需要打包/解包。它的结构化数据都以二进制形式保存，不需要数据解析过程，数据也可以方便传递。所以在性能上很有优势，但是后续我们分析后不太适合携程的业务场景因而最终没有使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤其他网络相关优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;弱网和网络抖动优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 引入了网络质量参数，通过网络类型和端到端 Ping 值进行计算，根据不同的网络质量改变网络服务策略：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调整长连接池个数：例如在 2G/2.5G Egde 网络下，会减少长连接池个数为 1（运营商会限制单个目标 IP 的 TCP 连接个数）；Wi-Fi 网络下可以增加长连接池个数等机制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态调整 TCP Connection、Write、Read 的超时时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不同网络类型状态切换连接机制：例如 Wi-Fi 和移动网络、4G/3G 切换至 2G 时，客户端 IP 地址会发生变化，已经连接上的 TCP Socket 注定已经失效（每个 Socket 对应一个四元组：源 IP、源 Port、目标 IP、目标 Port），此时会自动关闭所有空闲长连接，现有网络服务也会根据状态自动重试。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引入重试机制，提升服务成功率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;受 TCP 协议重传机制来保证可靠传输的机制启发，在应用层面也引入了重试机制来提高网络服务成功率。我们发现 90%以上的网络服务失败都是由于连接失败，此时再次重试是有机会连接成功并完成服务的；同时我们发现前面提到的网络服务生命周期处于建立连接、序列化网络请求报文、发送网络请求这三个阶段失败时，都可以自动重试，因为我们可以确信请求还没有到达服务端进行处理，不会产生幂等性问题（如果存在幂等性问题，会出现重复订单等情况）。当网络服务需要重试时，会使用短连接进行补偿，而不再使用长连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现了上述机制后，携程 App 网络服务成功率由原先的 95.3%+提升为如今的 99.5%+（这里的服务成功率是指端到端服务成功率，即客户端采集的服务成功数除以请求总量计算的，且不区分当前网络状况），效果显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤其他网络服务机制和技巧&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 也实现了其他一些网络服务机制方便业务开发，如网络服务优先级机制，高优先级服务优先使用长连接，低优先级服务默认使用短连接；网络服务依赖机制，根据依赖关系自动发起或取消网络服务，例如主服务失败时，子服务自动取消。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发过程中我们也发现一些移动平台上的 TCP Socket 开发技巧：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;iOS 平台上的原生 Socket 接口创建连接并不会激活移动网络，这里原生 Socket 接口是指 POSIX Socket 接口，必须使用 CFSocket 或再上层的网络接口尝试连接时才会激活网络。因此携程 App 启动时会优先激活注册一些第三方 SDK 以及发送 HTTP 请求来激活移动网络。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;合理设置 Socket 的几个参数：SO_KEEPALIVE 参数确保 TCP 连接保持（注：此 KeepAlive 是 TCP 中的属性，和 HTTP 的 KeepAlive 是两个场景概念），SO_NOSIGPIPE 参数关闭 SIGPIPE 事件，TCP_NODELAY 参数关闭 TCP Nagle 算法的影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 iOS 要求支持 IPv6-Only 网络，因此使用原生 Socket 必须支持 IPv6。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果使用 select 来处理 Non-blocking/IO 操作，确保正确处理不同的返回值和超时参数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保持 TCP 长连接可用性的心跳机制：对于非 IM 类应用而言，心跳机制的作用不大，因为用户会不断触发请求去使用 TCP 连接。尤其在携程业务场景下，通过数据统计发现使用心跳与否对服务耗时和成功率影响极小，因此目前已经关闭心跳机制。原先的心跳机制是 TCP 长连接池中的空闲 TCP 连接每 60 秒发送一个心跳包到 Gateway，Gateway 返回一个心跳响应包，从而让双方确认 TCP 连接有效。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤关于 SPDY 和 HTTP/2 协议的探讨&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过去两年我们的网络服务优化工作都是基于 TCP 协议实现的，基本达到了优化目标。不过这两年来新的应用层网络协议 SPDY 和 HTTP/2 逐步迈入主流，基于 UDP 的 QUIC 协议看起来也非常有趣，值得跟进调研。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SPDY 是 Google 基于 TCP 开发的网络应用层协议，目前已经停止开发，转向支持基于 SPDY 成果设计的 HTTP/2 协议。HTTP/2 协议的核心改进其实就是针对 HTTP/1.x 中影响延迟性能的痛点进行优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Header 压缩：压缩冗余的 HTTP 请求和响应 Header。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持 Multiplexing：在 HTTP/1.1 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞，而 HTTP 2.0 就是为了解决这个限制问题，采取多路复用技术，即支持一个 TCP 连接上同时实现多个请求和响应。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二进制分帧提高传输性能：在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等因素的情况下，应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层去提高传输效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保持长连接（比 HTTP/1.x 更彻底）：减少网络连接时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持服务端推送：由服务端主动推送数据到客户端，同时可以缓存，也让在遵循同源的情况下，不同页面之间共享缓存资源成为可能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官方性能测试结果显示使用 SPDY 或 HTTP/2 的页面加载时间减少 30% 左右，不过这是针对网页的测试结果。对于 App 中的网络服务，具体优化效果我们还在进行内部测试，不过其优化手段和目前我们使用 TCP 协议的相类似，因此性能优化效果可能不会很显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过 HTTP2.0 正处于逐步应用到线上产品和服务的阶段，可以预见未来会有不少新的坑产生和与之对应的优化技巧，HTTP1.x 和 SPDY 也将在一段时间内继续发挥余热。作为工程师，需要了解这些协议背后的技术细节，才能打造高性能的网络框架，从而提升我们的产品体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程图片相关优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Android 系统中，当我们使用资源 ID 来去引用一张图片时，Android 会使用一些规则来帮我们匹配最适合的图片。什么叫最适合的图片？比如我的手机屏幕密度是 xxhdpi，那么 drawable-xxhdpi 文件夹下的图片就是最适合的。因此，当我引用这张图时，如果 drawable-xxhdpi 文件夹下有这张图就会优先被使用，在这种情况下，图片是不会被缩放的。系统就会自动去其它文件夹下找这张图，优先会去更高密度的文件夹下寻找。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们当前的场景就是 drawable-xxhdpi 文件夹，然后发现这里也没有这张图，接下来会尝试再找更高密度的文件夹，发现没有更高密度的了，就会去 drawable-nodpi 文件夹找，发现也没有，那么就会去更低密度的文件夹下面找，依次是 drawable-xhdpi→drawable-hdpi→drawable-mdpi→ drawable→ldpi。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体匹配规则就是如上所示，那么比如说我手机是 1080P，但是资源图片放在 drawable-xhdpi 文件夹下面，系统首先去 xxhpi 文件下去寻找发现没有找到，然后跑到更高密度夹 xxxhdpi 还是没找到，最后发现低密度文件夹 xhdpi 下有资源，于是系统自动帮我们做了这样一个 3/2 放大操作。同样的道理，如果系统是在 drawable-xxxhdpi 文件夹下面找到这张图的话，它会认为这张图是为更高密度的设备所设计的，如果直接将这张图在当前设备上使用就有可能会出现像素过高的情况，于是会自动帮我们做一个缩小的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前市场上主流机型是 1080P，所以美工切图以 1080P 为基准切一套图，直接将这一套图放在 xxhdpi 文件夹下面即可，即如果你的机子是主流机型 1080P 分辨率，则图片资源不会做任何缩放，但如果你的机子是 720P（xhdpi），则图片资源会做 2/3 倍的扩大，其实际占用内存会变小，同时资源不会被放大变形；同理如果是 480P（hdpi），则图片资源会做 2/4 倍的扩大，即图片大小缩放为原来的 1/2，实际占用内存同上所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将资源图片放到正确的位置，能帮 App 去优化节省内存，提升用户体验，所以在开发过程中，资源图片不要任意放置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程做了一件事情，就是将图片资源位置进行了正确整理，如原来放错位置的 xhdpi/hdpi/mdpi 资源全部迁移到 xxhpi 文件夹下面，并且删除了原来的多套图资源，只是在特殊的界面适配比如 Pad 适配，才会特殊处理。这样做的结果是直接减少内存 20%，Apk Size 减少了 20% 左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，为了减少 App Size，除了删除多套图资源和无用的资源，我们在图片优化上，还使用了 SVG 矢量图、WebP 格式的图片替换原始的 PNG。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片是携程 App 使用场景中较多的元素之一，如何快速节省流量的下载和渲染图片是我们非常关注的性能问题。除了上面提到的网络优化长连接，携程还实现了 App 的动态切图技术，动态下发 WebP 格式图片：主要是基于分辨率、质量、锐化、格式四个纬度，对同一张图片生成了不同组合的文件，设置了一系列匹配规则，针对不同屏幕、机型处理能力、网络环境，配置出适合当前情况的图片大小质量，保证图片大小既节省又确保用户视觉体验。其图片加载流程如图 7 所示，最终携程的优化效果：图片下载大小减少 58%，下载耗时降低 50%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riavrVibic8ib1WSR9wLyOmUZmjge28MCYzTC21VSuicwzCKkE6PdyEeC6MzA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 7 携程图片加载流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在图 7 中，图片加载流程有个域名收敛机制，为什么需要域名收敛？首先它是相对于域名发散技术的，是因为浏览器对同一域名做了最大连接数限制，所以为了让浏览器并发加载而做发散，缺点是域名过多会引起 DNS 解析耗时。域名收敛就是为了解决 DNS 解析耗时问题，以加快图片下载速度从而提升用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程地图优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程国内地图最早接入的是高德地图，后来才接入百度地图，但是它们海外支持较差，很多城市没有数据支持，iOS 用户相对还好解决，因为苹果在国内的合作厂商是高德，所以当时 iOS App 无论国内外都是直接使用苹果自带的地图。但是 Android App 海外地图相对没有好的解决方案，本来 Android 海外地图直接集成 Google 地图 Native SDK 即可。但是因为国内用户无法访问 Google 的服务，所以这种方案直接就舍弃，后来就直接采用 Google 海外版的 JS 方案，基于 Google JS 地图 API，开发了 Hybrid 版的 Google 地图，最终效果图如图 8 和图 9 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaibw9qVjrTZd4pyOLoAow5Z9KjfWHicickLXXfTicFNzNlBr84ae6tV6dtQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 8 携程海外详情地图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaWHkGdha4icCEtkGUosEneAicRVz3Ujxv7PlUZrb4j4sAhftXbQyuVolg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 9 携程海外列表地图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google JS 地图的域名服务因为大陆不稳定，所以携程对于 JS 域名服务做了一个简单优化，在国内的优先使用香港域名服务，如果访问不通，再使用海外域名服务；在海外的用户则优先使用 Google 海外域名服务，保证了海外地图稳定的服务以及良好的用户体验。此外地图的其他方面优化，比如数据做分段加载，以及数据的缓存机制，WebView 单独 WebCore 的优化，提前预加载数据和 JS 资源等优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App 启动内存优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个章节主要是针对携程 App Android 平台上做的插件内存优化。携程目前有多个不同的事业部，主要由酒店、机票、火车票、汽车票、旅游等组成，每个事业部都独立开发。其开发的 Bundle 就是一个独立插件，开发过程中不相互依赖，Android 最终集成阶段会单独生产一个 APK，目前携程 App 由 30 多个 Bundle 业务插件组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动 App 时，为了优化内存，不直接将所有的 Bundle 插件而是将每个事业部的核心 Bundle dex 文件加载进来，其他插件实现 Lazy-loading 即按需加载机制。为了实现 Lazy-loading 加载速度，直接将 Bundle 优化到更加地细粒度（其加载时间尽量不超过 500ms），这样直接加快 App 启动速度，并节省 App 内存，其优化的效果如图 10 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaiaLqNmgYSJGADjKHylILgpOiczMWZ6FdoxXUxbxGrbQiapR08q0HbW7Zg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 10 Android App 安装启动时间对比效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过优化后，App 启动时间提升明显。关于内存优化，携程 App 还从图片占用内存、轻量级数据结构、内存泄露等角度进行了优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 React Native 优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 从 12 年开始开发，至今已有 4 年多时间，随着各项业务功能的全面移动化，以及公司“Mobile First”策略的指引下，App 功能愈加丰富和复杂，从而造成 App iOS Size 达到将近 100MB。而同样功能，使用 RN 开发，Size 远远小于 Native 开发，RN 的引入，可以支持我们 App 的可持续健康发展。此外由于 RN 通过 Java Core 解析 Java 模块转换成原生 Native 组件渲染，相比 H5 页面不再局限于 WebView、渲染性能长足提升，运行用户体验比 H5 提升明显可以媲美 Native，且 RN 支持跨平台和动态更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述原因，携程从 16 年 4 月份开始，在 App 内部开始小范围使用 React Native 技术，主要是基于 RN 0.28 定制 CRN，App V6.17 版本中实现站内信、机票低价订阅，之后开始较大规模地在各个 BU 事业部推广，有 15 个业务模块在使用，涉及到的页面在 50 个以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ListView 是我们大量使用的控件，所以需要重点优化，原生控件超出屏幕的条目，依然被渲染了。没有实现 cell 重用，导致数据量大时会出现卡顿现象。为了提高用户体验，具体优化思路是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们基于原生控件开发了可重用 cell 的 CRNListView，iOS 借鉴了第三方的 ReactNativeTableView 的实现，开发了可重用 cell 的 ListView，接口和官方原生的基本一致。Android 借鉴 iOS 的方案，采用 RecyclerView 实现了类似的可重用 cell 的 ListView，同时我们还做了一些扩展，把常用的下拉刷新，载入更多，右侧字母索引栏等功能，都增加了进去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际测试下来，当数据量少时，和 RN 官方提供的 ListView 性能基本一致，但数据量大时，CRNListView 优势明显，如图 11 是我们在 Android 上的测试数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riauGOjPwQyjfq4sjtoOKvYeaZQSm8Qwyl9C4PjIrfKJexCknaB9ibBspw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 11 前后对比效果图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RN 页面加载最大的瓶颈在 JS Init + Require，这块就是 JSBundle 的执行时间。为了提升页面加载速度，要想办法优化。基于此原因，我们对 RN 官方的打包脚本做改造，将框架代码拆分出来，让所有业务使用一份框架代码，即拆分成 Common.js 和 Business.js。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般 RN 框架部分文件（Common.js）大小比较大，占用了绝大部分的 JS 执行时间。如果这部分执行加载时间能放到后台预先做完，进入业务也只需执行业务页面的几个 JS 文件，将可以大大提升页面加载速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照这个思路，能后台加载的 JS 文件, 实际上就是一个 RN App。因此我们设计了一个空白页面的 Fake App，用来监听要显示的真实业务 JS 模块，收到监听后，渲染业务模块最终显示页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App 其他角度优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从减少频繁 I/O 角度，及自身业务出发，去除若干初始化阶段不必要的文件操作，以及将若干非实时性要求的文件操作延后处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Android 上对于频繁读写数据库 SharedPreference 以及文件的模块，通过增加缓存和降低采样率等手段减少对 I/O 的读写。对于 SharedPreference 进行了专门的优化，减少单个文件的大小，将毫无联系的存储键值分开到不同文件中，并且防止将大数据块存储到 SharedPreference 中，这样既不利于性能也不利于内存，因为 SharedPreference 会有额外的一份缓存长期存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于多线程治理：我们分析了各个模块的线程数量，检查线程池的合理性。通过去掉不必要的线程和线程池，再控制线程池的并发数和优先级。进一步通过框架层的线程池来接管业务方的线程使用，以减少线程太多的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;检测超时方法，优化主线程：在早期版本性能优化前，初始化代码都在主线程中执行，为了优化性能，我们已经将部分比较耗时的初始化任务放入后台线程或者异步执行。但是随着携程业务的不断发展和人员变更，还是出现了在主线程中执行很重的初始化任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Android 平台通过开启 StrictMode 去检测优化，StrictMode 主要检测两大问题，一个是线程策略，即 TreadPolicy，另一个是 VM 策略，即 VmPolicy。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ThreadPolicy 线程策略检测的内容有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自定义的耗时调用使用 detectCustomSlowCalls() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;磁盘读取操作使用 detectDiskReads() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;磁盘写入操作使用 detectDiskWrites() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络操作使用 detectNetwork() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;VmPolicy 虚拟机策略检测的内容有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Activity 泄露使用 detectActivityLeaks() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;未关闭的 Closable 对象泄露使用 detectLeaked ClosableObjects() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;泄露的 SQLite 对象使用 detectLeakedSqlLiteObjects() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;检测实例数量使用 setClassInstanceLimit() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开启 StrictMode 之后，我们将日志输入到 SD card 面，在开发 Debug 阶段导出来可以通过日志分析找出对应的问题和原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;iOS 平台我们实现了一套应用运行时方法耗时检测机制，能够对应用中所有类的方法调用做耗时统计。方便地找到超时的方法调用后，就可以有针对性地做出修改，或删除或异步化。这种方法调用耗时检测机制同样适用于 App 运行过程中，从而找到导致应用卡顿的根本原因，最后做出对应修改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App 性能衡量考察&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;衡量一个 App 性能和质量，首先需要了解 App 性能的现状，即 App 端性能的采集。常规的技术方案有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用第三方性能采集 SDK，例如 OneAPM、听云等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自主研发：携程为了完整掌握用户数据采用了自己研发的方式：App 通过日志 SDK 采集日志包括行为埋点和性能埋点，上传至日志服务端，日志消息经 Kafka 消息队列存入 HDFS（RCFile 格式）分布式文件存储系统，后期的数据查询均基于 Hive 系统来实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;App 端的性能数据会在多种纬度（操作系统、App 版本、网络状况、位置）下采集网络（网络服务成功率、平均耗时、耗时分布等）、定位（经纬度成功率、城市定位成功率等，见图 12）、启动时间、内存流量等各类指标。其中像网络服务性能是对于用户体验至关重要的端到端性能，也是优化的核心依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaMgVyLKnO5MNkkznpORoqB9SRSc2TJnaUZFmGg9wvibWbgOiaH3DJGibEw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 12 携程城市定位成功率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能数据采集后需要采用简单直观的 Portal 进行展示，携程为无线业务开发了 Web 端和 App 端性能展示 Portal，图 13 和图 14 是网络性能监控的截屏，数据会每小时进行更新聚合并展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6ria863ArcY2NicDKljicl5jAAnXVskGCtKHBANjjuzTU6eqQYe19CXSSkqw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 13 网络服务性能监控工具展示界面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riav0eg6ZQwCFVfhFVRGFnJ2e37UkYL1pv3gmcAKpzEEQWHVcWibx5RksA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 14 网络服务成功率展示界面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤携程 App 其他相关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 3.x 架构的基础上，携程插件 Bundle 自动化打包平台也应运而生，各 BU 只需要关注自己 BU 的 Bundle 即可，同时开发直接将最新的代码集成到 Bundle 中，打一个最新 Bundle，然后测试也可以自己随时打包，携程无线为我们开发了 MCD 打包平台，可以让整个打包流程自动化，同时这个平台还提供了 HotFix 发布平台、App 应用性能管理、App Crash 数据采集等工具，同时可以实现 Daily/Hourly Build，无缝集成自动化测试，集成了 Sonar 代码扫描去检测重复代码等和 infer null pointer，然后能生成一个代码健康度扫描报告，并能帮助分析和解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App Size 优化相关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过脚本或第三方工具检测删除无用的资源、类、函数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 Sonar 检测整个 App 中的重复代码，将重复代码合并或 App 删除；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清理第三方引入的库，删除不用的多套库，比如百度和高德地图 SDK 等，多套图片库等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不轻易引进第三方的库，比如注解框架等，慎重使用第三方定义的控件，自己自定义控件去实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于资源图片统一经过 tinpng 压缩；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;资源图片统一整理，功能和资源统一，不重复造轮子，删除原来的多套资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;资源图片使用 SVG 或者 WebP 格式图片去替换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清理高清资源大图片，特别是超过 10K 以上的图片；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;能用代码去实现的 UI，尽量不用去图片代替；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Native 转 H5；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Native 或者 H5 转 React Native；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hybrid 页面离线的 JS 资源，直接转换成 RN，减少包大小比较明显。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着移动端技术的不断成熟发展，以及各公司业务的成熟稳定发展，App 性能优化成为各大公司重点关注的问题，目的就是为了提升用户的使用体验。性能优化是一个持续发展的实践课题，可以持续贯穿于我们日常的开发工作中，即随着手机机型的日益碎片化，程序功能的复杂化多样化，总之移动端技术的性能优化是没有尽头的，我们会继续持续关注移动端的性能优化，并融入新的技术进行迭代更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;移动端技术发展很快，携程也正在积极尝试新技术，例如 React Native（已在线上很多模块的信息页面使用，如机票和酒店的部分页面），同时携程基于 RN 推出了自己的 RN 框架 Moles，并且做了不少相关 RN 实践性能优化。同时关于新的网络协议 SPDY、HTTP/2.0，Apple/Huawei/Samsung Watch App 等都做了大量尝试，以期能够提升产品品质。在过去几年时间里，我们已经实现了不少新技术与业务的融合，在这简单列举几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;推出了基于 React Native 的 Moles 框架，并且做了很多 RN 相关优化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Bundle 差分升级更新；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 MVP 和 AOP 的框架设计；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;率先支持 Apple/Huawei/Samsung Watch App；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 FreelLine 和 LayoutCast 的热部署方案；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持 SPDY，HTTP2.0 的探讨实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来我们会不断推进新技术的研究并且融合到业务需求中，希望有更多优质内容分享给行业同行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从之前持续不断的性能优化中，我们虽然积累了不少优化经验，但是在 Android 平台部分，较低端低配置机型上携程 App 性能问题依然不容乐观，所以接下来会继续努力通过更多更细致的优化方案来提升用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来我们基于之前积累的历史优化经验会形成一套性能优化的经验闭环，由观察问题现象到分析原因、建立监控，定下量化目标，执行优化方案，验证结果数据再回到观察新问题。每一次闭环只能解决部分问题，不积硅步无以至千里，不积小溪无以成江海，只有不断抓住细微的优化点持续“啃”下去，才能得到螺旋上升的良好结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章最后，感谢陈浩然、赵辛贵之前提供给我的相关框架资料。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者简介： 南志文，时任携程研发经理，曾负责携程 App 整体技术框架的架构研发与实践，酒店业务的迭代更新及 App 架构、性能优化，先后就职于阿里巴巴、巨人网络等。&lt;/span&gt;&lt;span&gt;责任编辑： 唐小引，技术之路，共同进步，欢迎技术投稿、约稿、给文章纠错，请发送邮件至tangxy@csdn.net。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/0?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 03 Jan 2017 17:21:22 +0800</pubDate>
    </item>
  </channel>
</rss>
