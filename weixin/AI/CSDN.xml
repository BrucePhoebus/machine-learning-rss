<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>CSDN大数据</title>
    <link>http://www.iwgc.cn/list/1933</link>
    <description>CSDN分享Hadoop、Spark、NoSQL/NewSQL、HBase、Impala、内存计算、流计算、机器学习和智能算法等相关大数据观点,提供云计算和大数据技术、平台、实践和产业信息等服务.</description>
    <item>
      <title>网易分库分表数据库DDB</title>
      <link>http://www.iwgc.cn/link/4197458</link>
      <description>&lt;blockquote style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文为&lt;/strong&gt;&lt;strong&gt;&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;《程序员》&lt;/a&gt;原创文章，未经允许不得转载，更多精彩请&lt;a target="_blank" style="color: rgb(67, 149, 245); max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;订阅2017年《程序员》&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互联网时代，也是关系型数据库独领风骚的时代，从早期的Oracle独步天下，到现在MySQL蒸蒸日上，关系型数据库是大多数互联网应用在数据可靠性存储上的“命脉”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着互联网产品在体量和规模上日益膨胀，无论是Oracle还是MySQL，都会第一时间面临来自磁盘、CPU和内存等单机瓶颈，为此，产品方除了需要不断购买成本难以控制的高规格服务器，还要面临不断迭代的在线数据迁移。在这种情况下，无论是海量的结构化数据还是快速成长的业务规模，都迫切需要一种水平扩展的方法将存储成本分摊到成本可控的商用服务器上。同时，也希望通过线性扩容降低全量数据迁移对线上服务带来的影响，分库分表方案便应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表的原理是将数据按照一定的分区规则Sharding到不同的关系型数据库中，应用再通过中间件的方式访问各个Shard中的数据。分库分表的中间件，隐藏了数据Sharding和路由访问的各项细节，使应用大多数场景下可以像使用单机数据库一样使用分库分表后的分布式数据库。业界中，网易DDB、阿里TDDL、Cobar、MyCat和HotDB等系统都是分库分表中间件中的佼佼者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景——十年一剑&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB（全称Distributed Database）是网易杭研院立项最早、应用最为广泛的后台产品之一，也是国内最早出现的数据库分库分表中间件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最早可以追溯到2006年，网易杭研成立之初，为了应对网易博客这个日活超过800W的大体量应用，由现任杭研院院长的汪源带队主导开发了DDB这套分库分表数据库，伴随着博客的成长，DDB集群也从最早的20+节点，到40+节点，最后到现在云端100+个RDS实例。除了博客外，十年来DDB也见证了很多其他大体量应用，如易信、云音乐、云阅读、考拉等。在大家耳熟能详的网易互联网产品中，几乎都可以看到DDB的身影。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过10年的发展和演变，DDB的产品形态已全面趋于成熟，功能和性能得到了众多产品的充分验证，下面罗列一些大家比较关注的功能特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;与SQL92标准的兼容度达90%以上&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持跨库JOIN和跨库事务，支持大部分标量函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持COUNT、SUM、AVG、MAX、CONCAT等常用聚合函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持与MySQL高度一致的用户管理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持读写分离和数据节点高可用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持数据节点在线扩缩容、在线更改表分布&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;提供完善的数据库管理工具、Web和命令行工具&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据节点支持Oracle和MySQL&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前DDB在网易内部有近50个产品使用，最大集群过百数据节点，大部分部署在云端，为应用提供透明、无侵入、MySQL标准协议的分库分表服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DDB演变之路&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十年来，DDB经历了三次服务模式的重大更迭，从最早的Driver模式，到后来的Proxy模式，再到近几年的云模式，DDB服务模式的成长也深刻反映着互联网流行架构的变迁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Driver模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Driver模式的特点在于应用通过DDB提供的JDBC Driver来访问DDB，类似于通过MySQL的JDBC驱动访问MySQL。而对于MySQL的驱动Connector/J，只需要实现将SQL按照特定协议编码和转码即可。而DDB的驱动为了实现透明的分库分表，需要做很多额外的工作，如图1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaUaFSSTawRvPxUPG1zMrXNwJAWPH0TibQaC8wkicBuib9Nct9fn4D44B1g/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB Driver执行一条SQL时，会经历以下几个步骤：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由语法解析器解析SQL，生成抽象语法树Parse Tree，并根据是否PreparedStatement决定是否进入PTC（Parse Tree Cache），PTC保存了SQL模式到语法树的映射，对PreparedStatement SQL，会优先进入PTC中查询语法树；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据语法树和启发式规则生成分布式执行计划，这个过程会涉及到多个步骤的SQL转换和优化，如条件合并，JOIN拆分，LIMIT转化等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由SQL执行器按照执行计划和语法树生成下发给每个数据节点的真实SQL，然后通过标准数据库驱动将SQL下发给各个数据节点，这个过程为并发执行；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将各个数据节点返回的结果按照执行计划进行合并，并返回上层。具体的合并操作可能在应用调用结果时动态执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBI模块作为DDB提供给应用的JDBC 驱动，包含了完整的透明分库分表逻辑，是DDB最为核心的组件，除此之外，DDB中还有用于元数据管理和同步的Master组件、数据库管理工具DBAdmin，和命令行工具ISQL，DDB的Driver模式整体架构如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaC25quzALRaeK3P0qVz76om44UBaYKiatajFBXzSKbnv0kZTpOgXPV2Q/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;管理操作以建表为例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBA通过DBAdmin的窗口创建表，或者用ISQL执行建表语句后，向Master发起实际建表请求，Master完成用户认证和合法性校验后，先在各个数据节点上创建新表，然后将新表元数据记录在系统库中，最后由Master将新表元数据同步给各个DBI模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于建表语句中DDB特有的语法，会由ISQL或DBAdmin在解析DDL时完成相应处理，如自增ID的设置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在DDB中，Master用于元数据管理、同步和报警监控。DBI模块启动时，会第一时间向Master注册，并拉取元数据，之后Master对元数据的同步保障了DBI模块元数据的更新。在DBI执行SQL，以及创建DB连接的过程中，不会涉及到与Master的交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在分库分表中间件中，与DDB Driver模式同样类型的还有阿里TDDL，优势是部署简单、成本较低、容易理解和上手。劣势也非常明显：只支持Java客户端、版本难以管理、问题难以追踪、DB连接难以归敛等，另外一点是，中间件与应用绑定在一起，对应用本身是个巨大侵入，而且分库分表的过程比较耗费CPU资源，所以在Driver模式下，无论是运维还是性能开销上都存在不可控的因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Proxy模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比于Driver模式在多语言，版本管理，运维风险上存在的问题，Proxy模式很好地弥补了这些缺陷。所谓Proxy，就是在DDB中搭建了一组代理服务器来提供标准的MySQL服务，在代理服务器内部实现分库分表的逻辑。本质上说，DDB Proxy作为一组独立服务，实现了MySQL标准通信协议，任何语言的MySQL驱动都可以访问，而在Proxy内部，依赖DBI组件实现分库分表，Proxy与DBI的关系如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaibo7holnugJ7RMeI3M3v6ickgN4Sbaiay7A4amJKcGnMMQuiaJq24W39Uw/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用通过标准数据库驱动访问DDB Proxy，Proxy内部通过MySQL解码器将请求还原为SQL，并由DDB Driver，也就是DBI模块执行得到结果，最后通过MySQL编码器返回给应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图3可以看出，Proxy在DBI上架设了MySQL编解码模块，从而形成独立标准的MySQL服务，而在MySQL编解码模块之上，DDB Proxy也提供了很多特色命令支持，例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;show processlist：查看Proxy所有连接状态，与MySQL相关命令高度一致&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;show connection_pool：查询Proxy到数据节点的连接池状态&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;showtopsql：查询按照SQL模式聚合的各项统计结果，如执行次数，平均执行时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;count..from：查询过去各个时间段内的吞吐量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，DDB Proxy内还提供了Slow Log等辅助功能，给运维带来很大的便利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB Proxy模式完整架构如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaLib0TznMs23OOaLjcyu9Yq4ap7zLovicFuwrR6QI1RWu3yZvjUZTZJxA/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与Driver模式架构相比，除了QS（DDBProxy的内部称谓，下同）取代了DBI的位置，还在多个QS节点之上部署了LVS或HAProxy + Keepalived的组合做负载均衡，从而实现多个DDBProxy节点的热备，由于DDBProxy无状态，或者说状态统一由Master同步，在数据库节点没有达到瓶颈时，可以通过简单地增设QS服务器实现服务线性扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;私有云模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在网易私有云项目启动之前，DDB一直以一个个独立集群为不同业务提供服务，不同DDB各自为政毫不相干，这样的好处是业务之间完全隔离，互不影响。不好之处在于随着使用DDB的产品数目不断增多，一个DBA往往同时运维数个甚至数十个DDB集群，而之前我们一直缺乏一个平台化的管理系统，DBA在各个集群之间应接不暇时，我们没有平台化的统筹运维帮助应用及早发现问题，或是优化一些使用方法。例如版本管理，2013年我们在一个大版本中做了个Hotfix，并通知所有DBA将相关版本进行升级，但是最后由于管理疏漏，有个别集群没有及时上线，为业务带来了损失。当时如果我们有平台化的管理方案，可以提供一些运维手段帮助和提醒运维人员及时更新所有有问题集群，另外，平台化的管理工具也可以定制一些自动化功能，如自动备份、报警组等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易私有云的出现为DDB的思变提供了契机，从2012年开始，我们就在基于网易私有云开发一套平台化的管理工具Cloudadmin，为此，我们将DDB中原先Master的功能打散，一部分分库相关功能集成到Proxy中，如分库管理、表管理、用户管理等，一部分中心化功能集成到Cloudadmin中，如报警监控，此外，Cloudadmin中提供了一键部署、自动和手动备份、版本管理等平台化功能。私有云DDB的整体架构如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaaRnvduHafdfNv8hQwiaynHuBRE53BRRM9eIr2XpsjwXh2FggEjxlIEw/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在云DDB解决方案中，还打包了网易私有云LVS服务，Cloudadmin通过DDBAgent实现一键部署和报警监控。到目前为止，网易80%以上的DDB集群都已部署云端，云DDB的出现极大减轻了运维人员的负担。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DDB特性介绍&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式执行计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式执行计划定义了SQL在分库分表环境中各个数据库节点上执行的方法、顺序和合并规则，是DDB实现中最为复杂的一环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如SQL：&lt;/span&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;select * from user order by id limit 10 offset 10;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个SQL要查询ID排名在10—20之间的user信息，这里涉及到两个合并操作：全局ID排序和全局LIMIT OFFSET。对全局ID排序，DDB的做法是将ID排序下发给各个数据库节点，在DBI层再进行一层归并排序，这样可以充分利用数据库节点的计算资源，同时将中间件层的排序复杂度降到最低，例如一些需要用到临时文件的排序场景，如果在中间件做全排序会导致极大开销。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对全局LIMIT OFFSET，DDB的做法是将OFFSET累加到LIMIT中下发，因为单个数据节点中的OFFSET没有意义，且会造成错误的数据偏移，只有在中间件层的全局OFFSET才能保证OFFSET的准确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以最后下发给各个DBN的SQL变为：select * from user order by id limit 20。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;又如SQL：&lt;/span&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;select avg(age) from UserTet group by name&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过EXPLAIN语法得到SQL的执行计划，如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaVvtSGYykFmnwbicOXAvDIuicPVyRfmTV82f7w3LPsjrlDdBfwEOCrHRg/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述SQL包含GROUP BY分组和AVG聚合两种合并操作，与全局ORDER BY类似，GROUP BY也可以下发给数据节点、中间件层做一个归并去重，但是前提要将GROUP BY的字段同时作为ORDER BY字段下发，因为归并的前提是排序。对AVG聚合，不能直接下发，因为得到所有数据节点各自的平均值，不能求出全局平均值，需要在DBI层把AVG转化为SUM和COUNT再下发，在结果集合并时再求平均。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB执行计划的代价取决于DBI中的排序、过滤和连接，在大部分场景下，排序可以将ORDER BY下发简化为一次性归并排序，这种情况下代价较小，但是对GROUP BY和ORDER BY同时存在的场景，需要优先下发GROUP BY字段的排序，以达到归并分组的目的，这种情况下，就需要将所有元素做一次全排序，除非GROUP BY和ORDER BY字段相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB的连接运算有两种实现，第一种是将连接直接下发，若连接的两张表数据分布完全相同，并且在分区字段上连接，则满足连接直接下发的条件，因为在不同数据节点的分区字段必然没有相同值，不会出现跨库连接的问题。若不满足连接下发条件，会在DBI内部执行Nest Loop算法，驱动表的顺序与FROM表排列次序一致，此时若出现ORDER BY表次序与表排列次序不一致，则不满足ORDER BY下发条件，也需要在DBI内做一次全排序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表的执行计划代价相比单机数据库而言，更加难以掌控，即便是相同的SQL模式，在不同的数据分布和分区字段使用方式上，也存在很大的性能差距，DDB的使用要求开发者和DBA对执行计划的原理具有一定认识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如分库分表在分区字段的使用上很有讲究：一般建议应用中80%以上的SQL查询通过分区字段过滤，使SQL可以单库执行。对于那些没有走分区字段的查询，需要在所有数据节点中并行下发，这对线程和CPU资源是一种极大的消耗，伴随着数据节点的扩展，这种消耗会越来越剧烈。另外，基于分区字段跨库不重合的原理，在分区字段上的分组、聚合、DISTINCT、连接等操作，都可以直接下发，这样对中间件的代价往往最小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式事务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式事务是个历久弥新的话题，分库分表、分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，如此像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，适用于中间件这种数据节点无耦合的场景。2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。与很多其他一致性协议相同，2PC保障的是最终一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2PC整个过程如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDiaVhCVUnXx6c5ESlsxo8BjFqbZgoh3681nnhiaAM8niczK6Qnibibx3EibNlQ/0?"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在DDB中，DBI和Proxy组件都作为Coordinator存在，2PC实现时，记录Prepare和PrepareAll的日志必须sync，以保障重启后恢复状态正确，而Coordinator最后的Commit日志主要作用是回收之前日志，可异步执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于2PC要求Coordinator记日志，事务吞吐率受到磁盘I/O性能的约束，为此DDB实现了GROUP I/O优化，可极大程度提升2P C的吞吐率。2PC本质上说是一种阻塞式协议，两阶段提交过程需要大量线程资源，因此CPU和磁盘都有额外消耗，与单机事务相比，2PC在响应时间和吞吐率上相差很多，从CAP角度出发，可以认为2PC在一定程度上成全了C，牺牲了A。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，目前MySQL最流行的5.5和5.6版本中，XA事务日志无法Replicate到从节点，这意味着主库一旦宕机，切换到从库后，XA的状态会丢失，可能造成数据不一致，这方面MySQL 5.7已经有所改善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然2PC有诸多不足，我们依然认为在DDB中有实现价值，DDB作为中间件，其迭代周期要比数据库这种底层服务频繁很多，若没有2PC，一次更新或重启就可能造成应用数据不一致。从应用角度看，分布式事务的现实场景常常无法规避，在有能力给出其他解决方案前，2PC也是一个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力，可以结合SOA框架来架构。原理上说，这两种方案都是大事务拆小事务，小事务变本地事务，最后通过幂等的Retry来保障最终一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;弹性扩缩容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分库分表数据库中，在线数据迁移也是核心需求，会用在以下两种场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据节点弹性扩容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着应用规模不断增长，DDB现有的分库可能有一天不足以支撑更多数据，要求DDB的数据节点具有在线弹性扩容的能力，而新节点加入集群后，按照不同的Sharding策略，可能需要将原有一些数据迁入新节点，如HASH分区，也有可能不需要在线数据迁移，如一些场景下的Range分区。无论如何，具备在线数据迁移是DDB支持弹性扩容的前提。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据重分布&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发者在使用DDB过程中，有时会陷入困局，比如一些表的分区字段一开始没考虑清楚，在业务已经初具规模后才明确应该选择其它字段。又如一些表一开始认为数据量很小，单节点分布足以，而随着业务变化，需要转变为多节点Sharding。这两种场景都体现了开发者对DDB在线数据迁移功能的潜在需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无论是弹性扩容，还是表重分布，都可当做DDB以表或库为单位的一次完整在线数据迁移。可分为两个阶段：全量迁移和增量迁移：全量迁移是将原库或原表中需要迁移的数据DUMP出来，并使用工具按照分区策略Apply到新库新表中。增量迁移是要将全量迁移过程中产生的增量数据更新按照分区策略Apply到新库新表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全量迁移的方案相对简单，使用DDB自带工具按照特定分区策略DUMP和Load即可。对增量迁移，DDB实现了一套独立的迁移工具Hamal来订阅各个数据节点的增量更新，Hamal内部又依赖DBI模块将增量更新Apply到新库新表，如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhboMzgaQTMiblcE1O5vfEDia4zFb3len9NlCQ6oEkKBuCZgLxgK0vtzgckzvQgibgfvw8KBlvHIq5gg/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;center style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/center&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hamal作为独立服务，与Proxy一样由DDB统一配置和管理，每个Hamal进程负责一个数据节点的增量迁移，启动时模拟Slave向原库拉取Binlog存储本地，之后实时通过DBI模块Apply到新库新表，除了基本的迁移功能外，Hamal具备以下两个特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;并行复制：Hamal的并行复制组件，通过在增量事件之间建立有向无环图，实时判断哪些事件可以并行执行，Hamal的并行复制与MySQL的并行复制相比快10倍以上；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;断点续传：Hamal的增量Apply具有幂等性，在网络中断或进程重启之后可以断点续传。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;全局表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑一种场景：City表记录了国内所有城市信息，应用中有很多业务表需要与City做联表查询，如按照城市分组统计一些业务信息。假设City的主键和分区键都是CityId，若连接操作发生在中间件层，代价较高，为了将连接操作下发数据节点，需要让联接的业务表同样按照CityId分区，而大多数业务表往往不能满足这个条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;联接直接下发需要满足两个条件，数据分布相同和分区键上联接，除此之外，其实还有一种解法，可以把City表冗余到所有数据节点中，这样各个数据节点本地联接的集合便是所求结果。DDB将这种类型的表称之为全局表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全局表的特点是更新极少，通过2PC保障各个节点冗余表的一致性。可以通过在建表语句添加相关 Hint指定全局表类型，在应用使用DDB过程中，全局表的概念对应用不可见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;未来——独立平台，与云共舞&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DDB作为网易浓缩了10年技术经验与精华的分库分表数据库，近一两年除了满足内部产品使用外，也渐渐开始帮助外部企业客户解决海量结构化数据存储的难题。随着公有云技术的大力发展和日趋成熟，各种IaaS和PaaS平台如雨后春笋层出不穷，如网易蜂巢的推出，为应用开发、部署和运维提供了极大便利。而随着IaaS层和PaaS平台的普及，各种SaaS服务也会慢慢为广大开发者所接纳，未来DDB也将重点为网易蜂巢客户打包DDB的SaaS服务，与蜂巢一同构建一套更加丰富的数据存储生态系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对DDB的SaaS服务化无比坚定，同时DDB的公有云之路绝非私有云的生搬硬套，在与蜂巢一同帮助企业客户解决分库分表难题的同时，未来我们也会更加注重平台独立，首先要做的是将DDB的SaaS层与底层PaaS和IaaS层解耦，实现将DDB平台所依赖的PaaS和IaaS以插件方式注入。这样既可以为客户提供更灵活的服务方式，也可以极大程度降低DDB平台本身的开发和运维成本：一套平台管理工具，适用所有内外部DDB用户，这是我们正在进行并将持续优化的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;作者：马进，DDB项目负责人，2013年加入网易，热衷于分布式中间件相关方面工作，从事过分库分表数据库DDB、缓存NKV、分布式事务中间件TCC、分布式视频处理系统NTS等项目。&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Wed, 04 Jan 2017 17:31:34 +0800</pubDate>
    </item>
    <item>
      <title>深度 | 对比深度学习十大框架：TensorFlow最流行但并不是最好</title>
      <link>http://www.iwgc.cn/link/4197459</link>
      <description>&lt;p&gt;&lt;span&gt;2016 年已经过去，BEEVA Labs 数据分析师 Ricardo Guerrero Gomez-Ol 近日在 Medium 上发表了一篇文章，盘点了目前最流行的深度学习框架。为什么要做这一个盘点呢？他写道：「我常听到人们谈论深度学习——我该从哪里开始呢？TensorFlow 是现在最流行的吧？我听说 Caffe 很常用，但会不会太难了？在 BEEVA Labs，我们常常需要应对许多不同的深度学习库，所以我希望能够将我们的发现和感想分享出来，帮助那些刚刚进入深度学习这一美丽世界的人。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;TensorFlow&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://www.tensorflow.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于那些听说过深度学习但还没有太过专门深入的人来说，TensorFlow 是他们最喜欢的深度学习框架，但在这里我要澄清一些事实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 TensorFlow 的官网上，它被定义为「一个用于机器智能的开源软件库」，但我觉得应该这么定义：TensorFlow 是一个使用数据流图（data flow graphs）进行数值计算的开源软件库。在这里，他们没有将 TensorFlow 包含在「深度学习框架」范围内，而是和 Theano 一起被包含在「图编译器（graph compilers）」类别中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在结束了Udacity 的Deep Learning课程之后，我的感觉是 TensorFlow 是一个非常好的框架，但是却非常低层。使用 TensorFlow 需要编写大量的代码，你必须一遍又一遍地重新发明轮子。而且我并不是唯一一个这么想的人。Andrej Karpathy 在 Twitter 上就多次吐过槽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;推文：我希望 TensorFlow 能标准化我们的代码，但它是低层面的，所以我们在其上面的层上分道扬镳了：Slim、PrettyTensor、Keras、TFLearn …&lt;/span&gt;&lt;span&gt;比如：我们在 OpenAI 使用 TensorFlow，但我们似乎都更喜欢其它框架，我们有些人还写自定义代码。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;几个月前，我去参加了「Google Experts Summit: TensorFlow, Machine Learning for everyone, with Sergio Guadarrama」。Sergio 是开发TensorFlow 的一位工程师，但他在会上没有展示 TensorFlow，而是展示了一个在TensorFlow上工作的更高层的库 tf.contrib：https://www.tensorflow.org/tutorials/tflearn/。我的看法是：他们内部已经意识到如果要让更多人使用 TensorFlow，他们就需要以更高的抽象水平在其上创建一些层，从而简化 TensorFlow 的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TensorFlow 支持 Python 和 C++，也允许在 CPU 和 GPU 上的计算分布，甚至支持使用 gRPC 进行水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：TensorFlow 非常好，但你必须了解它好在哪里。如果你不想什么事都自己手动去做和重新发明轮子，你可以使用更简单的库（安利一下 Keras）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Theano&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://deeplearning.net/software/theano/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Theano 是最老牌和最稳定的库之一。据我所知，深度学习库的开端不是 Caffe 就是 Theano。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;和 TensorFlow 类似，Theano 是一个比较低层的库。也因此它并不适合深度学习，而更适合数值计算优化。它支持自动的函数梯度计算，带有 Python 接口并集成了 Numpy，这使得它从一开始就成为了通用深度学习领域最常使用的库之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天，Theano 依然效果良好，但由于它不支持多 GPU 和水平扩展，在 TensorFlow 的热潮下（它们针对同一个领域），Theano 已然开始被遗忘了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Keras&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://keras.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「You have just found Keras.」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这句话是你打开文档页面时看到的第一句话。我还记得我第一次发现 Keras 的时候。那时候我正在柏林解决 Data Science Retreat 的最后一个项目，为此我努力进入了深度学习库的世界。我在起步时就已经有了足够的深度学习知识，但我没有时间自己手动编写功能，也没有时间探索和学习一个新的库（截止时间不到 2 个月，而我还有课要上）。然后我发现了 Keras。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我真的很喜欢 Keras，因为它的句法是相当明晰的，它的文档也非常好（尽管相对较新），而且它支持我已经掌握的语言 Python。它的使用非常简单轻松；我们也能很直观地了解它的指令、函数和每个模块之间的链接方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Keras 是一个非常高层的库，可以工作在 Theano 和 TensorFlow（可以配置）之上。另外，Keras 强调极简主义——你只需几行代码就能构建一个神经网络。在这里你可以比较一下 Keras 和 TensorFlow 实现相同功能时所需的代码：https://gist.github.com/ricgu8086/0ba44ce3aab19ec50425383a4d778b50&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Lasagne&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://lasagne.readthedocs.io/en/latest/index.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lasagne 是一个工作在 Theano 之上的库。它的使命是简化一点深度学习算法之下的复杂计算，同时也提供了一个更加友好的接口（也是 Python 的）。这是一个老牌的库，并且很长时间以来它都是一个扩展能力很强的工具；但在我看来，它的发展速度赶不上 Keras。它们的适用领域都差不多，但 Keras 有更好的文档、也更完整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Caffe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://caffe.berkeleyvision.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Caffe 不只是最老牌的框架之一，而是老牌中的老牌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我看来，Caffe 有非常好的特性，但也有一些小缺点。起初的时候它并不是一个通用框架，而仅仅关注计算机视觉，但它具有非常好的通用性。在我们实验室的实验中，CaffeNet 架构的训练时间在 Caffe 中比在 Keras 中（使用了 Theano 后端）少 5 倍。Caffe 的缺点是它不够灵活。如果你想给它来一点新改变，那你就需要使用 C++ 和 CUDA 编程，不过你也可以使用 Python 或 Matlab 接口进行一些小改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Caffe 的文档非常贫乏。你需要花大量时间检查代码才能理解它（Xavier 初始化有什么用？Glorot 是什么？）。Caffe 的最大缺点之一是它的安装。它需要解决大量的依赖包……我曾经安装过 Caffe 两次，真正痛苦至极。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但要清楚，Caffe 并不是一无是处。在投入了生产的计算机视觉系统的工具上，Caffe 是无可争议的领导者。它非常稳健非常快速。我的建议是：用 Keras 进行实验和测试，然后迁移到 Caffe 中进行生产。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DSSTNE&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://github.com/amznlabs/amazon-dsstne&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DSSTNE 的发音同 Destiny，是一个酷劲十足的框架却总是被忽略。为什么？除去其他的因素不谈，原因在于这个框架不具有普适性，不是为一般常见任务所设计的。DSSTNE 框架只做一件事——推荐系统，但把这件事做到了极致。既不是为研究而设计，也不是为测试 idea 而设计（来源其官方网站的宣传语），DSSTNE 框架是为量产而设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已在 BEEVA 上做一些实验测试了，目前我已经感觉到这是一个运行非常快的工具并且能够得到非常好的运行结果（平均准确率均值——mAP 很高）。为了达到这一速度，DSSTNE 框架用 GPU 运行，这也是它的弊端之一：不同于篇中分析的其他框架或者库，这个框架不支持使用者随意在 CPU 和 GPU 中切换，而这可能会对有些尝试有用，但我们在 DSSTNE 里做这样的尝试时是不被框架所允许的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其他的感受就是迄今为止 DSSTNE 还不是一个足够成熟的项目，而且它封装的太严密了（「black box」）。如果我们想深入了解这个框架的运行机制是什么，我们必须且只能去看它的源码，并且你需要完成很多必须完成的设置（「TODO」）才可以看到。同时，关于这个框架的在线教程不多，而能让开发者进行操作尝试的指导就更少了。我的意见是再等 4 个月看看 DSSTNE 的最新版本。不能不说 DSSTEN 的确是一个很有意思的项目但还需要一点成长空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还想说明一点，这个框架对编程能力没有要求。DSSTNE 框架通过其终端的命令行来执行相关操作。到目前为止，很多我知道也很流行的框架和库我还没有用过，我不能给出更多具体的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Torch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：http://torch.ch/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个世界上每天仍有很多战争，但是一个优秀的「勇士」（西班牙语「Guerrero」）必须熟知哪些战争是需要去参加作战的，哪些是可以选择不参与的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Torch 是一个很著名的框架，因巨头 Facebook 的人工智能研究所用的框架是 Torch，并且在被谷歌收购之前 DeepMind 也是用的 Torch（收购之后 DeepMind 转向了 TensorFlow）。Torch 的编程语言是 Lua，这就是我刚才所谈的「战争」的具体所指。在目前深度学习编程语言绝大部分以 Python 实现为主的大趋势下，一个以 Lua 为编程语言的框架的最大劣势莫过于此。我从未用使用过这个语言，如果我想使用 Torch 这个工具，毫无疑问我需要先学习 Lua 语言然后才能使用 Torch。这固然是一个合理的过程，但就我个人情况来说，我偏向于用 Python、Matlab 或者 C++的实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MXNet&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://github.com/dmlc/mxnet&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mxnet 是一个支持大多数编程语言的框架之一，包括 Python，R，C++，Julia 等。但我觉得使用 R 语言的开发者会特别偏爱 mxnet，因为至今为止还是 Python 以不可置疑的态势称霸深度学习语言的（Python 与 R 的对决，猜猜我会站哪边？:-p）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;老实说，在此之前我并没有很关注 mxnet。但是当亚马逊 AWS 宣布选择 mxnet 作为其深度学习 AMI 的库时触发我开始关注 mxnet。我必须去了解一下。后来我获知亚马逊把 mxnet 列为其深度学习的参考库并宣称其巨大的横向扩展能力。我感觉到这里面有一些新的改变发生而且我必须深入了解。这也是为什么我们 2017 的 BEEVA 的技术测试名单里有 mnxet 的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我对多 GPU 的扩展能力有点疑虑并且我很原意去了解这样实验的更多细节，但目前我还是对 mxnet 持怀疑态度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DL4J&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://deeplearning4j.org/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我接触这一库，是因为它的 documentation。当时我正在寻找受限玻尔兹曼机、自编码器，在 DL4J 中找到了这两个 documentation。里面的文件很清楚，有理论，有代码案例。我必须得说 DL4J 的 documentation 简直是艺术品，其他库在记录代码的时候需要向它学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DL4J 背后的公司 Skymind 意识到，虽然在深度学习圈内 Python 是老大，但大部分程序员起自 Java，所以需要找到一个解决方案。DL4J 兼容 JVM，也适用 Java、Clojure 和 Scala，随着 Scala 的起起落落，它也被很多有潜力的创业公司使用，所以我还会继续紧追这个库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，Skymind 的 twitter 账户非常活跃，不断公开最新的科学论文、案例和教程，及其推荐大家关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cognitive Toolkit&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://github.com/Microsoft/CNTK&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;认知工具包（Cognitive Toolkit）之前被大家所知的缩略是 CNTK，但是最近又重命名回归到 Cognitive Toolkit，很可能是想沾最近微软认知服务（Microsoft Cognitive services）的光。在公开的基准测试上的表现来看，这个工具似乎很强劲，支持纵向和横向的推移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前为止，Cognitive Toolkit 似乎不是很流行。我并没有读到很多关于使用这个库的博客、在线实验案例或者在 Kaggle 里的相关评论。但是对我来说，一个背靠微软研究的框架特别强调自己的推移能力让我觉得有些奇怪，毕竟微软研究团队可是在语音识别上打破世界纪录并逼近人类水准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我在查看他们项目百科的一个范例的时候了解到 Cognitive Toolkit 在 Python 上的语法和 Keras 是非常相类似的（Cognitive Toolkit 也支持 C++），这不禁让我在想（并不是确认）Keras 才是正确的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的结论是：如果你想进入这一领域，你应该首先学习 Python。尽管这一领域还支持其它很多语言，但 Python 是应用范围最广而且最简单的一个。但是为什么要选择 Python 呢——毕竟 Python 速度这么慢？因为大多数的库都使用的是符号式语言（symbolic language）方法而非命令式语言（imperative language）方法。解释一下也就是说：不是一条接一条地执行你的指令，而是根据你给出的所有指令创建一个计算图（computing graph）。这个图被内部优化和编译成可执行的 C++ 代码。这样你就能同时利用上两个世界的最优之处：Python 带来的开发速度和 C++ 带来的执行速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人们对深度学习的兴趣越来越大了，但人们并不愿意等待算法训练所需的大量计算时间（而且我说的是 GPU，想都不要想只使用 CPU）。这也是多 GPU 支持、多机器上的水平扩展甚至定制硬件最近开始得势的原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度学习领域非常活跃、易变。很可能我现在所说的在 2017 年的中旬就变了。我的建议是，如果你是初学者，使用 Keras，如果不是初学者，也可以使用它。如果你参加过 Kaggle 比赛，你肯定注意到了 Kaggle 的两大巨星：Keras 和 XGBoost。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;原文链接：&amp;nbsp;&lt;/span&gt;&lt;span&gt;https://medium.com/@ricardo.guerrero/deep-learning-frameworks-a-review-before-finishing-2016-5b3ab4010b06#.z8zuthuwm&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Wed, 04 Jan 2017 17:31:34 +0800</pubDate>
    </item>
    <item>
      <title>一图读懂JVM架构解析</title>
      <link>http://www.iwgc.cn/link/4197460</link>
      <description>&lt;p&gt;&lt;span&gt;本文阐述了JVM的构成和组件，配图清晰易懂，是学习Java开发者的入门必读文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个Java开发人员都知道字节码经由JRE（Java运行时环境）执行。但他们或许不知道JRE其实是由Java虚拟机（JVM）实现，JVM分析字节码，解释并执行它。作为开发人员，了解JVM的架构是非常重要的，因为它使我们能够编写出更高效的代码。本文中，我们将深入了解Java中的JVM架构和JVM的各个组件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虚拟机是物理机的软件实现。Java的设计理念是WORA（Write Once Run Anywhere，一次编写随处运行）。编译器将Java文件编译为Java .class文件，然后将.class文件输入到JVM中，JVM执行类文件的加载和执行的操作。请看以下的JVM架构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuialqalWoEk23CVV2t67okjt749UJZzK0kibfxNUCfkqsR87EgCvARcKpfI3ZAzFgNtU0a8IkwdB4FA/640?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;JVM是如何工作的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上面架构图所示，JVM分为三个主要子系统：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;类加载器子系统（Class Loader Subsystem）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运行时数据区（Runtime Data Area）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行引擎（Execution Engine）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 类加载器子系统&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java的动态类加载功能由类加载器子系统处理，处理过程包括加载和链接，并在类文件运行时，首次引用类时就开始实例化类文件，而不是在编译时进行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Boot Strap类加载器，Extension类加载器和Application（类加载器是实现类加载过程的三个类加载器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1) Boot Strap类加载器：负责从引导类路径加载类，除了rt.jar，它具有最高优先级；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) Extension 类加载器：负责加载ext文件夹（jre \ lib）中的类；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3) Application类加载器：负责加载应用程序级类路径，环境变量中指定的路径等信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的类装载器在加载类文件时遵循委托层次算法（Delegation Hierarchy Algorithm）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 链接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1) 验证（Verify）：字节码验证器将验证生成的字节码是否正确，如果验证失败，将提示验证错误；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2) 准备（Prepare）：对于所有静态变量，内存将会以默认值进行分配；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3) 解释（Resolve）：有符号存储器引用都将替换为来自方法区（Method Area）的原始引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3 初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是类加载的最后阶段，所有的静态变量都将被赋予原始值，并且静态区块将被执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 运行时数据区&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行时数据区可分为5个主要组件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1) 方法区（Method Area）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所有的类级数据将存储在这里，包括静态变量。每个JVM只有一个方法区，它是一个共享资源；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2) 堆区域（Heap Area）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;所有对象及其对应的实例变量和数组将存储在这里。每个JVM也只有一个堆区域。由于方法和堆区域共享多个线程的内存，所存储的数据不是线程安全的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3) 堆栈区（Stack Area）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于每个线程，将创建单独的运行时堆栈。对于每个方法调用，将在堆栈存储器中产生一个条目，称为堆栈帧。所有局部变量将在堆栈内存中创建。堆栈区域是线程安全的，因为它不共享资源。堆栈框架分为三个子元素：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;局部变量数组（Local Variable Array）：与方法相关，涉及局部变量，并在此存储相应的值&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;操作数堆栈（Operand stack）：如果需要执行任何中间操作，操作数堆栈将充当运行时工作空间来执行操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;帧数据（Frame Data）：对应于方法的所有符号存储在此处。在任何异常的情况下，捕获的区块信息将被保持在帧数据中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(4) PC寄存器（PC Registers）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每个线程都有单独的PC寄存器，用于保存当前执行指令的地址。一旦执行指令，PC寄存器将被下一条指令更新；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(5) 本地方法堆栈（Native Method stacks）：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;本地方法堆栈保存本地方法信息。对于每个线程，将创建一个单独的本地方法堆栈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.执行引擎&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分配给运行时数据区的字节码将由执行引擎执行，执行引擎读取字节码并逐个执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1) 解释器：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;解释器更快地解释字节码，但执行缓慢。解释器的缺点是当一个方法被调用多次时，每次都需要一个新的解释；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2) JIT编译器：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;JIT编译器消除了解释器的缺点。执行引擎将在转换字节码时使用解释器的帮助，但是当它发现重复的代码时，将使用JIT编译器，它编译整个字节码并将其更改为本地代码。这个本地代码将直接用于重复的方法调用，这提高了系统的性能。JIT的构成组件为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style=" max-width: 100%; color: rgb(62, 62, 62) ; ; ; ; ; ; ; ; ; ; ; ; "&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中间代码生成器（Intermediate Code Generator）：生成中间代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码优化器（Code Optimizer）：负责优化上面生成的中间代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;目标代码生成器（Target Code Generator）：负责生成机器代码或本地代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析器（Profiler）：一个特殊组件，负责查找热点，即该方法是否被多次调用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3) 垃圾收集器(Garbage Collector)：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;收集和删除未引用的对象。可以通过调用“System.gc（）”触发垃圾收集，但不能保证执行。JVM的垃圾回收对象是已创建的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java本机接口（JNI）：JNI将与本机方法库进行交互，并提供执行引擎所需的本机库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地方法库（Native Method Libraries）：它是执行引擎所需的本机库的集合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原文：The JVM Architecture Explained&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：Jackson Joseraj 翻译：Daisy 责编：仲培艺&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/640?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 04 Jan 2017 17:31:34 +0800</pubDate>
    </item>
    <item>
      <title>携程移动端性能优化</title>
      <link>http://www.iwgc.cn/link/4181253</link>
      <description>&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文为《程序员》原创文章，未经允许不得转载，更多精彩请订阅2017年《程序员》&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在《程序员》杂志 10 月刊作者发布了文章《携程移动端架构演进与优化之路》文章第一部分：架构演进，11 月份作者在 CSDN 上发布了《携程移动端 UI 界面性能优化实践》。此文章是在这两篇文章基础上进行总结的关于携程移动端性能优化的其他内容，包括 Hybrid 框架优化、网络优化、通信数据格式传输优化、内存优化、启动时间优化、React Native 优化等内容，接下来作者将从这几个角度进行详细展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Hybrid 框架优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 的 Hybrid 框架经过多个版本的迭代，支持强大的插件功能，已经做到凡是可用，通通使用 Native 组件来优化 Hybrid 业务的体验。携程 Hybrid 框架在设计之初即采用了离线包功能：Hybrid 业务整体打包在 App 中，节省了用户打开页面时的资源加载时间；同时离线包支持差分增量更新，并通过 7z 压缩方式进一步降低了增量更新包的大小，相对 Zip 压缩减少 30%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤离线组件包&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统 HTML5 页面的静态资源常常需要从远程服务器下载，造成移动环境下最昂贵的网络开销。不同于 HTML5，组件化 Hybrid 方案引入了组件包的概念，将业务需要的所有静态资源打包成一个组件包文件，并进行离线化版本管理，而且关于离线包的更新是采取增量差分升级更新的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在用户访问组件页面之前，组件框架通常默默地将最新业务组件包下载至客户端，用户访问组件页面时，WebView 加载的实际上均是本地页面和资源，大幅提升了页面加载性能。不仅如此，关键业务组件在携程客户端版本发布时会预置到 App 中，减少首次下载安装的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤WebView 预加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;影响页面加载速度的因素非常多，我们在对 WebView 加载一个网页的过程进行调试发现，每次加载的过程中都会有较多的网络请求。除了 Web 页面自身的 URL 请求，还会有 Web 页面外部引用的 JS、CSS、字体、图片等都是个独立的 HTTP 请求。这些请求都是串行的，加上浏览器的解析、渲染时间就会导致 WebView 整体加载时间变长，消耗的流量也对应地增多。所以为了加快 WebView 的整体加载时间，我们使用了预加载策略，将 JS、CSS、字体、图片等资源提前加载出来。Android 通过 WebView 自带的 API 即 setWebViewClient 中的回调接口 ShouldInterceptRequest 去实现资源的预加载。类似事例代码如图 1 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaicr9LicU7hEyiaDTLU5fjiaEy0lu9gqBplmv2kJfZiaDgfSjaFozNibTHYfw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 1 WebView 预加载资源&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;iOS 通过 setNeedsLayout 机制提前初始化下一个 UIwebView，将 HTML 文件初始化，然后捕获点击事件去动态刷新数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 网络请求是基于 TCP 和 HTTP 的混合请求，比如 Hybrid 页面就是通过直接发送 HTTP 请求。由于携程用户环境的复杂情况下 Hybrid 页面 HTTP 失败率在 3%左右，对于携程来说 4 个 9 的高可行性架构要求显然是不符合的，同时在 HTML5 页面使用 HTTP 服务容易发生 DNS 劫持现象。基于这些原因，提高服务的成功率是当时必须要推进而且是重中之重要推进的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们 Hybrid 网络性能优化通过 Hybrid 接口发送 Native 网络服务的方案替代 HTTP，其一是因为 Native 端的 TCP 长连接可以提高服务成功率，其二从安全角度可以避免 DNS 劫持。此外，针对携程海外用户的特点，我们也进行了海外网络性能优化，主要是通过 TCP 海外加速产品实现链路优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于携程 App 大部分网络服务主要基于 TCP 连接，为了将 DNS 时间降至最低，我们采取了动态 IP 优化策略算法，即内置了 Server IP 列表，该列表可以在 App 启动服务中下发更新。App 启动后的首次网络服务会从 Server IP 列表中取一个 IP 地址进行 TCP 连接，同时 DNS 解析会并行进行，DNS 成功后，会返回最适合用户网络的 Server IP，那么这个 Server IP 会被加入到 Server IP 列表中被优先使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，Server IP 列表是有权重机制的，DNS 解析返回的 IP 很明显具有最高的权重，每次从 Server IP 列表中取 IP 会取权重最高的 IP。列表中 IP 权重也是动态更新的，根据连接或服务的成功失败来动态调整，这样即使 DNS 解析失败，用户在使用一段时间后也会选取到适合的 Server IP。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了动态 IP 优化策略，携程还使用 TCP 替换 HTTP 请求服务，原因在于：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;携程用户有时会在网络环境非常差的景区使用，需要针对弱网进行特别的优化，单纯 HTTP 应用层协议很难实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP 请求首次需要进行 DNS 域名解析，我们发现国内环境下针对携程域名的失败率在 2-3%（包含域名劫持和解析失败的情况），严重影响用户体验。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;HTTP 虽然是基于 TCP 协议实现的应用层协议，优势是封装性好，客户端和服务端解决方案成熟。劣势是可控性小，无法针对网络连接、发送请求和接收响应做定制性的优化，即使是 HTTP 的特性如保持长连接 Keep Alive 或管道 Pipeline 等都会受制于网络环境中的 Proxy 或者服务端实现，很难充分发挥作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤Hybrid 网络服务优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 中有相当比例的业务是使用 Hybrid 技术实现的，运行在 WebView 环境中，其中的所有网络服务（HTTP 请求）都是由系统控制的，我们无法掌控，也就无法进行优化，其端到端服务成功率也仅有 97%左右（注：这里指页面中业务逻辑发送的网络服务请求，而非静态资源请求）。我们采用了名为“TCP Tunnel for Hybrid”的技术方案来优化 Hybrid 网络服务，和传统 HTTP 加速产品的方法不同，我们没有采用拦截 HTTP 请求再转发的方式，而是在携程 Hybrid 框架中的网络服务层进行自动切换。具体的架构图如图 2 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaI6CzO2SPah8JQ12Qotm6tcdia9ONog9Dm9BAVibPwXvLFlGbaSDlNzKg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 2 携程 Hybrid 网络请求转发图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图 2 可见，该技术方案的流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 App 支持 TCP Tunnel for Hybrid，Hybrid 业务在发网络服务时，会通过 Hybrid 接口转发至 App Native 层的 TCP 网络通讯层。该模块会封装这个 HTTP 请求，作为 TCP 网络服务的 Payload 转发到 TCP Gateway。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TCP Gateway 会根据服务号判断出是 Hybrid 转发服务，解包后将 Payload 直接转发至 HTTP Gateway，此 HTTP 请求对 HTTP Gateway 是透明的，HTTP Gateway 无需区分是 App 直接发来的还是 TCP Gateway 转发来的 HTTP 请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后端业务服务处理完成后，HTTP 响应会经 HTTP Gateway 返回给 TCP Gateway，TCP Gateway 将此 HTTP 响应作为 Payload 返回给 App 的 TCP 网络通讯层。 TCP 网络通讯层会再将该 Payload 反序列化后返回给 Hybrid 框架，最终异步回调给 Hybrid 业务调用方。整个过程对于 Hybrid 业务调用方也是透明的，它并不知道 TCP Tunnel 的存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用该技术方案后，携程 App 中 Hybrid 业务的网络服务成功率提升至 99%以上，平均耗时下降 30%，如图 3 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaTTL5Enk1Gd0avESFGysOe6VakRAtKtzxJJG0MobsqqKtFKzlVLUeKg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 3 携程 App TCP 和 HTTP 效果对比图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤携程 App 海外网络服务优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程目前没有部署海外 IDC，海外用户在使用 App 时需要访问位于国内的 IDC，服务平均耗时明显高于国内用户。我们采用了名为“TCP Bypass for Oversea”的技术方案来优化主要是使用了 Akamai 的海外专属网络通道，同时在携程国内 IDC 部署了局端设备，使用专用加速通道的方式来提升海外用户体验，如图 4 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riabat7SNgQCvEqia3HjGdzOQoJesEoLhTXrJusyMC6K9Xibiaf8xctpy3EA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 4 携程海外网络通道署图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;海外用户启动 App 后先通过 Akamai 定制域名获取 Server IP，所有网络服务优先走 Akamai 通道；如果 Akamai 通道的网络服务失败并且重试机制生效时，会改走传统 Internet 通道进行重试。相比只用传统 Internet 通道，在保持网络服务成功率不变的情况下，使用 Akamai 通道 Bypass 技术后平均服务耗时下降了 33%，如图 5 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riao7MQJeVC51Umex34UX65xH1Qsxdk87DQnbA3FpAFekIDCJAUnpndVQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 5 海外网络服务优化前后对比图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤携程 App 通信数据格式优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 原来使用了自定义的 SOTP 协议格式，底层采用 Socket TCP 协议，为了提高服务响应加载速度，我们优化了 TCP 服务 Payload 数据的格式和序列化/反序列化算法，从自定义 SOTP 格式转换到了 Protocol Buffer 数据格式。此外对数据格式进行了 Gzip 压缩，提升效果非常明显，我们使用 PB＋Gzip 后，数据大小下降了 76%，如图 6 和表 1 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaZOz8DonLrkZxnLRL4lFib17v0RibSZUM2yuiaKzKbWjtjtfjwaJn7ib1tw/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 6 数据序列化大小对比效果图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riarPDab48xSLSaPGTrqLcunub4RJ885gpib97ibj1RDdY5MAV9QjoHRWoA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表 1 数据序列化大小对比效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 PB+Gzip 的优势，我们目前基本上大部分服务都已经迁移到 PB 上来。另外 Facebook 曾分享过他们使用 FlatBuffer 提高性能的实践，可以参考 Facebook 开源的 Blog。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FlatBuffer 是 Google 为游戏平台开放的一个开源项目，它是 Protocol Buffer 的一种进化方案与实现，具有不需要反序列化就能够获取到任意子元素、保持元数据的优点，不需要打包/解包。它的结构化数据都以二进制形式保存，不需要数据解析过程，数据也可以方便传递。所以在性能上很有优势，但是后续我们分析后不太适合携程的业务场景因而最终没有使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤其他网络相关优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;弱网和网络抖动优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 引入了网络质量参数，通过网络类型和端到端 Ping 值进行计算，根据不同的网络质量改变网络服务策略：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调整长连接池个数：例如在 2G/2.5G Egde 网络下，会减少长连接池个数为 1（运营商会限制单个目标 IP 的 TCP 连接个数）；Wi-Fi 网络下可以增加长连接池个数等机制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态调整 TCP Connection、Write、Read 的超时时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不同网络类型状态切换连接机制：例如 Wi-Fi 和移动网络、4G/3G 切换至 2G 时，客户端 IP 地址会发生变化，已经连接上的 TCP Socket 注定已经失效（每个 Socket 对应一个四元组：源 IP、源 Port、目标 IP、目标 Port），此时会自动关闭所有空闲长连接，现有网络服务也会根据状态自动重试。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引入重试机制，提升服务成功率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;受 TCP 协议重传机制来保证可靠传输的机制启发，在应用层面也引入了重试机制来提高网络服务成功率。我们发现 90%以上的网络服务失败都是由于连接失败，此时再次重试是有机会连接成功并完成服务的；同时我们发现前面提到的网络服务生命周期处于建立连接、序列化网络请求报文、发送网络请求这三个阶段失败时，都可以自动重试，因为我们可以确信请求还没有到达服务端进行处理，不会产生幂等性问题（如果存在幂等性问题，会出现重复订单等情况）。当网络服务需要重试时，会使用短连接进行补偿，而不再使用长连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现了上述机制后，携程 App 网络服务成功率由原先的 95.3%+提升为如今的 99.5%+（这里的服务成功率是指端到端服务成功率，即客户端采集的服务成功数除以请求总量计算的，且不区分当前网络状况），效果显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤其他网络服务机制和技巧&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 也实现了其他一些网络服务机制方便业务开发，如网络服务优先级机制，高优先级服务优先使用长连接，低优先级服务默认使用短连接；网络服务依赖机制，根据依赖关系自动发起或取消网络服务，例如主服务失败时，子服务自动取消。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发过程中我们也发现一些移动平台上的 TCP Socket 开发技巧：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;iOS 平台上的原生 Socket 接口创建连接并不会激活移动网络，这里原生 Socket 接口是指 POSIX Socket 接口，必须使用 CFSocket 或再上层的网络接口尝试连接时才会激活网络。因此携程 App 启动时会优先激活注册一些第三方 SDK 以及发送 HTTP 请求来激活移动网络。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;合理设置 Socket 的几个参数：SO_KEEPALIVE 参数确保 TCP 连接保持（注：此 KeepAlive 是 TCP 中的属性，和 HTTP 的 KeepAlive 是两个场景概念），SO_NOSIGPIPE 参数关闭 SIGPIPE 事件，TCP_NODELAY 参数关闭 TCP Nagle 算法的影响。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 iOS 要求支持 IPv6-Only 网络，因此使用原生 Socket 必须支持 IPv6。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果使用 select 来处理 Non-blocking/IO 操作，确保正确处理不同的返回值和超时参数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保持 TCP 长连接可用性的心跳机制：对于非 IM 类应用而言，心跳机制的作用不大，因为用户会不断触发请求去使用 TCP 连接。尤其在携程业务场景下，通过数据统计发现使用心跳与否对服务耗时和成功率影响极小，因此目前已经关闭心跳机制。原先的心跳机制是 TCP 长连接池中的空闲 TCP 连接每 60 秒发送一个心跳包到 Gateway，Gateway 返回一个心跳响应包，从而让双方确认 TCP 连接有效。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤关于 SPDY 和 HTTP/2 协议的探讨&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过去两年我们的网络服务优化工作都是基于 TCP 协议实现的，基本达到了优化目标。不过这两年来新的应用层网络协议 SPDY 和 HTTP/2 逐步迈入主流，基于 UDP 的 QUIC 协议看起来也非常有趣，值得跟进调研。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SPDY 是 Google 基于 TCP 开发的网络应用层协议，目前已经停止开发，转向支持基于 SPDY 成果设计的 HTTP/2 协议。HTTP/2 协议的核心改进其实就是针对 HTTP/1.x 中影响延迟性能的痛点进行优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Header 压缩：压缩冗余的 HTTP 请求和响应 Header。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持 Multiplexing：在 HTTP/1.1 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞，而 HTTP 2.0 就是为了解决这个限制问题，采取多路复用技术，即支持一个 TCP 连接上同时实现多个请求和响应。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二进制分帧提高传输性能：在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等因素的情况下，应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层去提高传输效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;保持长连接（比 HTTP/1.x 更彻底）：减少网络连接时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持服务端推送：由服务端主动推送数据到客户端，同时可以缓存，也让在遵循同源的情况下，不同页面之间共享缓存资源成为可能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官方性能测试结果显示使用 SPDY 或 HTTP/2 的页面加载时间减少 30% 左右，不过这是针对网页的测试结果。对于 App 中的网络服务，具体优化效果我们还在进行内部测试，不过其优化手段和目前我们使用 TCP 协议的相类似，因此性能优化效果可能不会很显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过 HTTP2.0 正处于逐步应用到线上产品和服务的阶段，可以预见未来会有不少新的坑产生和与之对应的优化技巧，HTTP1.x 和 SPDY 也将在一段时间内继续发挥余热。作为工程师，需要了解这些协议背后的技术细节，才能打造高性能的网络框架，从而提升我们的产品体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程图片相关优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Android 系统中，当我们使用资源 ID 来去引用一张图片时，Android 会使用一些规则来帮我们匹配最适合的图片。什么叫最适合的图片？比如我的手机屏幕密度是 xxhdpi，那么 drawable-xxhdpi 文件夹下的图片就是最适合的。因此，当我引用这张图时，如果 drawable-xxhdpi 文件夹下有这张图就会优先被使用，在这种情况下，图片是不会被缩放的。系统就会自动去其它文件夹下找这张图，优先会去更高密度的文件夹下寻找。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们当前的场景就是 drawable-xxhdpi 文件夹，然后发现这里也没有这张图，接下来会尝试再找更高密度的文件夹，发现没有更高密度的了，就会去 drawable-nodpi 文件夹找，发现也没有，那么就会去更低密度的文件夹下面找，依次是 drawable-xhdpi→drawable-hdpi→drawable-mdpi→ drawable→ldpi。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体匹配规则就是如上所示，那么比如说我手机是 1080P，但是资源图片放在 drawable-xhdpi 文件夹下面，系统首先去 xxhpi 文件下去寻找发现没有找到，然后跑到更高密度夹 xxxhdpi 还是没找到，最后发现低密度文件夹 xhdpi 下有资源，于是系统自动帮我们做了这样一个 3/2 放大操作。同样的道理，如果系统是在 drawable-xxxhdpi 文件夹下面找到这张图的话，它会认为这张图是为更高密度的设备所设计的，如果直接将这张图在当前设备上使用就有可能会出现像素过高的情况，于是会自动帮我们做一个缩小的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前市场上主流机型是 1080P，所以美工切图以 1080P 为基准切一套图，直接将这一套图放在 xxhdpi 文件夹下面即可，即如果你的机子是主流机型 1080P 分辨率，则图片资源不会做任何缩放，但如果你的机子是 720P（xhdpi），则图片资源会做 2/3 倍的扩大，其实际占用内存会变小，同时资源不会被放大变形；同理如果是 480P（hdpi），则图片资源会做 2/4 倍的扩大，即图片大小缩放为原来的 1/2，实际占用内存同上所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将资源图片放到正确的位置，能帮 App 去优化节省内存，提升用户体验，所以在开发过程中，资源图片不要任意放置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程做了一件事情，就是将图片资源位置进行了正确整理，如原来放错位置的 xhdpi/hdpi/mdpi 资源全部迁移到 xxhpi 文件夹下面，并且删除了原来的多套图资源，只是在特殊的界面适配比如 Pad 适配，才会特殊处理。这样做的结果是直接减少内存 20%，Apk Size 减少了 20% 左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，为了减少 App Size，除了删除多套图资源和无用的资源，我们在图片优化上，还使用了 SVG 矢量图、WebP 格式的图片替换原始的 PNG。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片是携程 App 使用场景中较多的元素之一，如何快速节省流量的下载和渲染图片是我们非常关注的性能问题。除了上面提到的网络优化长连接，携程还实现了 App 的动态切图技术，动态下发 WebP 格式图片：主要是基于分辨率、质量、锐化、格式四个纬度，对同一张图片生成了不同组合的文件，设置了一系列匹配规则，针对不同屏幕、机型处理能力、网络环境，配置出适合当前情况的图片大小质量，保证图片大小既节省又确保用户视觉体验。其图片加载流程如图 7 所示，最终携程的优化效果：图片下载大小减少 58%，下载耗时降低 50%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riavrVibic8ib1WSR9wLyOmUZmjge28MCYzTC21VSuicwzCKkE6PdyEeC6MzA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 7 携程图片加载流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在图 7 中，图片加载流程有个域名收敛机制，为什么需要域名收敛？首先它是相对于域名发散技术的，是因为浏览器对同一域名做了最大连接数限制，所以为了让浏览器并发加载而做发散，缺点是域名过多会引起 DNS 解析耗时。域名收敛就是为了解决 DNS 解析耗时问题，以加快图片下载速度从而提升用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程地图优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程国内地图最早接入的是高德地图，后来才接入百度地图，但是它们海外支持较差，很多城市没有数据支持，iOS 用户相对还好解决，因为苹果在国内的合作厂商是高德，所以当时 iOS App 无论国内外都是直接使用苹果自带的地图。但是 Android App 海外地图相对没有好的解决方案，本来 Android 海外地图直接集成 Google 地图 Native SDK 即可。但是因为国内用户无法访问 Google 的服务，所以这种方案直接就舍弃，后来就直接采用 Google 海外版的 JS 方案，基于 Google JS 地图 API，开发了 Hybrid 版的 Google 地图，最终效果图如图 8 和图 9 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaibw9qVjrTZd4pyOLoAow5Z9KjfWHicickLXXfTicFNzNlBr84ae6tV6dtQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 8 携程海外详情地图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaWHkGdha4icCEtkGUosEneAicRVz3Ujxv7PlUZrb4j4sAhftXbQyuVolg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 9 携程海外列表地图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google JS 地图的域名服务因为大陆不稳定，所以携程对于 JS 域名服务做了一个简单优化，在国内的优先使用香港域名服务，如果访问不通，再使用海外域名服务；在海外的用户则优先使用 Google 海外域名服务，保证了海外地图稳定的服务以及良好的用户体验。此外地图的其他方面优化，比如数据做分段加载，以及数据的缓存机制，WebView 单独 WebCore 的优化，提前预加载数据和 JS 资源等优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App 启动内存优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个章节主要是针对携程 App Android 平台上做的插件内存优化。携程目前有多个不同的事业部，主要由酒店、机票、火车票、汽车票、旅游等组成，每个事业部都独立开发。其开发的 Bundle 就是一个独立插件，开发过程中不相互依赖，Android 最终集成阶段会单独生产一个 APK，目前携程 App 由 30 多个 Bundle 业务插件组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启动 App 时，为了优化内存，不直接将所有的 Bundle 插件而是将每个事业部的核心 Bundle dex 文件加载进来，其他插件实现 Lazy-loading 即按需加载机制。为了实现 Lazy-loading 加载速度，直接将 Bundle 优化到更加地细粒度（其加载时间尽量不超过 500ms），这样直接加快 App 启动速度，并节省 App 内存，其优化的效果如图 10 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaiaLqNmgYSJGADjKHylILgpOiczMWZ6FdoxXUxbxGrbQiapR08q0HbW7Zg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 10 Android App 安装启动时间对比效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过优化后，App 启动时间提升明显。关于内存优化，携程 App 还从图片占用内存、轻量级数据结构、内存泄露等角度进行了优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 React Native 优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程 App 从 12 年开始开发，至今已有 4 年多时间，随着各项业务功能的全面移动化，以及公司“Mobile First”策略的指引下，App 功能愈加丰富和复杂，从而造成 App iOS Size 达到将近 100MB。而同样功能，使用 RN 开发，Size 远远小于 Native 开发，RN 的引入，可以支持我们 App 的可持续健康发展。此外由于 RN 通过 Java Core 解析 Java 模块转换成原生 Native 组件渲染，相比 H5 页面不再局限于 WebView、渲染性能长足提升，运行用户体验比 H5 提升明显可以媲美 Native，且 RN 支持跨平台和动态更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述原因，携程从 16 年 4 月份开始，在 App 内部开始小范围使用 React Native 技术，主要是基于 RN 0.28 定制 CRN，App V6.17 版本中实现站内信、机票低价订阅，之后开始较大规模地在各个 BU 事业部推广，有 15 个业务模块在使用，涉及到的页面在 50 个以上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ListView 是我们大量使用的控件，所以需要重点优化，原生控件超出屏幕的条目，依然被渲染了。没有实现 cell 重用，导致数据量大时会出现卡顿现象。为了提高用户体验，具体优化思路是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们基于原生控件开发了可重用 cell 的 CRNListView，iOS 借鉴了第三方的 ReactNativeTableView 的实现，开发了可重用 cell 的 ListView，接口和官方原生的基本一致。Android 借鉴 iOS 的方案，采用 RecyclerView 实现了类似的可重用 cell 的 ListView，同时我们还做了一些扩展，把常用的下拉刷新，载入更多，右侧字母索引栏等功能，都增加了进去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际测试下来，当数据量少时，和 RN 官方提供的 ListView 性能基本一致，但数据量大时，CRNListView 优势明显，如图 11 是我们在 Android 上的测试数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riauGOjPwQyjfq4sjtoOKvYeaZQSm8Qwyl9C4PjIrfKJexCknaB9ibBspw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 11 前后对比效果图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RN 页面加载最大的瓶颈在 JS Init + Require，这块就是 JSBundle 的执行时间。为了提升页面加载速度，要想办法优化。基于此原因，我们对 RN 官方的打包脚本做改造，将框架代码拆分出来，让所有业务使用一份框架代码，即拆分成 Common.js 和 Business.js。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般 RN 框架部分文件（Common.js）大小比较大，占用了绝大部分的 JS 执行时间。如果这部分执行加载时间能放到后台预先做完，进入业务也只需执行业务页面的几个 JS 文件，将可以大大提升页面加载速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照这个思路，能后台加载的 JS 文件, 实际上就是一个 RN App。因此我们设计了一个空白页面的 Fake App，用来监听要显示的真实业务 JS 模块，收到监听后，渲染业务模块最终显示页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App 其他角度优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从减少频繁 I/O 角度，及自身业务出发，去除若干初始化阶段不必要的文件操作，以及将若干非实时性要求的文件操作延后处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Android 上对于频繁读写数据库 SharedPreference 以及文件的模块，通过增加缓存和降低采样率等手段减少对 I/O 的读写。对于 SharedPreference 进行了专门的优化，减少单个文件的大小，将毫无联系的存储键值分开到不同文件中，并且防止将大数据块存储到 SharedPreference 中，这样既不利于性能也不利于内存，因为 SharedPreference 会有额外的一份缓存长期存在。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于多线程治理：我们分析了各个模块的线程数量，检查线程池的合理性。通过去掉不必要的线程和线程池，再控制线程池的并发数和优先级。进一步通过框架层的线程池来接管业务方的线程使用，以减少线程太多的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;检测超时方法，优化主线程：在早期版本性能优化前，初始化代码都在主线程中执行，为了优化性能，我们已经将部分比较耗时的初始化任务放入后台线程或者异步执行。但是随着携程业务的不断发展和人员变更，还是出现了在主线程中执行很重的初始化任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Android 平台通过开启 StrictMode 去检测优化，StrictMode 主要检测两大问题，一个是线程策略，即 TreadPolicy，另一个是 VM 策略，即 VmPolicy。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ThreadPolicy 线程策略检测的内容有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自定义的耗时调用使用 detectCustomSlowCalls() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;磁盘读取操作使用 detectDiskReads() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;磁盘写入操作使用 detectDiskWrites() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络操作使用 detectNetwork() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;VmPolicy 虚拟机策略检测的内容有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Activity 泄露使用 detectActivityLeaks() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;未关闭的 Closable 对象泄露使用 detectLeaked ClosableObjects() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;泄露的 SQLite 对象使用 detectLeakedSqlLiteObjects() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;检测实例数量使用 setClassInstanceLimit() 开启。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开启 StrictMode 之后，我们将日志输入到 SD card 面，在开发 Debug 阶段导出来可以通过日志分析找出对应的问题和原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;iOS 平台我们实现了一套应用运行时方法耗时检测机制，能够对应用中所有类的方法调用做耗时统计。方便地找到超时的方法调用后，就可以有针对性地做出修改，或删除或异步化。这种方法调用耗时检测机制同样适用于 App 运行过程中，从而找到导致应用卡顿的根本原因，最后做出对应修改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App 性能衡量考察&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;衡量一个 App 性能和质量，首先需要了解 App 性能的现状，即 App 端性能的采集。常规的技术方案有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用第三方性能采集 SDK，例如 OneAPM、听云等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自主研发：携程为了完整掌握用户数据采用了自己研发的方式：App 通过日志 SDK 采集日志包括行为埋点和性能埋点，上传至日志服务端，日志消息经 Kafka 消息队列存入 HDFS（RCFile 格式）分布式文件存储系统，后期的数据查询均基于 Hive 系统来实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;App 端的性能数据会在多种纬度（操作系统、App 版本、网络状况、位置）下采集网络（网络服务成功率、平均耗时、耗时分布等）、定位（经纬度成功率、城市定位成功率等，见图 12）、启动时间、内存流量等各类指标。其中像网络服务性能是对于用户体验至关重要的端到端性能，也是优化的核心依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaMgVyLKnO5MNkkznpORoqB9SRSc2TJnaUZFmGg9wvibWbgOiaH3DJGibEw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 12 携程城市定位成功率&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能数据采集后需要采用简单直观的 Portal 进行展示，携程为无线业务开发了 Web 端和 App 端性能展示 Portal，图 13 和图 14 是网络性能监控的截屏，数据会每小时进行更新聚合并展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6ria863ArcY2NicDKljicl5jAAnXVskGCtKHBANjjuzTU6eqQYe19CXSSkqw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 13 网络服务性能监控工具展示界面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riav0eg6ZQwCFVfhFVRGFnJ2e37UkYL1pv3gmcAKpzEEQWHVcWibx5RksA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 14 网络服务成功率展示界面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;➤携程 App 其他相关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于 3.x 架构的基础上，携程插件 Bundle 自动化打包平台也应运而生，各 BU 只需要关注自己 BU 的 Bundle 即可，同时开发直接将最新的代码集成到 Bundle 中，打一个最新 Bundle，然后测试也可以自己随时打包，携程无线为我们开发了 MCD 打包平台，可以让整个打包流程自动化，同时这个平台还提供了 HotFix 发布平台、App 应用性能管理、App Crash 数据采集等工具，同时可以实现 Daily/Hourly Build，无缝集成自动化测试，集成了 Sonar 代码扫描去检测重复代码等和 infer null pointer，然后能生成一个代码健康度扫描报告，并能帮助分析和解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;携程 App Size 优化相关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过脚本或第三方工具检测删除无用的资源、类、函数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 Sonar 检测整个 App 中的重复代码，将重复代码合并或 App 删除；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清理第三方引入的库，删除不用的多套库，比如百度和高德地图 SDK 等，多套图片库等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不轻易引进第三方的库，比如注解框架等，慎重使用第三方定义的控件，自己自定义控件去实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于资源图片统一经过 tinpng 压缩；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;资源图片统一整理，功能和资源统一，不重复造轮子，删除原来的多套资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;资源图片使用 SVG 或者 WebP 格式图片去替换；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清理高清资源大图片，特别是超过 10K 以上的图片；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;能用代码去实现的 UI，尽量不用去图片代替；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Native 转 H5；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Native 或者 H5 转 React Native；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hybrid 页面离线的 JS 资源，直接转换成 RN，减少包大小比较明显。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着移动端技术的不断成熟发展，以及各公司业务的成熟稳定发展，App 性能优化成为各大公司重点关注的问题，目的就是为了提升用户的使用体验。性能优化是一个持续发展的实践课题，可以持续贯穿于我们日常的开发工作中，即随着手机机型的日益碎片化，程序功能的复杂化多样化，总之移动端技术的性能优化是没有尽头的，我们会继续持续关注移动端的性能优化，并融入新的技术进行迭代更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;移动端技术发展很快，携程也正在积极尝试新技术，例如 React Native（已在线上很多模块的信息页面使用，如机票和酒店的部分页面），同时携程基于 RN 推出了自己的 RN 框架 Moles，并且做了不少相关 RN 实践性能优化。同时关于新的网络协议 SPDY、HTTP/2.0，Apple/Huawei/Samsung Watch App 等都做了大量尝试，以期能够提升产品品质。在过去几年时间里，我们已经实现了不少新技术与业务的融合，在这简单列举几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: disc;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;推出了基于 React Native 的 Moles 框架，并且做了很多 RN 相关优化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Bundle 差分升级更新；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 MVP 和 AOP 的框架设计；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;率先支持 Apple/Huawei/Samsung Watch App；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 FreelLine 和 LayoutCast 的热部署方案；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持 SPDY，HTTP2.0 的探讨实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来我们会不断推进新技术的研究并且融合到业务需求中，希望有更多优质内容分享给行业同行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从之前持续不断的性能优化中，我们虽然积累了不少优化经验，但是在 Android 平台部分，较低端低配置机型上携程 App 性能问题依然不容乐观，所以接下来会继续努力通过更多更细致的优化方案来提升用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来我们基于之前积累的历史优化经验会形成一套性能优化的经验闭环，由观察问题现象到分析原因、建立监控，定下量化目标，执行优化方案，验证结果数据再回到观察新问题。每一次闭环只能解决部分问题，不积硅步无以至千里，不积小溪无以成江海，只有不断抓住细微的优化点持续“啃”下去，才能得到螺旋上升的良好结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章最后，感谢陈浩然、赵辛贵之前提供给我的相关框架资料。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者简介： 南志文，时任携程研发经理，曾负责携程 App 整体技术框架的架构研发与实践，酒店业务的迭代更新及 App 架构、性能优化，先后就职于阿里巴巴、巨人网络等。&lt;/span&gt;&lt;span&gt;责任编辑： 唐小引，技术之路，共同进步，欢迎技术投稿、约稿、给文章纠错，请发送邮件至tangxy@csdn.net。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/0?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Tue, 03 Jan 2017 17:21:22 +0800</pubDate>
    </item>
    <item>
      <title>基于Spark的公安大数据实时运维技术实践</title>
      <link>http://www.iwgc.cn/link/4181254</link>
      <description>&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文为&lt;span&gt;《程序员》&lt;/span&gt;原创文章，未经允许不得转载，更多精彩请&lt;span&gt;订阅2017年《程序员》&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公安行业存在数以万计的前后端设备，前端设备包括相机、检测器及感应器，后端设备包括各级中心机房中的服务器、应用服务器、网络设备及机房动力系统，数量巨大、种类繁多的设备给公安内部运维管理带来了巨大挑战。传统通过ICMP/SNMP、Trap/Syslog等工具对设备进行诊断分析的方式已不能满足实际要求，由于公安内部运维管理的特殊性，现行通过ELK等架构的方式同样也满足不了需要。为寻求合理的方案，我们将目光转向开源架构，构建了一套适用于公安行业的实时运维管理平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;实时运维平台整体架构&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据采集层：Logstash+Flume，负责在不同场景下收集、过滤各类前后端硬件设备输出的Snmp Trap、Syslog日志信息以及应用服务器自身产生的系统和业务日志；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据传输层：采用高吞吐的分布式消息队列Kafka集群，保证汇聚的日志、消息的可靠传输；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据处理层：由Spark实时Pull Kafka数据，通过Spark Streaming以及RDD操作进行数据流的处理以及逻辑分析；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据存储层：实时数据存入MySQL中便于实时的业务应用和展示；全量数据存入ES以及HBase中便于后续的检索分析；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务服务层：基于存储层，后续的整体业务应用涵盖了APM、网络监控、拓扑、告警、工单、CMDB等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体系统涉及的主要开源框架情况如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUCxQlfrLsDBQzBKJAE0rr79cU50QibP7LgTnaL6MmnO4Y8Kwp4AA6ia1AA/640?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，整体环境基于JDK 8以及Scala 2.10.4。公安系统设备种类繁多，接下来将以交换机Syslog日志为例，详细介绍日志处理分析的整体流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUC4CWXd63Zf4lUsK4YTiazQTBCahNKq6ickkx2HxaqSKfV37n60TNGKVfg/640?wx_fmt=png"/&gt;&amp;nbsp;图1&amp;nbsp;&amp;nbsp;公安实时运维平台整体架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Flume+Logstash日志收集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Flume是Cloudera贡献的一个分布式、可靠及高可用的海量日志采集系统，支持定制各类Source（数据源）用于数据收集，同时提供对数据的简单处理以及通过缓存写入Sink（数据接收端）的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Flume中，Source、Channel及Sink的配置如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;# 为该Flume Agent的source、channel以及sink命名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sources = r1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks = k1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.channels = c1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 配置Syslog源&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sources.r1.type = syslogtcp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sources.r1.port = 5140&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sources.r1.host = localhost&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Kafka Sink的相关配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.topic = syslog-kafka&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.brokerList = gtcluster-slave01:9092&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.requiredAcks = 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.batchSize = 20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.channel = c1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Channel基于内存作为缓存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.channels.c1.type = memory&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.channels.c1.capacity = 1000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.channels.c1.transactionCapacity = 100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 将Source以及Sink绑定至Channel&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sources.r1.channels = c1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1.sinks.k1.channel = c1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;该配置通过syslog source配置localhost tcp 5140端口来接收网络设备发送的Syslog信息，event缓存在内存中，再通过KafkaSink将日志发送到kafka集群中名为“syslog-kafka”的topic中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Logstash来自Elastic公司，专为收集、分析和传输各类日志、事件以及非结构化的数据所设计。它有三个主要功能：事件输入（Input）、事件过滤器（Filter）以及事件输出（Output），在后缀为.conf的配置文件中设置，本例中Syslog配置如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;# syslog.conf&lt;br/&gt;input {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Syslog {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;port =&amp;gt; "514"&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;}&lt;br/&gt;filter {&lt;br/&gt;}&lt;br/&gt;output {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;kafka {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bootstrap_servers =&amp;gt; "192.168.8.65:9092"&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;topic_id =&amp;gt; "syslog-kafka"&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;compression_type =&amp;gt; "snappy"&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;codec =&amp;gt; plain {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;format =&amp;gt; "%{host} %{@timestamp} %{message}"&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Input（输入）插件用于指定各种数据源，本例中的Logstash通过udp 514端口接收Syslog信息；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Filter（过滤器）插件虽然在本例中不需要配置，但它的功能非常强大，可以进行复杂的逻辑处理，包括正则表达式处理、编解码、k/v切分以及各种数值、时间等数据处理，具体可根据实际场景设置；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Output（输出）插件用于将处理后的事件数据发送到指定目的地，指定了Kafka的位置、topic以及压缩类型。在最后的Codec编码插件中，指定来源主机的IP地址（host）、Logstash处理的时间戳（@timestamp）作为前缀并整合原始的事件消息（message），方便在事件传输过程中判断Syslog信息来源。单条原始Syslog信息流样例如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;147&amp;gt;12164: Oct&amp;nbsp;&amp;nbsp;9 18:04:10.735: %LINK-3-UPDOWN: Interface GigabitEthernet0/16, changed state to down&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Logstash Output插件处理后的信息流变成为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;19.1.1.12 2016-10-13T10:04:54.520Z &amp;lt;147&amp;gt;12164: Oct&amp;nbsp;&amp;nbsp;9 18:04:10.735: %LINK-3-UPDOWN: Interface GigabitEthernet0/16, changed state to down&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;其中红色字段就是codec编码插件植入的host以及timestamp信息。处理后的Syslog信息会发送至Kafka集群中进行消息的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Kafka日志缓冲&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Kafka是一个高吞吐的分布式消息队列，也是一个订阅/发布系统。Kafka集群中每个节点都有一个被称为broker的实例，负责缓存数据。Kafka有两类客户端，Producer（消息生产者的）和Consumer（消息消费者）。Kafka中不同业务系统的消息可通过topic进行区分，每个消息都会被分区，用以分担消息读写负载，每个分区又可以有多个副本来防止数据丢失。消费者在具体消费某个topic消息时，指定起始偏移量。Kafka通过Zero-Copy、Exactly Once等技术语义保证了消息传输的实时、高效、可靠以及容错性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Kafka集群中某个broker的配置文件server.properties的部分配置如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;########## Server Basics ###########&lt;br/&gt;# 为每一个broker设置独立的数字作为id&lt;br/&gt;broker.id=1&lt;br/&gt;&amp;nbsp;&lt;br/&gt;###### Socket Server Settings ######&lt;br/&gt;# socket监听端口&lt;br/&gt;port=9092&lt;br/&gt;&amp;nbsp;&lt;br/&gt;########### Zookeeper ##############&lt;br/&gt;# Zookeeper的连接配置&lt;br/&gt;zookeeper.connect=gtcluster-slave02:2181,gtcluster-slave03:2181,gtcluster-slave04:2181&lt;br/&gt;&amp;nbsp;&lt;br/&gt;# Timeout in ms for connecting to zookeeper&lt;br/&gt;zookeeper.connection.timeout.ms=3000&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中需指定集群里不同broker的id，此台broker的id为1，默认监听9092端口，然后配置Zookeeper（后续简称zk）集群，再启动broker即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Kafka集群名为syslog-kafka的topic：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;bin/kafka-topics.sh&lt;br/&gt;--create&lt;br/&gt;--zookeeper gtcluster-slave02:2181,gtcluster-slave03:2181,gtcluster-slave04:2181&lt;br/&gt;--replication-factor 3 --partitions 3&lt;br/&gt;--topic syslog-kafka&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Kafka集群的topic以及partition等信息也可以通过登录zk来观察。然后再通过下列命令查看Kafka接收到的所有交换机日志信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;bin/kafka-console-consumer.sh--zookeeper gtcluster-slave02:2181--from-beginning&lt;br/&gt;--topic Syslog-kafka&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;部分日志样例如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;10.1.1.10 2016-10-18T05:23:04.015Z &amp;lt;163&amp;gt;5585: Oct 18 13:22:45: %LINK-3-UPDOWN: Interface FastEthernet0/9, changed state to down&lt;br/&gt;19.1.1.113 2016-10-18T05:24:04.425Z &amp;lt;149&amp;gt;10857: Oct 18 13:25:23.019 cmt: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet1/0/3, changed state to down&lt;br/&gt;19.1.1.113 2016-10-18T05:24:08.312Z &amp;lt;149&amp;gt;10860: Oct 18 13:25:27.935 cmt: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet1/0/3, changed state to up&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Spark日志处理逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;Spark是一个为大规模数据处理而生的快速、通用的引擎，在速度、效率及通用性上表现极为优异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在Spark主程序中，通过Scala的正则表达式解析Kafka Source中名为“syslog-kafka” 的topic中的所有Syslog信息，再将解析后的有效字段封装为结果对象，最后通过MyBatis近实时地写入MySQL中，供前端应用进行实时地可视化展示。另外，全量数据存储进入HBase及ES中，为后续海量日志的检索分析及其它更高级的应用提供支持。主程序示例代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;object SwSyslogProcessor {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def main(args: Array[String]): Unit = {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 初始化SparkContext，批处理间隔5秒&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val sparkConf: SparkConf = new SparkConf().setAppName("SwSyslogProcessorApp ")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.set("spark.serializer", "org.apache.spark.serializer.KryoSerializer")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val ssc = new StreamingContext(sparkConf, Seconds(5))&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 定义topic&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val topic = Set("syslog-kafka")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 定义kafka的broker list地址&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val brokers = "192.168.8.65:9092,192.168.8.66:9092,192.168.8.67:9092"&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val kafkaParams = Map[String, String]("metadata.broker.list" -&amp;gt; brokers, "serializer.class" -&amp;gt; "kafka.serializer.StringDecoder")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 通过topic以及brokers，创建从kafka获取的数据流&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val swSyslogDstream = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ssc, kafkaParams, topic)&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val totalcounts = ssc.sparkContext.accumulator(0L, "Total count")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val lines = swSyslogDstream.map(x =&amp;gt; x._2)&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 将一行一行数据映射成SwSyslog对象&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lines.filter(x =&amp;gt; !x.isEmpty&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;amp;&amp;amp; x.contains("%LIN")&lt;br/&gt;&amp;amp;&amp;amp; x.contains("Ethernet")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.map(&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x =&amp;gt; {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SwSyslogService.encapsulateSwSyslog(x) // 封装并返回SwSyslog&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}).foreachRDD((s: RDD[SwSyslog], time: Time) =&amp;gt; {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 遍历DStream中的RDD&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!s.isEmpty()) {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 遍历RDD中的分区记录&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.foreachPartition {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;records =&amp;gt; {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!records.isEmpty) records.toSet.foreach {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;r: SwSyslog =&amp;gt; // 统计当前处理的记录总数&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;totalcounts.add(1L) // 保存SwSyslog信息到MySQL&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SwSyslogService.saveSwSyslog(r)&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;)&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//启动程序&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ssc.start()&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 阻塞等待&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ssc.awaitTermination()&lt;br/&gt;&amp;nbsp;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;整体的处理分析主要分为4步：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初始化SparkContext并指定Application的参数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建基于Kafka topic "syslog-kafka" 的DirectStream；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将获取的每一行数据映射为Syslog对象，调用Service进行对象封装并返回；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;遍历RDD，记录不为空时保存或者更新Syslog信息到MySQL中。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Syslog POJO的部分基本属性如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;@Table(name = "sw_syslog")&lt;br/&gt;public class SwSyslog {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 日志ID&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Id&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@GeneratedValue(strategy = GenerationType.IDENTITY)&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private Long id;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 设备IP&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Column(name = "dev_ip")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private String devIp;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 服务器时间&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Column(name = "server_time")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private String serverTime;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 信息序号&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Column(name = "syslog_num")&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private Long syslogNum;&lt;br/&gt;&amp;nbsp;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;……&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SwSyslog实体中的基本属性对应Syslog中的接口信息，注解中的name对应MySQL中的表sw_syslog 以及各个字段，MyBatis完成成员属性和数据库结构的ORM（对象关系映射）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;程序中的SwSyslogService有两个主要功能：&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;public static SwSyslog encapsulateSwSyslog(String syslogInfo) {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SwSyslog swsyslog = new SwSyslog();&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setDevIp(SwSyslogExtractorUtil.extractDevIp(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setServerTime(SwSyslogExtractorUtil.extractServerTime(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setSyslogNum(SwSyslogExtractorUtil.extractSyslogNum(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setDevTime(SwSyslogExtractorUtil.extractDevTime(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setSyslogType(SwSyslogExtractorUtil.extractSyslogType(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setInfoType(SwSyslogExtractorUtil.extractInfoType(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setDevInterface(SwSyslogExtractorUtil&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.extractDevInterface(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swsyslog.setInterfaceState(SwSyslogExtractorUtil&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.extractInterfaceState(syslogInfo));&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return swsyslog;&lt;br/&gt;}&lt;br/&gt;&amp;nbsp;&lt;br/&gt;public static void saveSwSyslog(SwSyslog swSyslog) {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("开始保存或更新SwSyslog", swSyslog);&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 根据ip查询所有Syslog&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;List&amp;lt;swsyslog&amp;gt; list = swSyslogMapper.queryAllByIp(swSyslog.getDevIp());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//&amp;nbsp;&amp;nbsp;如果list非空，即查到对应IP的SwSyslog&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (list != null &amp;amp;&amp;amp; !list.isEmpty()) {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (SwSyslog sys : list) {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 若IP的接口相同，则更新信息&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (sys.getDevInterface().equals(swSyslog.getDevInterface())) {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("有相同IP相同接口的记录，开始更新SwSyslog");&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setServerTime(swSyslog.getServerTime());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setSyslogNum(swSyslog.getSyslogNum());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setDevTime(swSyslog.getDevTime());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setSyslogType(swSyslog.getSyslogType());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setInfoType(swSyslog.getInfoType());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setInterfaceState(swSyslog.getInterfaceState());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sys.setUpdated(new Date());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslogMapper.update(sys);&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 若接口不同，则直接保存&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("相同IP无对应接口，保存SwSyslog");&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslog.setCreated(new Date());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslog.setUpdated(swSyslog.getCreated());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslogMapper.insert(swSyslog);&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// 没有对应的IP记录，直接保存信息&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOGGER.debug("没有相同IP记录，直接保存SwSyslog");&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslog.setCreated(new Date());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslog.setUpdated(swSyslog.getCreated());&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;swSyslogMapper.insert(swSyslog);&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;}&amp;lt;/swsyslog&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;encapsulateSwSyslog()将Spark处理后的每一行Syslog通过Scala的正则表达式解析为不同的字段，然后封装并返回Syslog对象；遍历RDD分区生成的每一个Syslog对象中都有ip以及接口信息，saveSwSyslog()会据此判断该插入还是更新Syslog信息至数据库。另外，封装好的Syslog对象通过ORM工具MyBatis与MySQL进行互操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;获取到的每一行Syslog信息如之前所述：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;19.1.1.12 2016-10-13T10:04:54.520Z &amp;lt;147&amp;gt;12164: Oct&amp;nbsp;&amp;nbsp;9 18:04:10.735: %LINK-3-UPDOWN: Interface GigabitEthernet0/16, changed state to down&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这段信息需解析为设备ip、服务器时间、信息序号、设备时间、Syslog类型、属性、设备接口、接口状态等字段。Scala正则解析逻辑如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote style="max-width: 100%; color: rgb(62, 62, 62); font-size: 16px; line-height: 25.6px; white-space: normal; widows: 1; box-sizing: border-box !important; word-wrap: break-word !important; background-color: rgb(255, 255, 255);"&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 抽取服务器时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 样例：2016-10-09T10:04:54.517Z&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* @param line&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* @return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def extractServerTime(line: String): String = {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val regex1 = "20\\d{2}-\\d{2}-\\d{2}".r&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val regex2 = "\\d{2}:\\d{2}:\\d{2}.?(\\d{3})?".r&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val matchedDate = regex1.findFirstIn(line)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val matchedTime = regex2.findFirstIn(line)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val result1 = matchedDate match {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case Some(date) =&amp;gt; date&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case None =&amp;gt; " "&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val result2 = matchedTime match {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case Some(time) =&amp;gt; time&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case None =&amp;gt; " "&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result1 + " " + result2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/**&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 抽取设备时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* 样例：Sep 29 09:33:06&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Oct&amp;nbsp;&amp;nbsp;9 18:04:09.733&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* @param line&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* @return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def extractDevTime(line: String): String = {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val regex = "[a-zA-Z]{3}\\s+\\d+\\s\\d{2}:\\d{2}:\\d{2}((.\\d{3})|())".r&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val matchedDevTime = regex.findFirstIn(line)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;val result = matchedDevTime match {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case Some(devTime) =&amp;gt; devTime&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case None =&amp;gt; " "&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;通过正则过滤、Syslog封装以及MyBatis持久层映射，Syslog接口状态信息最终解析如下：&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhpDbVpWiaWKMN0VlIGQlJUC2g4I00H1L1NkARzWia3eJiaNg5ZxFEibCVOoXqPic5AbzfxcHINGDYhgoA/640?wx_fmt=jpeg"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;最后，诸如APM、网络监控或者告警等业务应用便可以基于MySQL做可视化展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;本文首先对公安运维管理现状做了简要介绍，然后介绍公安实时运维平台的整体架构，再以交换机Syslog信息为例，详细介绍如何使用Flume+Logstash+Kafka+Spark Streaming进行实时日志处理分析，对处理过程中大量的技术细节进行了描述并通过代码详细地介绍整体处理步骤。本文中的示例实时地将数据写入MySQL存在一定的性能瓶颈，后期会对包含本例的相关代码重构，数据将会实时写入HBase来提高性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;作者：秦海龙，杭州以数科科技有限公司大数据工程师。Java及Scala语言，Hadoop生态、Spark大数据处理技术爱好者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;责编：郭芮，关注大数据领域，寻求报道或投稿请联系guorui@csdn.net。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/0?wx_fmt=jpeg"/&gt;&lt;br/&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Tue, 03 Jan 2017 17:21:22 +0800</pubDate>
    </item>
    <item>
      <title>总结｜2016年编程方面的主流趋势</title>
      <link>http://www.iwgc.cn/link/4181255</link>
      <description>&lt;p&gt;&lt;span&gt;TechCrunch在去年一月时曾发布过一篇&lt;/span&gt;&lt;span&gt;&lt;em style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;文章&lt;/em&gt;&lt;/span&gt;&lt;span&gt;，预测2016年编程方面的主要趋势，但软件开发的世界总是变幻莫测，很难明确预测到会有哪些全新的开发语言、框架以及工具出现。如今已是2017年伊始，之前的预测实现了多少呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最新版JavaScript的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015年6月，JavaScript/ECMAScript 6（即ECMAScript 2015或ES6）发布。根据之前的预测，在2016年JS语言将会获得广泛采用——这一预测基本实现。超过九成的主流浏览器，以及开源的JavaScript运行时Node.js都已兼容ES6。目前，不仅企业内部工具及不太重要的小型系统都有更多用到ES6语法，面对客户的主流系统也出现了更多ES6的痕迹，像Airbnb和谷歌这样不依赖旧版客户端的公司都在内部编程风格指南中明令要求使用ES6的语法。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，ES6并未在全球范围内普及，仍有一些开发者必须对老版的JS提供支持。一方面想要在程序中使用ES6注释，但仍有老版本浏览器客户需要维护的开发者们可以通过transpilers或者polyfills这样的工具，将ES6代码转为旧版语法。此外，某些ES6的功能尚未在所有JS环境中实现，比如正确的处理尾调用。这里有张&lt;/span&gt;&lt;span&gt;&lt;em style="max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"&gt;表格&lt;/em&gt;&lt;/span&gt;&lt;span&gt;，列出了目标平台是否兼容ES6的情况。老版的JavaScript不会一夕消失，但2016年间ES6的应用确实取得了很大的进展，希望来年再斩佳绩。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;后端即服务&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与预测一致，后端即服务（BaaS）在2016年间也有所增长。BaaS即通过第三方服务，执行项目中特定重复任务，比如云存储、推送通知等。有了这些服务的出色工作，开发者也更能专注于自身专业。由于前端框架不断发展，跟这些服务交互更加容易，因此后端API服务也在蓬勃发展。开发者也偏向采用整合技术，通过一些较小的应用组合成整体系统。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;简易的镜像管理与部署机制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如同预期那样，类似Docker和Packer这样的服务成为了许多开发团队的支柱。工程师可以运用这些服务，快速生成、复制被称为“容器”的机器镜像——其中捆绑有运行时、软件、系统工具及数据库等，确保在任何环境下都能快速运行起来。在一个带有预先版本控制的轻量级虚拟环境中构建项目的原型，再轻松将新版本部署到多台服务器上非常简单。手工配置服务器费时费力，因此被自动化取代也是可以预见的。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去年间相关的配置管理工具都在普及开来，包括Vagrant、Puppet、Chef和Ansible。使用以容器为基础的系统来工作成为了开发人员的基本技能，其大势所趋，不可阻挡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;增加对函数式编程语言的依赖&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似Haskell、Clojure、Scala等函数式编程语言在2016年间也逐渐热门起来，随着智能手机与联网设备的普及，为了在这些设备上获得更好的体验，服务器端语言也随之兴盛。随着计算机、平板电脑、智能手机和物联网小物件的日趋强大，服务器也成为了性能表现的瓶颈。目前发展方向就是：增进服务器性能，实现任务并行，并在与大量互联设备互动时获得更积极的响应。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大多函数式编程模型都是无状态的，也就是说无需复杂的同步，这些软件便能更简单、更高效地在不同的CPU内核或者机器上实现并行运行，函数式范式在执行类似网络请求这样的并行任务时具有天然优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Material Design和模式趋同&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年的视觉设计前端非常有趣，谷歌果然在系列产品中加入了更多的material design元素，涉及范围包括操作系统（ChromeOS、Android），应用（Chrome、Drive、Google Play Music），网站（YouTube、AdSense）甚至其网络搜索，从Slack、Twitter、Spotify、Airbnb以及Wikipedia等安卓应用，还有Asana、Geekbench等网站中都能看到material design的痕迹。不过除了Ubuntu有少量应用之外，其它平台无论是iOS、Tizen、Windows、MacOS，我们都未见到相关的应用。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其它平台的开发者也在努力推进相关平台的特定风格。预测到2017年，开发者会抛弃传统的设计风格，转向非视觉界面——Amazon Alexa、Siri、Cortana、Google Home等语音助手，或AR、VR等超视觉界面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年，软件开发方面出现了许多振奋人心的变化，我们预测在2017年，容器和函数式编程语言将获得广泛的采用，同时JavaScript语言将成为标准开发实践中更为核心的部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接： 2016’s top programming trends （编译/孙薇 责编/钱曙光）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;温馨提示：文中所有下划线部分均可阅读原文获取详情。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riakAD0e0pibwG8wrO3qbP5O2EZR7IQAvLJJjo7cAa4tGWZSPfuicNDYHrw/0?wx_fmt=gif"/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjX8cRiaTgvtibCyiaicEGUuc6riaJHic2zOwqWtdgNnLqPSlL5ok8ibCnnD3El9EjQYnG0LdCaD9otCg2wIg/0?wx_fmt=jpeg"/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;【长按识别立即关注】&lt;/strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&amp;nbsp;&lt;strong&gt;&lt;span&gt;品读之后，&lt;/span&gt;&lt;span&gt;愿有所获。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;</description>
      <pubDate>Tue, 03 Jan 2017 17:21:22 +0800</pubDate>
    </item>
    <item>
      <title>2016年OpenStack总结</title>
      <link>http://www.iwgc.cn/link/4103106</link>
      <description>&lt;blockquote style="line-height: 25.6px; white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;本文为《程序员》原创文章，未经允许不得转载，更多精彩请订阅2017年《程序员》。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenStack基本每年都会有很大的变化，2016年，也不例外。下面总结我所看到的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;巨头的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mirantis是OpenStack最显眼的巨头，它的一则新闻值得大家花心思去解读 （原文地址：http://www.zdnet.com/article/mirantis-openstack-the-good-news-and-the-bad-news/#ftag=RSSbaffb68），在收购了TCPCloud增强Kubernetes方面的能力之后，Mirantis对公司的人员配比做了调整，缩小原有研发型工程师（wind down a number of engineering investments）团队，而将重心转向了以运维为中心的OpenStack“建设－运维－交付”上（focus of delivering an operations-centric OpenStack distribution through a build-operate-transfer model）。这则新闻体现了两个问题，一是表明OpenStack已经趋于成熟，在主要的核心代码完成后，新增代码的边际效益已经降低，二是体现了OpenStack公司重点的专项，更注重服务、客户价值和交付，不再是简单的代码演进。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从企业的社区贡献，其实可以分析出它们在OpenStack投入的变化，根据Stackalytics统计分析，可以对比2015年到2016年人员上的投入变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGNXu3JwNxvzibSBobcHQQfIG6yL2wQlx8lPHmNial7adXemFfLlNa5o8w/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图1 部分OpenStack投入情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看到除了Rackspace之外，其他各大公司在OpenStack的投入上都有增加，HPE由于刚从HP拆分出来，投入变化比最大，但实际上HPE由于自身战略问题，可能明年会在OpenStack方向上有调整。Mirantis和Intel在2016年的两个版本也加大近一倍的人员投入，IBM和Radhat也有稳步的增长。其次是日本的两家公司NEC和Fujitsu，在OpenStack上面的投入也很大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenStack基金会为了加大OpenStack对企业的影响，也做出了很大的调整。从2017年开始，OpenStack的版本发布从以前的4月、10月，改成2月、8月，把OpenStack峰会拆分成两个会议，一个开发者会议PTG（Project Teams Gathering），在版本发布后，马上就举办，一个用户大会，在五月份举行，这样OpenStack企业，可以有3个月的时间来完善新的版本，用户可以在大会上看到和了解到最新版本的特性。看来OpenStack基金会时刻都在关注用户反馈，一切为了用户方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGrLbTxmnmOsthPrnppTXicT5m53U2duTicdByq57SLWDKTzWyZgxDrBdg/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图2 PTG和OpenStack Summit及版本发布时间表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;国内市场&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGw5gu9NibWpt1MibA1p3FHpkQH9WNBWPnw1z0iarWicH1RdhLLEF9E7t2HQ/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图3 OpenStack基金会黄金会员&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国内OpenStack市场热度在持续升温。随着今年新批准了7家中国企业成为OpenStack基金会黄金会员，黄金会员的24个席位里，1/3是国内企业，分别是华为、中国移动、中国电信、九州云、浪潮、中兴、EasyStack、有云。其中除了3家OpenStack创业公司以外，其他五家，都是各自行业里的巨无霸。如果再加上台湾的两家黄金会员，大中华区已经几乎占据了半壁江山。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这么多国内企业申请成为基金会黄金会员，也说明国内的企业经过了多年的教育后，对OpenStack社区有越来越高的认同度，同时也说明OpenStack基金会的黄金会员批准机制并不是“唯利是图”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;国内企业社区贡献&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国内参与社区的代码贡献，从2012年的几家企业，一直发展到今天的30多家国内企业参与社区代码贡献。10月份发布的Newton版本里，国内已经有好几篇盘点文章，从不同维度对国内企业对OpenStack社区代码的贡献进行了分析，从以前单纯关注Commit，到现在关注面已经扩大到完成Blueprints（实现功能）、Bug fix数量、代码行数和对项目的掌控能力，对各企业的社区贡献评价更全面，含金量也更高，有效避免单纯为了commit排名而刷榜灌水的行为。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenStack的代码贡献，其实也是符合二八原则，百分之八十有用的代码，都来自10～20%的社区贡献者，目前大部分项目的代码，都是Core team完成。2016年国内OpenStack Big Tent项目的Core数量，有了大幅增长。目前国内core数量最多的是华为和九州云，都是6个Core。不过中国总共30个左右的Core，在OpenStack社区几百个Core的总数里所占比例还有待提高，这也是众多国内企业积极努力的方向，Upstream first，努力提高中国开发者在国际开源社区的话语权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;华为向社区提交的Tricircle项目，实现OpenStack级联的功能，实现大规模的OpenStack统一管理，经过了2年努力，通过和社区、OpenStack技术委员会的不断交流，终于获得了认可，在2016年11月份，正式纳入的Big Tent项目。这其实也是一个里程碑事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国内参与OpenStack贡献的企业多起来，社区的互相合作，也成为一种趋势。Kolla通过Docker来部署OpenStack的项目，国内OpenStack公司如九州云，也认准这个方向，积极参与，互相合作，把Kolla变得更加完善，最终服务客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;容器化OpenStack潮流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在OpenStack逐步进入企业的过程中，升级一直都是一个难以逾越的门槛。OpenStack每年2个版本，并且项目越来越多，传统发行版厂商的包管理，已经无法解决OpenStack升级的问题。在容器和Docker流行以后，很多企业看到的希望，在峰会上很多企业分享自己在容器化OpenStack的经验和教训。OpenStack社区的容器化项目Kolla，也受到的很大的关注，Kolla项目的成熟度，已经让Mirantis感受到威胁。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年OpenStack圈里最有名的一个收购案例就是Mirantis收购TCP Cloud公司，收购目的就是为了补救当前公司在OpenStack容器化的短板。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;OpenStack成为NFV的标准模块&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OpenStack已经攻占了世界上主流的运营商，比如AT&amp;amp;T、Verizon、NTT、SK电信、中国移动、中国联通、德国电信、瑞士电信、英国电信等，而且也成为了NFV里NFVI的标准选择。AT&amp;amp;T通过利用NFV、SDN、OpenStack、OpenDaylight、Open vSwitch等技术，在接下来的几年中实现其网络75%的虚拟化。AT&amp;amp;T的NFV云已经包括了10个OpenStack项目，并计划在2016年年底之前推出3个云产品。Verizon也计划在未来3年内将其有线和无线网络元素大部分实现虚拟化（使用NFV和OpenStack），其中包括了数以万计的服务器规模部署。国内运营商入中国移动、中国电信也在NFV上积极推进，而OpenStack成为了它底层承载的标准选择。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然NFV的发展离真正成熟还存在一定距离，而OpenStack并不是NFV的全部，比如MANO模块，所以OpenStack推出了Tacker项目以弥补这一块短板，从L版开始孵化，M版本成为正式项目，只有博科、九州云、德国电信、NEC等几个参与者，到了N版本已经吸引了非常多的厂商投入，像华为、中兴、Redhat这些专攻运营商的企业也积极跟进，大有后来居上的势头。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGJic2z4mfCgTiapyaPWUpqypGIkPayfpLywibK10SWdHIqf8fUbHfqA7sg/0?wx_fmt=png"/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;图4 2016 Tacker主要厂商&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说在2016年，OpenStack的发展和机会并存，接近中场，国际大厂们开始进行洗牌和盘整，日本和中国公司随着本土市场的成熟，后来居上的势头很猛。和容器整合成为OpenStack供应商们技术角逐的终点战场，而OpenStack的NFV之路则逐渐开始明朗，并且朝着良好的方向前进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;&amp;nbsp;陈沙克，九州云技术副总裁，OpenStack骨灰级玩家，国内最早接触OpenStack的工程师，社区知名OpenStack技术专家。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;责编：&lt;/strong&gt;魏伟，欢迎技术投稿、约稿、给文章纠错，请发送邮件至weiwei@csdn.net。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 28 Dec 2016 17:28:59 +0800</pubDate>
    </item>
    <item>
      <title>C-Tech Awards 2016最具价值大奖评选活动</title>
      <link>http://www.iwgc.cn/link/4103107</link>
      <description>&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGdR4zyleG8kGMhqh0OkVSIsk2POXnOiacJHs4hAc9PbvjZH9BvQgrLdg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了表彰在过去一年中为推动IT行业发展做出贡献的企业和产品，CSDN将通过公开征集、CSDN行业数据及专家评审的方式评选出“C-Tech Awards 2016 最具价值大奖”，一方面我们希望突出产业中获得优异成功表现的企业，另一方面希望挖掘出具备发展潜力的产品。以“彰显技术力量，成就创新未来”为主题，向中国开发者展示来自全业界最前沿的技术实力及科技魅力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;奖项设置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本次评选活动是针对云计算、大数据、人工智能、物联网、互联网应用、开发服务提供商举行的大规模有奖评选活动，评选活动通过公开征集、CSDN行业数据及专家评审等手段，对参选厂商进行评选，最终选出综合奖“C-Tech Awards 2016 最具价值TOP50”，以及单项奖“最具品牌影响力奖、最具技术创新奖、最具成长潜力奖”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGZdu7xMlUqcicyM8JB5qkic0k4AITy2LllicuQg6G10wKP4HjUxgiax9d4w/0?wx_fmt=png"/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;评选流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;企业报名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;请扫描以下&lt;span&gt;&lt;strong&gt;二维码&lt;/strong&gt;&lt;/span&gt;或点击底部的&lt;span&gt;&lt;strong&gt;【阅读原文】&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGdOCzIRr6ib2PLIgoInBRce53Xc2Y3MiayQ1ba6O761IcILJ1vxqjrZlA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;填写申报材料&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，评委会将对企业和相关产品参评资格进行审核，并发送确认邮件；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络展示：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过CSDN审核的企业材料，会在本次大奖官方网站公示，并由相关专家点评。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;奖项终评：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;评委会将评选出 “C-Tech Awards 2016 最具价值TOP 50“、”最具品牌影响力奖“、”最具技术创新奖“、”最具成长潜力奖“。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;奖项颁发：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;本次大奖的所有奖项将于评选结束后，在线下的“C-Tech Awards 2016最具价值大奖颁奖典礼”上正式颁发。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGPEGZ8YjatH3NKMibYQS9WRG0yAJ2jepn6XJiaU1OJ5Taia8Btb8qia65sA/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;专家顾问&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcG5Ld2ic1NOYCbNDDDfZKANmnMIfDCYicqdXKbvxCYdO4AaGrvZbwW1xbA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;陈鸣&amp;nbsp;&lt;span&gt;CSDN总裁&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcG5CW0bIQiaWV98iauwANeTib9FdtaWrib749yRx2h1vsxKIuZSUsuFujFVQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;刘江&amp;nbsp;&lt;span&gt;美团技术学院院长&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcG24VCn34Is78HLYrxibtTxEQ69bmx865KAZPf13aCdwRiaaJQX4fkiaISA/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;卢亿雷&amp;nbsp;&lt;span&gt;精硕科技(AdMaster)技术副总裁兼总架构师&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGeo5icAMxUZpwj87t5icV3gxrgAnQvCibxVBnKvn0ZgSolFKIZ5FsLelGQ/0?wx_fmt=jpeg"/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;马力&amp;nbsp;&lt;span&gt;最美应用创始人&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_jpg/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGzZzpVfEZQFCtHRia3ACdIljWByfcELkU5AicqsWwmWqUHJJ9iajKgKibAQ/0?wx_fmt=jpeg"/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;沈剑&amp;nbsp;&lt;span&gt;58到家技术委员会主席&amp;amp;技术总监&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2016年，是一个不平凡的一年，在这一年，人工智能获得了长足的发展，AlphaGo战胜了人类围棋世界冠军，在这一年，神州九号也顺利发射升空，在国内掀起了又一股航天“热浪“。而也就是在这一年，“大众创新 万众创业“席卷神州大地，IT领域的创新浪潮一浪高过一浪，许多创新的技术、产品和企业如月后春笋般迅速成长。正是在此背景下，CSDN才能汇聚力量举办本次评选活动，活动的初衷是为了让真正能够给用户带来价值的创新技术、创新产品和创新企业，真正的被用户所认知、所了解、所使用，从而推动整个中国IT市场的发展。CSDN希望可以通过我们自身的努力，为中国的IT发展做出哪怕一点点的贡献。如果您是用户，我们希望您能够持续关注本次评选活动，同时欢迎您给予我们关于本次评选活动最真诚的建议与意见。如果您是企业，我们希望您能够参加本次评选活动，把你们的创新产品和技术推荐给更多的企业和用户去分享，去使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="line-height: 25.6px; white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;欢迎有意担任C-Tech Awards 2016最具价值大奖评审顾问的专家联系我们，邮箱：hanrui@csdn.net，电话：010-64376055/64351430。我们深信正因为有了您的参与和分享，CSDN才能成为一个卓越的平台。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;</description>
      <pubDate>Wed, 28 Dec 2016 17:28:59 +0800</pubDate>
    </item>
    <item>
      <title>深度卷积对抗生成网络(DCGAN)</title>
      <link>http://www.iwgc.cn/link/4103108</link>
      <description>&lt;blockquote style="line-height: 25.6px; white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;版权声明：本文为CSDN博主原创文章，未经博主允许不得转载。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;卷积神经网络在有监督学习中的各项任务上都有很好的表现，但在无监督学习领域，却比较少。本文介绍的算法将有监督学习中的CNN和无监督学习中的GAN结合到了一起。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote style="line-height: 25.6px; white-space: normal;"&gt;&lt;p&gt;&lt;span&gt;在非CNN条件下，LAPGAN在图像分辨率提升领域也取得了好的效果。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与其将本文看成是CNN的扩展，不如将其看成GAN的扩展到CNN领域。而GAN的基本算法，可以参考对抗神经网络。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GAN无需特定的cost function的优势和学习过程可以学习到很好的特征表示，但是GAN训练起来非常不稳定，经常会使得生成器产生没有意义的输出。而论文的贡献就在于：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为CNN的网络拓扑结构设置了一系列的限制来使得它可以稳定的训练。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用得到的特征表示来进行图像分类，得到比较好的效果来验证生成的图像特征表示的表达能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对GAN学习到的filter进行了定性的分析。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;展示了生成的特征表示的向量计算特性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;模型结构&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;模型结构上需要做如下几点变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将pooling层convolutions替代，其中，在discriminator上用strided convolutions替代，在generator上用fractional-strided convolutions替代。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在generator和discriminator上都使用batchnorm。&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决初始化差的问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;帮助梯度传播到每一层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;防止generator把所有的样本都收敛到同一个点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;直接将BN应用到所有层会导致样本震荡和模型不稳定，通过在generator输出层和discriminator输入层不采用BN可以防止这种现象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;移除全连接层&amp;nbsp;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=" list-paddingleft-2" style="list-style-type: circle;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;global pooling增加了模型的稳定性，但伤害了收敛速度。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在generator的除了输出层外的所有层使用ReLU，输出层采用tanh。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在discriminator的所有层上使用LeakyReLU。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DCGAN的generator网络结构：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGF1YPnG1fjvNGobCZ7QjibfsqvySpaicm4ichR83U52AdJ9NAZwMNL9elw/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，这里的conv层是four fractionally-strided convolution，在其他的paper中也可能被称为是deconvolution.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;训练细节&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=" list-paddingleft-2" style="width: 528.188px; line-height: 25.6px; white-space: normal;"&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预处理环节，将图像scale到tanh的[-1, 1]。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;mini-batch训练，batch size是128.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有的参数初始化由(0, 0.02)的正态分布中随即得到&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LeakyReLU的斜率是0.2.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虽然之前的GAN使用momentum来加速训练，DCGAN使用调好超参的Adam optimizer。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;learning rate=0.0002&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将momentum参数beta从0.9降为0.5来防止震荡和不稳定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;LSUN效果图&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过一次循环的训练(online learning)和收敛后得模型得到的效果分别如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGgBSBwkgCpYuPGSMpzMKkUmGtAWPr6gfncCNhXuq285QB5Nhj9T2xibQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这表明了DCGAN不是通过记忆训练数据来生成/过拟合高质量的图片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;DCGAN capabilities验证&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了验证DCGAN的特征表示的有效性，将特征表示输入到L2-SVM中，并将分类结果与其他的无监督学习算法进行对比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了做到这一点，使用在ImageNet-1K上训练得到的generator，使用所有层的所有CNN特征作为输入，将每一层的CNN特征使用max-pooling的方式降到4×4，然后展开，形成一个28672维的向量，输入到L2-SVM中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mnist数据集上的效果对比：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGr5H08HO4LZra2V8eFb80YjMEibJfg26hqzht26SF33cUQRYLc0VibHaA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SVNH数据集上的对比：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGfLlLq0MvicbI7Nd9PTx9FiaO2Cdfb8Y5XJoXxPUs37DtjjN4VvqgNicHQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;漫游隐空间&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过慢慢的调整初始向量来探索隐空间是如何影响最终图片的生成的。这样，既可以探索图片特征是如何折叠到隐空间的，又可以判断这些图片是由于真正学习到了语义特征还是只是记住了图片（如果有sharp的变化）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcG5AZLuoclIpZRP0XibFBQpAnRNjsHKhfPdysmDbWETe7gCsbeEXH8lHg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGdibH1VUYF2F2JuVvwCR88aw8FnOwSuoZX8ZAF5kvye1lfWaDc0bzRaw/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由上图，可以看到一些逐渐的变化，比如第六行中，逐渐有了一个窗户。第四行中，电视逐渐消失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;Discriminator Filter&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过分析filter，我们可以看到，在对房屋特征的学习中，GAN确实学习到了床、窗口等特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcG9GSglwR1AiaR5q3bmLTfqrJVrLRKG37PWeBCKg4yhBAX3Z8NBPOBe7w/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;左侧是随机filter，右侧是学习到的filter，可见，右侧的filter还是有意义的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;Semantic Mask&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在隐空间上，假设知道哪几个变量控制着某个物体，那么僵这几个变量挡住是不是就可以将生成图片中的某个物体消失？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文中的实验是这样的：首先，生成150张图片，包括有窗户的和没有窗户的，然后使用一个逻辑斯底回归函数来进行分类，对于权重不为0的特征，认为它和窗户有关。将其挡住，得到新的生成图片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGEqDkffRCQK4LBwwY0Ilm9WaIgsJJpem6JCuUMRicfiaQC5vxFzU5Ddgg/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;Vector Arithmetic&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似于word2vec，图像是不是也有类似的特点，可以在隐空间里进行加减法来得到新的图像？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实验表明，使用单张图片的表示并不稳定，使用三张图片会比较稳定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGYOPQddRlica8ibftQpzbfciah6VV4aL8nWAHUiaIzwg0Tic1Z2Z59h4QgjA/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcG9nvXVfT7ZIU06gN0bS8Rfwznsuko4X2XErUXSqcNPf6KtlLDfH4Nng/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，单张图片并不稳定，而三张图片则可以学到表情和墨镜等特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更甚者，可以学到一个稳定的向量，来进行某种变换，比如，方位变换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuhicBqQcZYnmKk5kF5EYDIcGZ5Me87EqjKExcE5BM6MUlibeULF6pSoxwMNu6SLKbKNLGmibyh4Dx6dw/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;section&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;/section&gt;&lt;section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这篇paper的主要贡献看似简单，但其实工作量很大，充分展现出作者在调参大法上的卓越功力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但我觉得，更大的贡献在于作者对于效果的研究方式，生成模型很难来区分好与坏，而本paper通过探索隐空间，分析网络，比较特征表现能力等一系列手段，证明了DCGAN算法确实是一个强大的算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Wed, 28 Dec 2016 17:28:59 +0800</pubDate>
    </item>
  </channel>
</rss>
