<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>AlgorithmDog</title>
    <link>http://www.iwgc.cn/list/5566</link>
    <description>AlgorithmDog 讲述机器学习和系统研发的轶事,希望把这些事讲得生动有趣.每周日更新哦.欢迎关注.</description>
    <item>
      <title>广告和推荐系统部署机器学习模型的两种架构</title>
      <link>http://www.iwgc.cn/link/4461852</link>
      <description>&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 广告和推荐系统是机器学习是最成熟的应用领域。那么广告和推荐系统是怎么在线上部署机器学习模型的呢？&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvPDgBBat7R9ic1eRsadA1ywTfMTMtQqdKpRaXFGLsQFYFzJNPODheTNo0NcFsXIpWAQFvn68myNfoQ/0?wx_fmt=png"/&gt;&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;1.预测函数上线&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;刚刚学习机器学习时候，我认为广告和推荐系统过程如下图所示：1）线下部分，从用户和广告（物品）属性抽取用户和物品特征，将抽取的特征合并进日志生成训练数据，训练机器学习模型；2）线上部分，来了一个请求，从用户和广告（物品）属性抽取请求中的用户和物品的特征，将这些特征合并请求生成预测实例，用线上模型得到预测结果。&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-3787" style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvPDgBBat7R9ic1eRsadA1ywTOKUNoE0rqNiauxhkUpK61H5YBXgczvyd3G2BwoP8ujpqicE7bEn29M4g/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;但是这个架构有两个问题：1）从用户和广告（物品）属性抽取特征的程序有线上线下两套，这两套程序必须保持完全一致。但由于调参的原因，特征抽取是机器学习系统中最经常发生变化的模块。经常变化的模块需要保持一致，这很困难。那么我们能不能强行地用一套程序呢？比如，我们把特征抽取和特征处理模块写成 .so 文件。这样也有问题：线下要求快速变化以方便工程师调特征，可能会使用一些训练框架（比如 Spark）；线上要求程序快速实时，要求工程师编码严谨。写成严谨的 .so 文件，能够保证线上的需求，但无法快速变化，也不能在 Spark 上使用。2）线上特征抽取要求非常快速，特别在线上吞吐量很大的情况。但有些重度特征不可能在短时间内抽取出来，比如广告的历史点击率（生成这个特征需要遍历一段时间的点击日志）。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在读书期间，这两个问题困扰了我很久, 直到 2014 年我知道了神器 Redis。Redis 是一个开源内存数据库，支持集群模式、持久化和 Key-Value 数据结构。在使用时，我们可以将 Redis 看成一个巨大的哈希表。Redis 在后台开发中经常用作 cache 服务器, 后来被工程师们用于广告和推荐系统中的特征服务器。工程师将用户和广告（物品）的 ID 作为 Key，将用户和广告（物品）的特征作为 Value 存入 Redis，这样线上程序只需要用户和广告（物品）的 ID 就能知道特征。引入 Redis 之后，广告和推荐系统过程如下所示：1）线下部分，从用户和广告（物品）属性抽取用户和广告（物品）特征，把抽取的特征合并进日志生成训练数据用于训练机，并把抽取的特征上载到线上 Redis 服务器；2）线上部分，来了一个请求，从 Redis 服务器取出用户和广告（物品）特征，将特征合并进请求生成预测实例，用线上模型得到预测结果。&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-3788" style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvPDgBBat7R9ic1eRsadA1ywT3D30hwOgSaIUiaQN9Hd4htruqu0sCto3icmRfsHMF2LM87BCWAAJA6aQ/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这种架构还有一个变种：在线下抽取特征之后不生成训练数据而是直接送到 Redis，在线上用 Storm 实时拼接训练数据。但我对这个变种的前因后果不太了解，就不展开讨论了。这种架构将预测函数（也就是训练出来的模型）部署在线上。为了和下面的架构区分开来，我们将这种架构称为预测函数上线架构。&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;2.预测结果上线&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;了解预测函数上线架构之后，我将之作为广告和推荐系统线上部署模型的 “正统”。 因此当 2014 年我接触到另一种架构时，我内心是拒绝的。这种架构的要点在于把预测结果上线，具体过程如下所示：1）在线上，从用户和广告（物品）属性抽取用户和物品特征，将抽取的特征合并进日志生成训练数据，训练机器学习模型；将几乎所有可能的请求合并特征，进而生成预测实例，用模型得到预测结果；2）线上就很简单了，接入线下传过来的预测结果。这里稍微难理解的是 “穷尽几乎所有可能的请求”，疑惑那么多可能的请求怎么可能穷尽呢？微博广告系统（虚构的）所有可能的请求貌似很多，但每个用户只需要匹配若干个广告就行了。因此微博广告系统的预测结果 “userid,adid1,adid2...,adidn” 上载到线上，一旦线上传一个 userid 请求展示广告，线上模块就按照一定的逻辑返回预测结果中这个用户对应的广告。这种架构是将预测结果部署到线上，我们将之称为预测结果上线架构。&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-3793" style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvPDgBBat7R9ic1eRsadA1ywTxOliafkslV1yls6yQQ9ic6XwVUF9B64qNc1G2DHCLQqjj2P7moGic6hdA/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;慢慢地我也开始明白预测结果上线的好处了。预测结果上线架构将机器学习全过程和绝大部分控制逻辑都搬到线下，规避了线上的各种隐患。这样不那么厉害的工程师用不那么厉害的机器也能搞定线上模块了，毕竟线上模块只需要实现少量的控制逻辑和展示。这大大降低了建立一个广告系统或者推荐系统的难度。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我正式工作之后，组里支持运营活动的推荐系统采用了预测结果上线的架构。我发现有不少时间浪费在重跑数据上，原因在于有时需要临时增加或者删除物品。一旦增加或者删除物品，预测结果上线的推荐系统就需要重新生成预测数据（因此之前跑的数据要么没有要加的物品，要么有要删的数据）。另外一个问题就是预测结果上线架构有延时性：今天线上展示的是昨天准备的预测结果，今天准备的预测结果要等明天才能展示，这会导致节奏慢一些。最后还有一个问题，预测结果上线架构只适用于几乎所有可能的请求能够穷尽的场景。比如，预测结果上线架构不适用于搜索广告系统，因为搜索广告系统不能穷尽所有可能的请求。&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;3.总结&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;预测函数上线架构能够覆盖预测结果上线架构的适用场景，但是预测结果上线架构不能够覆盖预测函数上线架构的适用场景。同时预测函数上线架构更具灵活性。预测函数上线架构不愧为部署机器学习模型的 “堂堂正正” 之法。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;预测结果上线架构的好处就是难度比较低。预测结果上线架构将机器学习全过程和绝大部分控制逻辑，规避了线上的各种隐患。在机器、时间和人力等各种条件不充足的情况，预测结果上线架构不失为一个好的选择。预测结果上线架构是 “剑走偏锋” 的机器学习模型部署之法。兵法有云：以正合以奇胜，选择哪一种架构还是需要仔细的分析和权衡。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最后欢迎关注我的公众号，每两周的更新就会有提醒哦~&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-2360" style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvPDgBBat7R9ic1eRsadA1ywTDVuXj4Cc3ArRsMKzicuyyKyyibWJ4vrO2B5V1a6xiaRRuEzze8UeA8L2Q/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Mon, 23 Jan 2017 19:54:46 +0800</pubDate>
    </item>
    <item>
      <title>Akka 使用系列之二: 测试</title>
      <link>http://www.iwgc.cn/link/4417592</link>
      <description>&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 通过上一篇文章，我们已经大致了解怎么使用 Akka，期待细致用法。这篇文章将介绍如何用 Akka-testkit 对 Akka 程序进行测试。&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-3677" style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjGru1BXTVuciaicTpHxCB5nvU5WBx2KueTDD7MnXlHZCbyCgUMokhibnaA/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;并行程序是最难调试的程序类型之一，因此做好测试是相当重要的事情。为了减轻 Akka 的程序的测试难度, Akka 官方专门开发了一个测试工具包 Akka-testkit。&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;1 Actor 的测试需求&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于一个 Actor, 我们要测什么呢？不同的文章有不同的说法，比如&lt;a style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;http://rerun.me/2014/09/29/akka-notes-logging-and-testing/&amp;nbsp;&lt;/a&gt;就把 Actor 测试需求分为:1)发送消息给 Actors, 2)测试内部状态，3）测试日志和 4)带参数 Actor 的测试。我个人认为，对于一个 Actor, 我们要测的有三个方面：1）Actor 接收消息之后，是否返回正确的消息，2）Actor 接收消息之后，是否正确地改变内部状态和执行内部行为，3）Actor 接收消息之后，是否正确地发消息给后续 Actor。当然这是我的一家之言，有什么不完善的地方，欢迎大家讨论。下面是一个简单的示例图。&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-3758" style="   ; ; ; ; ; ; ;   "&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjrmOAiczwj8FdRXOlOArrClG3Gm9np2X2BYRqpcoH1JTxcESbeoibdppw/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;下面是 studentActor 的一段代码，反应了 studentActor 接受到早上时间消息之后的动作，包括：1）给环境或者闹钟回应“关闭闹钟”，2）内部变量 DayInSchool 加 1，3）向老师发送问题消息。这段代码将包含所有要测试的元素，后面我们将示例怎么用 Akka-testkit 测试这段代码。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjiafIBsGUXpgBqic2rzCFPaPQuBWeVsU3KojLialwN7xB8YNhXcXbFx1vg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;2 不适用的 Scalatest&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Scalatest 是 Scala 开发者们最常见的测试工具，其用法非常简便。下面是一个 Scalatest 的简单示例。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjYNhNs0NNOokRM8M88xHG8U0x0BDzllM4GJBS9icGyjNeavQKxl8bt2A/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;但是我们无法使用 scalatest 测试 Actor。原因在于：1）Scalatest 无法捕捉被测 Actor 回应的消息，因此无法测试被测 Actor 是否正确回应消息; 2）Scalatest 无法获取被测 Actor 的内部状态，因此无法测试被测 Actor 内部状态的改变是否正确; 3) Scalatest 无法捕捉被测 Actor 对外发送的消息，因此无法测试被测 Actor 对外发送的消息是否正确。因此有必要针对 Akka 开发一套测试工具, Akka-testkit 测试包应运而生。&lt;br/&gt;&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;3 Akka-testkit 的使用&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Maven 项目要使用 Akka-testkit，需要在 pom.xml 文件中加入 akka-testkit 包，如下所示。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjFnlrEOzw2KIzt2Ykfc7TZkIdq6lJrYxbRyibQMIgNxEks3ibdhNTfJeQ/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;然后编写单元测试的代码，其基本范例如下。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjrvmyp34SHF6ZyIM3op6jqYFCwJga8bOaqs8eJBFyzQqibXDMh3QuIzQ/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Akka-testkit 的主要工具包括, 1) testProbe 用于测试 Actor 回应和发送消息，testActor 用于简便情况下测试 Actor 回应消息，和 2) testActorRef 用于测试 Actor 内部状态的改变。&lt;br/&gt;&lt;/p&gt;&lt;h4 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 24px;"&gt;&lt;span&gt;3.1 回应消息的测试&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于被测 Actor 是否正确地回应消息，可以用 testProbe 测试。首先将 testProbe 给被测 Actor 发送消息，再看 testProbe 是否接受到期望的回应消息。下面是一个示例。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjR2BpdZPV78mMdDeFOjdvX0ibRnvuUqZjt1auHx6ic99973Su2BQIiaeAw/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;除了使用 testProbe 之外，Akka-testkit 还提供一种简便方法: 使用 testActor。 如果测试类实现特质 ImplicitSender， studentActorRef ! 7.toLong 发送给 studentActor 的消息 7.toLong 就是从 testActor 来的。然后在调用 expectMsg("关闭闹钟") 就可以测试 testActor 是否收到 studentActor 回应消息 "关闭闹钟" 了。具体代码如下所示。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjEIDEU9hyqtHDZwVcIOnJBOaNSmVsgq8YSvgHpqBaicEEKDlwm8oVnoA/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;我们可以看出，使用 testActor 的代码比使用 testProbe 的简便。但是，一个东西的用法越是简便，功能便越缺失。testActor 最大的缺失是只能接受被测 Actor 发来的一个回应消息。比如下面的代码就会报错。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjqWdvVbCbw21qicPSN5ds2mgBDuC8PN0uSKicpEs0hicnuNfJFXSGKfCsg/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h4 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 24px;"&gt;&lt;/h4&gt;&lt;h4 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 24px;"&gt;&lt;span&gt;3.2 内部状态的测试&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于被测 Actor 内部状态的改变，可以用 TestActorRef 进行测试。TestActorRef.underlyingActor 可以探测被测 Actor 的内部，用于测试被测 Actor 内部状态是否符合预期。 下面是一个示例。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjOVD4neibiaaLpYNbVUuo9xzyEDboM8KJlWLQv3icpej658GJFzdG9o70g/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h4 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 24px;"&gt;3.3 发出消息的测试&lt;/h4&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对于被测 Actor 是否正确地发出消息，也可以用 testProbe 测试。首先将 testProbe 设置为被测 Actor 发出消息的目标，然后让被测 Actor 发出消息，再看 testProbe 是否接受到期望的消息。下面是一个示例。&lt;/p&gt;&lt;p&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjLdeic3NRuYxvzIjJSJoAhic0La0uiaibmcmQrDROWnurAaevlJicccDNmhw/0?wx_fmt=png"/&gt;&lt;br/&gt;&lt;/p&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;4 总结&lt;/span&gt;&lt;/h3&gt;&lt;hr&gt;&lt;h3 style="border: 0px; margin-bottom: 10px; vertical-align: baseline; clear: both; line-height: 1.5em;"&gt;&lt;span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Akka-testkit 是 Akka 官方推出的 Akka 测试工具包，用于减轻 Akka 程序的测试难度。Akka-testkit 的主要工具包括, 1) testProbe 用于测试被测 Actor 回应和发送消息，testActor 用于简便情况下测试被测 Actor 回应消息，和 2) testActorRef 用于测试被测 Actor 内部状态的改变。完整的项目代码已经上传到&amp;nbsp;&lt;a style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;/a&gt;https: //github. com/ AlgorithmDog/ AkkaUsageLearner&amp;nbsp;上了。被测 Actor 是 org. algorithmdog. akkalearning. StudentActor, 测试类是 org. algorithmdog. akkalearning. StudentActorTest。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这篇文章难产了很长一段时间，对不住支持我的读者们。对不起。Akka 和 Actor 模型对我来说是一个全新的东西，花了比较多的时间学习和熟悉。学习之后，觉得第一篇写得太不清楚了，准备重构第一篇。对于这篇文章质量，我个人比较满意的，甚至敢认为这篇文章应该是国内关于 Akka-testkit 最清楚的文章之一（ps:大牛们轻喷）。最后欢迎关注我的公众号，每两周的更新就会有提醒哦~&lt;/p&gt;&lt;p&gt;&lt;a rel="attachment wp-att-2360" style="border: 0px; vertical-align: baseline; color: rgb(116, 51, 153); background: transparent;"&gt;&lt;img src="https://images.weserv.nl/?url=mmbiz.qpic.cn/mmbiz_png/Q3H1TCddfvMSOOpWZIN8qK9coArqicAKjfkDr54GgJUqVdiaicS6q17X9zqLMHNQObMZiaBM6xyS6s2TiaxZQER9xTw/0?wx_fmt=png"/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;</description>
      <pubDate>Fri, 20 Jan 2017 08:49:06 +0800</pubDate>
    </item>
  </channel>
</rss>
